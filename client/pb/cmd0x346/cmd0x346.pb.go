// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cmd0x346.proto

package cmd0x346

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ApplyCleanTrafficRsp struct {
	RetCode int32  `protobuf:"varint,10,opt,name=retCode,proto3" json:"retCode,omitempty"`
	RetMsg  string `protobuf:"bytes,20,opt,name=retMsg,proto3" json:"retMsg,omitempty"`
}

func (m *ApplyCleanTrafficRsp) Reset()         { *m = ApplyCleanTrafficRsp{} }
func (m *ApplyCleanTrafficRsp) String() string { return proto.CompactTextString(m) }
func (*ApplyCleanTrafficRsp) ProtoMessage()    {}
func (*ApplyCleanTrafficRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{0}
}
func (m *ApplyCleanTrafficRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyCleanTrafficRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyCleanTrafficRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplyCleanTrafficRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyCleanTrafficRsp.Merge(m, src)
}
func (m *ApplyCleanTrafficRsp) XXX_Size() int {
	return m.Size()
}
func (m *ApplyCleanTrafficRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyCleanTrafficRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyCleanTrafficRsp proto.InternalMessageInfo

func (m *ApplyCleanTrafficRsp) GetRetCode() int32 {
	if m != nil {
		return m.RetCode
	}
	return 0
}

func (m *ApplyCleanTrafficRsp) GetRetMsg() string {
	if m != nil {
		return m.RetMsg
	}
	return ""
}

type ApplyCopyFromReq struct {
	SrcUin          int64  `protobuf:"varint,10,opt,name=srcUin,proto3" json:"srcUin,omitempty"`
	SrcGroup        int64  `protobuf:"varint,20,opt,name=srcGroup,proto3" json:"srcGroup,omitempty"`
	SrcSvcid        int32  `protobuf:"varint,30,opt,name=srcSvcid,proto3" json:"srcSvcid,omitempty"`
	SrcParentfolder []byte `protobuf:"bytes,40,opt,name=srcParentfolder,proto3" json:"srcParentfolder,omitempty"`
	SrcUuid         []byte `protobuf:"bytes,50,opt,name=srcUuid,proto3" json:"srcUuid,omitempty"`
	FileMd5         []byte `protobuf:"bytes,60,opt,name=fileMd5,proto3" json:"fileMd5,omitempty"`
	DstUin          int64  `protobuf:"varint,70,opt,name=dstUin,proto3" json:"dstUin,omitempty"`
	FileSize        int64  `protobuf:"varint,80,opt,name=fileSize,proto3" json:"fileSize,omitempty"`
	FileName        string `protobuf:"bytes,90,opt,name=fileName,proto3" json:"fileName,omitempty"`
	DangerLevel     int32  `protobuf:"varint,100,opt,name=dangerLevel,proto3" json:"dangerLevel,omitempty"`
	TotalSpace      int64  `protobuf:"varint,110,opt,name=totalSpace,proto3" json:"totalSpace,omitempty"`
}

func (m *ApplyCopyFromReq) Reset()         { *m = ApplyCopyFromReq{} }
func (m *ApplyCopyFromReq) String() string { return proto.CompactTextString(m) }
func (*ApplyCopyFromReq) ProtoMessage()    {}
func (*ApplyCopyFromReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{1}
}
func (m *ApplyCopyFromReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyCopyFromReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyCopyFromReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplyCopyFromReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyCopyFromReq.Merge(m, src)
}
func (m *ApplyCopyFromReq) XXX_Size() int {
	return m.Size()
}
func (m *ApplyCopyFromReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyCopyFromReq.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyCopyFromReq proto.InternalMessageInfo

func (m *ApplyCopyFromReq) GetSrcUin() int64 {
	if m != nil {
		return m.SrcUin
	}
	return 0
}

func (m *ApplyCopyFromReq) GetSrcGroup() int64 {
	if m != nil {
		return m.SrcGroup
	}
	return 0
}

func (m *ApplyCopyFromReq) GetSrcSvcid() int32 {
	if m != nil {
		return m.SrcSvcid
	}
	return 0
}

func (m *ApplyCopyFromReq) GetSrcParentfolder() []byte {
	if m != nil {
		return m.SrcParentfolder
	}
	return nil
}

func (m *ApplyCopyFromReq) GetSrcUuid() []byte {
	if m != nil {
		return m.SrcUuid
	}
	return nil
}

func (m *ApplyCopyFromReq) GetFileMd5() []byte {
	if m != nil {
		return m.FileMd5
	}
	return nil
}

func (m *ApplyCopyFromReq) GetDstUin() int64 {
	if m != nil {
		return m.DstUin
	}
	return 0
}

func (m *ApplyCopyFromReq) GetFileSize() int64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *ApplyCopyFromReq) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *ApplyCopyFromReq) GetDangerLevel() int32 {
	if m != nil {
		return m.DangerLevel
	}
	return 0
}

func (m *ApplyCopyFromReq) GetTotalSpace() int64 {
	if m != nil {
		return m.TotalSpace
	}
	return 0
}

type ApplyCopyFromRsp struct {
	RetCode    int32  `protobuf:"varint,10,opt,name=retCode,proto3" json:"retCode,omitempty"`
	RetMsg     string `protobuf:"bytes,20,opt,name=retMsg,proto3" json:"retMsg,omitempty"`
	Uuid       []byte `protobuf:"bytes,30,opt,name=uuid,proto3" json:"uuid,omitempty"`
	TotalSpace int64  `protobuf:"varint,40,opt,name=totalSpace,proto3" json:"totalSpace,omitempty"`
}

func (m *ApplyCopyFromRsp) Reset()         { *m = ApplyCopyFromRsp{} }
func (m *ApplyCopyFromRsp) String() string { return proto.CompactTextString(m) }
func (*ApplyCopyFromRsp) ProtoMessage()    {}
func (*ApplyCopyFromRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{2}
}
func (m *ApplyCopyFromRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyCopyFromRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyCopyFromRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplyCopyFromRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyCopyFromRsp.Merge(m, src)
}
func (m *ApplyCopyFromRsp) XXX_Size() int {
	return m.Size()
}
func (m *ApplyCopyFromRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyCopyFromRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyCopyFromRsp proto.InternalMessageInfo

func (m *ApplyCopyFromRsp) GetRetCode() int32 {
	if m != nil {
		return m.RetCode
	}
	return 0
}

func (m *ApplyCopyFromRsp) GetRetMsg() string {
	if m != nil {
		return m.RetMsg
	}
	return ""
}

func (m *ApplyCopyFromRsp) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *ApplyCopyFromRsp) GetTotalSpace() int64 {
	if m != nil {
		return m.TotalSpace
	}
	return 0
}

type ApplyCopyToReq struct {
	DstId         int64  `protobuf:"varint,10,opt,name=dstId,proto3" json:"dstId,omitempty"`
	DstUin        int64  `protobuf:"varint,20,opt,name=dstUin,proto3" json:"dstUin,omitempty"`
	DstSvcid      int32  `protobuf:"varint,30,opt,name=dstSvcid,proto3" json:"dstSvcid,omitempty"`
	SrcUin        int64  `protobuf:"varint,40,opt,name=srcUin,proto3" json:"srcUin,omitempty"`
	FileSize      int64  `protobuf:"varint,50,opt,name=fileSize,proto3" json:"fileSize,omitempty"`
	FileName      string `protobuf:"bytes,60,opt,name=fileName,proto3" json:"fileName,omitempty"`
	LocalFilepath string `protobuf:"bytes,70,opt,name=localFilepath,proto3" json:"localFilepath,omitempty"`
	Uuid          []byte `protobuf:"bytes,80,opt,name=uuid,proto3" json:"uuid,omitempty"`
}

func (m *ApplyCopyToReq) Reset()         { *m = ApplyCopyToReq{} }
func (m *ApplyCopyToReq) String() string { return proto.CompactTextString(m) }
func (*ApplyCopyToReq) ProtoMessage()    {}
func (*ApplyCopyToReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{3}
}
func (m *ApplyCopyToReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyCopyToReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyCopyToReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplyCopyToReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyCopyToReq.Merge(m, src)
}
func (m *ApplyCopyToReq) XXX_Size() int {
	return m.Size()
}
func (m *ApplyCopyToReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyCopyToReq.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyCopyToReq proto.InternalMessageInfo

func (m *ApplyCopyToReq) GetDstId() int64 {
	if m != nil {
		return m.DstId
	}
	return 0
}

func (m *ApplyCopyToReq) GetDstUin() int64 {
	if m != nil {
		return m.DstUin
	}
	return 0
}

func (m *ApplyCopyToReq) GetDstSvcid() int32 {
	if m != nil {
		return m.DstSvcid
	}
	return 0
}

func (m *ApplyCopyToReq) GetSrcUin() int64 {
	if m != nil {
		return m.SrcUin
	}
	return 0
}

func (m *ApplyCopyToReq) GetFileSize() int64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *ApplyCopyToReq) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *ApplyCopyToReq) GetLocalFilepath() string {
	if m != nil {
		return m.LocalFilepath
	}
	return ""
}

func (m *ApplyCopyToReq) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

type ApplyCopyToRsp struct {
	RetCode int32  `protobuf:"varint,10,opt,name=retCode,proto3" json:"retCode,omitempty"`
	RetMsg  string `protobuf:"bytes,20,opt,name=retMsg,proto3" json:"retMsg,omitempty"`
	FileKey string `protobuf:"bytes,30,opt,name=fileKey,proto3" json:"fileKey,omitempty"`
}

func (m *ApplyCopyToRsp) Reset()         { *m = ApplyCopyToRsp{} }
func (m *ApplyCopyToRsp) String() string { return proto.CompactTextString(m) }
func (*ApplyCopyToRsp) ProtoMessage()    {}
func (*ApplyCopyToRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{4}
}
func (m *ApplyCopyToRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyCopyToRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyCopyToRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplyCopyToRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyCopyToRsp.Merge(m, src)
}
func (m *ApplyCopyToRsp) XXX_Size() int {
	return m.Size()
}
func (m *ApplyCopyToRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyCopyToRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyCopyToRsp proto.InternalMessageInfo

func (m *ApplyCopyToRsp) GetRetCode() int32 {
	if m != nil {
		return m.RetCode
	}
	return 0
}

func (m *ApplyCopyToRsp) GetRetMsg() string {
	if m != nil {
		return m.RetMsg
	}
	return ""
}

func (m *ApplyCopyToRsp) GetFileKey() string {
	if m != nil {
		return m.FileKey
	}
	return ""
}

type ApplyDownloadAbsReq struct {
	Uin  int64  `protobuf:"varint,10,opt,name=uin,proto3" json:"uin,omitempty"`
	Uuid []byte `protobuf:"bytes,20,opt,name=uuid,proto3" json:"uuid,omitempty"`
}

func (m *ApplyDownloadAbsReq) Reset()         { *m = ApplyDownloadAbsReq{} }
func (m *ApplyDownloadAbsReq) String() string { return proto.CompactTextString(m) }
func (*ApplyDownloadAbsReq) ProtoMessage()    {}
func (*ApplyDownloadAbsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{5}
}
func (m *ApplyDownloadAbsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyDownloadAbsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyDownloadAbsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplyDownloadAbsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyDownloadAbsReq.Merge(m, src)
}
func (m *ApplyDownloadAbsReq) XXX_Size() int {
	return m.Size()
}
func (m *ApplyDownloadAbsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyDownloadAbsReq.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyDownloadAbsReq proto.InternalMessageInfo

func (m *ApplyDownloadAbsReq) GetUin() int64 {
	if m != nil {
		return m.Uin
	}
	return 0
}

func (m *ApplyDownloadAbsReq) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

type ApplyDownloadAbsRsp struct {
	RetCode      int32         `protobuf:"varint,10,opt,name=retCode,proto3" json:"retCode,omitempty"`
	RetMsg       string        `protobuf:"bytes,20,opt,name=retMsg,proto3" json:"retMsg,omitempty"`
	DownloadInfo *DownloadInfo `protobuf:"bytes,30,opt,name=downloadInfo,proto3" json:"downloadInfo,omitempty"`
}

func (m *ApplyDownloadAbsRsp) Reset()         { *m = ApplyDownloadAbsRsp{} }
func (m *ApplyDownloadAbsRsp) String() string { return proto.CompactTextString(m) }
func (*ApplyDownloadAbsRsp) ProtoMessage()    {}
func (*ApplyDownloadAbsRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{6}
}
func (m *ApplyDownloadAbsRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyDownloadAbsRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyDownloadAbsRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplyDownloadAbsRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyDownloadAbsRsp.Merge(m, src)
}
func (m *ApplyDownloadAbsRsp) XXX_Size() int {
	return m.Size()
}
func (m *ApplyDownloadAbsRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyDownloadAbsRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyDownloadAbsRsp proto.InternalMessageInfo

func (m *ApplyDownloadAbsRsp) GetRetCode() int32 {
	if m != nil {
		return m.RetCode
	}
	return 0
}

func (m *ApplyDownloadAbsRsp) GetRetMsg() string {
	if m != nil {
		return m.RetMsg
	}
	return ""
}

func (m *ApplyDownloadAbsRsp) GetDownloadInfo() *DownloadInfo {
	if m != nil {
		return m.DownloadInfo
	}
	return nil
}

type ApplyDownloadReq struct {
	Uin       int64  `protobuf:"varint,10,opt,name=uin,proto3" json:"uin,omitempty"`
	Uuid      []byte `protobuf:"bytes,20,opt,name=uuid,proto3" json:"uuid,omitempty"`
	OwnerType int32  `protobuf:"varint,30,opt,name=ownerType,proto3" json:"ownerType,omitempty"`
	ExtIntype int32  `protobuf:"varint,500,opt,name=extIntype,proto3" json:"extIntype,omitempty"`
}

func (m *ApplyDownloadReq) Reset()         { *m = ApplyDownloadReq{} }
func (m *ApplyDownloadReq) String() string { return proto.CompactTextString(m) }
func (*ApplyDownloadReq) ProtoMessage()    {}
func (*ApplyDownloadReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{7}
}
func (m *ApplyDownloadReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyDownloadReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyDownloadReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplyDownloadReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyDownloadReq.Merge(m, src)
}
func (m *ApplyDownloadReq) XXX_Size() int {
	return m.Size()
}
func (m *ApplyDownloadReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyDownloadReq.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyDownloadReq proto.InternalMessageInfo

func (m *ApplyDownloadReq) GetUin() int64 {
	if m != nil {
		return m.Uin
	}
	return 0
}

func (m *ApplyDownloadReq) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *ApplyDownloadReq) GetOwnerType() int32 {
	if m != nil {
		return m.OwnerType
	}
	return 0
}

func (m *ApplyDownloadReq) GetExtIntype() int32 {
	if m != nil {
		return m.ExtIntype
	}
	return 0
}

type ApplyDownloadRsp struct {
	RetCode      int32         `protobuf:"varint,10,opt,name=retCode,proto3" json:"retCode,omitempty"`
	RetMsg       string        `protobuf:"bytes,20,opt,name=retMsg,proto3" json:"retMsg,omitempty"`
	DownloadInfo *DownloadInfo `protobuf:"bytes,30,opt,name=downloadInfo,proto3" json:"downloadInfo,omitempty"`
	FileInfo     *FileInfo     `protobuf:"bytes,40,opt,name=fileInfo,proto3" json:"fileInfo,omitempty"`
}

func (m *ApplyDownloadRsp) Reset()         { *m = ApplyDownloadRsp{} }
func (m *ApplyDownloadRsp) String() string { return proto.CompactTextString(m) }
func (*ApplyDownloadRsp) ProtoMessage()    {}
func (*ApplyDownloadRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{8}
}
func (m *ApplyDownloadRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyDownloadRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyDownloadRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplyDownloadRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyDownloadRsp.Merge(m, src)
}
func (m *ApplyDownloadRsp) XXX_Size() int {
	return m.Size()
}
func (m *ApplyDownloadRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyDownloadRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyDownloadRsp proto.InternalMessageInfo

func (m *ApplyDownloadRsp) GetRetCode() int32 {
	if m != nil {
		return m.RetCode
	}
	return 0
}

func (m *ApplyDownloadRsp) GetRetMsg() string {
	if m != nil {
		return m.RetMsg
	}
	return ""
}

func (m *ApplyDownloadRsp) GetDownloadInfo() *DownloadInfo {
	if m != nil {
		return m.DownloadInfo
	}
	return nil
}

func (m *ApplyDownloadRsp) GetFileInfo() *FileInfo {
	if m != nil {
		return m.FileInfo
	}
	return nil
}

type ApplyForwardFileReq struct {
	SenderUin   int64  `protobuf:"varint,10,opt,name=senderUin,proto3" json:"senderUin,omitempty"`
	RecverUin   int64  `protobuf:"varint,20,opt,name=recverUin,proto3" json:"recverUin,omitempty"`
	Uuid        []byte `protobuf:"bytes,30,opt,name=uuid,proto3" json:"uuid,omitempty"`
	DangerLevel int32  `protobuf:"varint,40,opt,name=dangerLevel,proto3" json:"dangerLevel,omitempty"`
	TotalSpace  int64  `protobuf:"varint,50,opt,name=totalSpace,proto3" json:"totalSpace,omitempty"`
}

func (m *ApplyForwardFileReq) Reset()         { *m = ApplyForwardFileReq{} }
func (m *ApplyForwardFileReq) String() string { return proto.CompactTextString(m) }
func (*ApplyForwardFileReq) ProtoMessage()    {}
func (*ApplyForwardFileReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{9}
}
func (m *ApplyForwardFileReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyForwardFileReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyForwardFileReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplyForwardFileReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyForwardFileReq.Merge(m, src)
}
func (m *ApplyForwardFileReq) XXX_Size() int {
	return m.Size()
}
func (m *ApplyForwardFileReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyForwardFileReq.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyForwardFileReq proto.InternalMessageInfo

func (m *ApplyForwardFileReq) GetSenderUin() int64 {
	if m != nil {
		return m.SenderUin
	}
	return 0
}

func (m *ApplyForwardFileReq) GetRecverUin() int64 {
	if m != nil {
		return m.RecverUin
	}
	return 0
}

func (m *ApplyForwardFileReq) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *ApplyForwardFileReq) GetDangerLevel() int32 {
	if m != nil {
		return m.DangerLevel
	}
	return 0
}

func (m *ApplyForwardFileReq) GetTotalSpace() int64 {
	if m != nil {
		return m.TotalSpace
	}
	return 0
}

type ApplyForwardFileRsp struct {
	RetCode    int32  `protobuf:"varint,10,opt,name=retCode,proto3" json:"retCode,omitempty"`
	RetMsg     string `protobuf:"bytes,20,opt,name=retMsg,proto3" json:"retMsg,omitempty"`
	TotalSpace int64  `protobuf:"varint,30,opt,name=totalSpace,proto3" json:"totalSpace,omitempty"`
	UsedSpace  int64  `protobuf:"varint,40,opt,name=usedSpace,proto3" json:"usedSpace,omitempty"`
	Uuid       []byte `protobuf:"bytes,50,opt,name=uuid,proto3" json:"uuid,omitempty"`
}

func (m *ApplyForwardFileRsp) Reset()         { *m = ApplyForwardFileRsp{} }
func (m *ApplyForwardFileRsp) String() string { return proto.CompactTextString(m) }
func (*ApplyForwardFileRsp) ProtoMessage()    {}
func (*ApplyForwardFileRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{10}
}
func (m *ApplyForwardFileRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyForwardFileRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyForwardFileRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplyForwardFileRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyForwardFileRsp.Merge(m, src)
}
func (m *ApplyForwardFileRsp) XXX_Size() int {
	return m.Size()
}
func (m *ApplyForwardFileRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyForwardFileRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyForwardFileRsp proto.InternalMessageInfo

func (m *ApplyForwardFileRsp) GetRetCode() int32 {
	if m != nil {
		return m.RetCode
	}
	return 0
}

func (m *ApplyForwardFileRsp) GetRetMsg() string {
	if m != nil {
		return m.RetMsg
	}
	return ""
}

func (m *ApplyForwardFileRsp) GetTotalSpace() int64 {
	if m != nil {
		return m.TotalSpace
	}
	return 0
}

func (m *ApplyForwardFileRsp) GetUsedSpace() int64 {
	if m != nil {
		return m.UsedSpace
	}
	return 0
}

func (m *ApplyForwardFileRsp) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

type ApplyGetTrafficReq struct {
}

func (m *ApplyGetTrafficReq) Reset()         { *m = ApplyGetTrafficReq{} }
func (m *ApplyGetTrafficReq) String() string { return proto.CompactTextString(m) }
func (*ApplyGetTrafficReq) ProtoMessage()    {}
func (*ApplyGetTrafficReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{11}
}
func (m *ApplyGetTrafficReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyGetTrafficReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyGetTrafficReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplyGetTrafficReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyGetTrafficReq.Merge(m, src)
}
func (m *ApplyGetTrafficReq) XXX_Size() int {
	return m.Size()
}
func (m *ApplyGetTrafficReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyGetTrafficReq.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyGetTrafficReq proto.InternalMessageInfo

type ApplyGetTrafficRsp struct {
	RetCode     int32  `protobuf:"varint,10,opt,name=retCode,proto3" json:"retCode,omitempty"`
	RetMsg      string `protobuf:"bytes,20,opt,name=retMsg,proto3" json:"retMsg,omitempty"`
	UseFileSize int64  `protobuf:"varint,30,opt,name=useFileSize,proto3" json:"useFileSize,omitempty"`
	UseFileNum  int32  `protobuf:"varint,40,opt,name=useFileNum,proto3" json:"useFileNum,omitempty"`
	AllFileSize int64  `protobuf:"varint,50,opt,name=allFileSize,proto3" json:"allFileSize,omitempty"`
	AllFileNum  int32  `protobuf:"varint,60,opt,name=allFileNum,proto3" json:"allFileNum,omitempty"`
}

func (m *ApplyGetTrafficRsp) Reset()         { *m = ApplyGetTrafficRsp{} }
func (m *ApplyGetTrafficRsp) String() string { return proto.CompactTextString(m) }
func (*ApplyGetTrafficRsp) ProtoMessage()    {}
func (*ApplyGetTrafficRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{12}
}
func (m *ApplyGetTrafficRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyGetTrafficRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyGetTrafficRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplyGetTrafficRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyGetTrafficRsp.Merge(m, src)
}
func (m *ApplyGetTrafficRsp) XXX_Size() int {
	return m.Size()
}
func (m *ApplyGetTrafficRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyGetTrafficRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyGetTrafficRsp proto.InternalMessageInfo

func (m *ApplyGetTrafficRsp) GetRetCode() int32 {
	if m != nil {
		return m.RetCode
	}
	return 0
}

func (m *ApplyGetTrafficRsp) GetRetMsg() string {
	if m != nil {
		return m.RetMsg
	}
	return ""
}

func (m *ApplyGetTrafficRsp) GetUseFileSize() int64 {
	if m != nil {
		return m.UseFileSize
	}
	return 0
}

func (m *ApplyGetTrafficRsp) GetUseFileNum() int32 {
	if m != nil {
		return m.UseFileNum
	}
	return 0
}

func (m *ApplyGetTrafficRsp) GetAllFileSize() int64 {
	if m != nil {
		return m.AllFileSize
	}
	return 0
}

func (m *ApplyGetTrafficRsp) GetAllFileNum() int32 {
	if m != nil {
		return m.AllFileNum
	}
	return 0
}

type ApplyListDownloadReq struct {
	Uin        int64 `protobuf:"varint,10,opt,name=uin,proto3" json:"uin,omitempty"`
	BeginIndex int32 `protobuf:"varint,20,opt,name=beginIndex,proto3" json:"beginIndex,omitempty"`
	ReqCount   int32 `protobuf:"varint,30,opt,name=reqCount,proto3" json:"reqCount,omitempty"`
}

func (m *ApplyListDownloadReq) Reset()         { *m = ApplyListDownloadReq{} }
func (m *ApplyListDownloadReq) String() string { return proto.CompactTextString(m) }
func (*ApplyListDownloadReq) ProtoMessage()    {}
func (*ApplyListDownloadReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{13}
}
func (m *ApplyListDownloadReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyListDownloadReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyListDownloadReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplyListDownloadReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyListDownloadReq.Merge(m, src)
}
func (m *ApplyListDownloadReq) XXX_Size() int {
	return m.Size()
}
func (m *ApplyListDownloadReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyListDownloadReq.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyListDownloadReq proto.InternalMessageInfo

func (m *ApplyListDownloadReq) GetUin() int64 {
	if m != nil {
		return m.Uin
	}
	return 0
}

func (m *ApplyListDownloadReq) GetBeginIndex() int32 {
	if m != nil {
		return m.BeginIndex
	}
	return 0
}

func (m *ApplyListDownloadReq) GetReqCount() int32 {
	if m != nil {
		return m.ReqCount
	}
	return 0
}

type ApplyListDownloadRsp struct {
	RetCode    int32       `protobuf:"varint,10,opt,name=retCode,proto3" json:"retCode,omitempty"`
	RetMsg     string      `protobuf:"bytes,20,opt,name=retMsg,proto3" json:"retMsg,omitempty"`
	TotalCount int32       `protobuf:"varint,30,opt,name=totalCount,proto3" json:"totalCount,omitempty"`
	BeginIndex int32       `protobuf:"varint,40,opt,name=beginIndex,proto3" json:"beginIndex,omitempty"`
	RspCount   int32       `protobuf:"varint,50,opt,name=rspCount,proto3" json:"rspCount,omitempty"`
	IsEnd      int32       `protobuf:"varint,60,opt,name=isEnd,proto3" json:"isEnd,omitempty"`
	FileList   []*FileInfo `protobuf:"bytes,70,rep,name=fileList,proto3" json:"fileList,omitempty"`
}

func (m *ApplyListDownloadRsp) Reset()         { *m = ApplyListDownloadRsp{} }
func (m *ApplyListDownloadRsp) String() string { return proto.CompactTextString(m) }
func (*ApplyListDownloadRsp) ProtoMessage()    {}
func (*ApplyListDownloadRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{14}
}
func (m *ApplyListDownloadRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyListDownloadRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyListDownloadRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplyListDownloadRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyListDownloadRsp.Merge(m, src)
}
func (m *ApplyListDownloadRsp) XXX_Size() int {
	return m.Size()
}
func (m *ApplyListDownloadRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyListDownloadRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyListDownloadRsp proto.InternalMessageInfo

func (m *ApplyListDownloadRsp) GetRetCode() int32 {
	if m != nil {
		return m.RetCode
	}
	return 0
}

func (m *ApplyListDownloadRsp) GetRetMsg() string {
	if m != nil {
		return m.RetMsg
	}
	return ""
}

func (m *ApplyListDownloadRsp) GetTotalCount() int32 {
	if m != nil {
		return m.TotalCount
	}
	return 0
}

func (m *ApplyListDownloadRsp) GetBeginIndex() int32 {
	if m != nil {
		return m.BeginIndex
	}
	return 0
}

func (m *ApplyListDownloadRsp) GetRspCount() int32 {
	if m != nil {
		return m.RspCount
	}
	return 0
}

func (m *ApplyListDownloadRsp) GetIsEnd() int32 {
	if m != nil {
		return m.IsEnd
	}
	return 0
}

func (m *ApplyListDownloadRsp) GetFileList() []*FileInfo {
	if m != nil {
		return m.FileList
	}
	return nil
}

type ApplyUploadHitReq struct {
	SenderUin     int64  `protobuf:"varint,10,opt,name=senderUin,proto3" json:"senderUin,omitempty"`
	RecverUin     int64  `protobuf:"varint,20,opt,name=recverUin,proto3" json:"recverUin,omitempty"`
	FileSize      int64  `protobuf:"varint,30,opt,name=fileSize,proto3" json:"fileSize,omitempty"`
	FileName      string `protobuf:"bytes,40,opt,name=fileName,proto3" json:"fileName,omitempty"`
	Bytes_10MMd5  []byte `protobuf:"bytes,50,opt,name=bytes_10mMd5,json=bytes10mMd5,proto3" json:"bytes_10mMd5,omitempty"`
	LocalFilepath string `protobuf:"bytes,60,opt,name=localFilepath,proto3" json:"localFilepath,omitempty"`
	DangerLevel   int32  `protobuf:"varint,70,opt,name=dangerLevel,proto3" json:"dangerLevel,omitempty"`
	TotalSpace    int64  `protobuf:"varint,80,opt,name=totalSpace,proto3" json:"totalSpace,omitempty"`
}

func (m *ApplyUploadHitReq) Reset()         { *m = ApplyUploadHitReq{} }
func (m *ApplyUploadHitReq) String() string { return proto.CompactTextString(m) }
func (*ApplyUploadHitReq) ProtoMessage()    {}
func (*ApplyUploadHitReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{15}
}
func (m *ApplyUploadHitReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyUploadHitReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyUploadHitReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplyUploadHitReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyUploadHitReq.Merge(m, src)
}
func (m *ApplyUploadHitReq) XXX_Size() int {
	return m.Size()
}
func (m *ApplyUploadHitReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyUploadHitReq.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyUploadHitReq proto.InternalMessageInfo

func (m *ApplyUploadHitReq) GetSenderUin() int64 {
	if m != nil {
		return m.SenderUin
	}
	return 0
}

func (m *ApplyUploadHitReq) GetRecverUin() int64 {
	if m != nil {
		return m.RecverUin
	}
	return 0
}

func (m *ApplyUploadHitReq) GetFileSize() int64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *ApplyUploadHitReq) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *ApplyUploadHitReq) GetBytes_10MMd5() []byte {
	if m != nil {
		return m.Bytes_10MMd5
	}
	return nil
}

func (m *ApplyUploadHitReq) GetLocalFilepath() string {
	if m != nil {
		return m.LocalFilepath
	}
	return ""
}

func (m *ApplyUploadHitReq) GetDangerLevel() int32 {
	if m != nil {
		return m.DangerLevel
	}
	return 0
}

func (m *ApplyUploadHitReq) GetTotalSpace() int64 {
	if m != nil {
		return m.TotalSpace
	}
	return 0
}

type ApplyUploadHitReqV2 struct {
	SenderUin     int64  `protobuf:"varint,10,opt,name=senderUin,proto3" json:"senderUin,omitempty"`
	RecverUin     int64  `protobuf:"varint,20,opt,name=recverUin,proto3" json:"recverUin,omitempty"`
	FileSize      int64  `protobuf:"varint,30,opt,name=fileSize,proto3" json:"fileSize,omitempty"`
	FileName      string `protobuf:"bytes,40,opt,name=fileName,proto3" json:"fileName,omitempty"`
	Bytes_10MMd5  []byte `protobuf:"bytes,50,opt,name=bytes_10mMd5,json=bytes10mMd5,proto3" json:"bytes_10mMd5,omitempty"`
	Bytes_3Sha    []byte `protobuf:"bytes,60,opt,name=bytes_3sha,json=bytes3sha,proto3" json:"bytes_3sha,omitempty"`
	Sha           []byte `protobuf:"bytes,70,opt,name=sha,proto3" json:"sha,omitempty"`
	LocalFilepath string `protobuf:"bytes,80,opt,name=localFilepath,proto3" json:"localFilepath,omitempty"`
	DangerLevel   int32  `protobuf:"varint,90,opt,name=dangerLevel,proto3" json:"dangerLevel,omitempty"`
	TotalSpace    int64  `protobuf:"varint,100,opt,name=totalSpace,proto3" json:"totalSpace,omitempty"`
}

func (m *ApplyUploadHitReqV2) Reset()         { *m = ApplyUploadHitReqV2{} }
func (m *ApplyUploadHitReqV2) String() string { return proto.CompactTextString(m) }
func (*ApplyUploadHitReqV2) ProtoMessage()    {}
func (*ApplyUploadHitReqV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{16}
}
func (m *ApplyUploadHitReqV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyUploadHitReqV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyUploadHitReqV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplyUploadHitReqV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyUploadHitReqV2.Merge(m, src)
}
func (m *ApplyUploadHitReqV2) XXX_Size() int {
	return m.Size()
}
func (m *ApplyUploadHitReqV2) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyUploadHitReqV2.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyUploadHitReqV2 proto.InternalMessageInfo

func (m *ApplyUploadHitReqV2) GetSenderUin() int64 {
	if m != nil {
		return m.SenderUin
	}
	return 0
}

func (m *ApplyUploadHitReqV2) GetRecverUin() int64 {
	if m != nil {
		return m.RecverUin
	}
	return 0
}

func (m *ApplyUploadHitReqV2) GetFileSize() int64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *ApplyUploadHitReqV2) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *ApplyUploadHitReqV2) GetBytes_10MMd5() []byte {
	if m != nil {
		return m.Bytes_10MMd5
	}
	return nil
}

func (m *ApplyUploadHitReqV2) GetBytes_3Sha() []byte {
	if m != nil {
		return m.Bytes_3Sha
	}
	return nil
}

func (m *ApplyUploadHitReqV2) GetSha() []byte {
	if m != nil {
		return m.Sha
	}
	return nil
}

func (m *ApplyUploadHitReqV2) GetLocalFilepath() string {
	if m != nil {
		return m.LocalFilepath
	}
	return ""
}

func (m *ApplyUploadHitReqV2) GetDangerLevel() int32 {
	if m != nil {
		return m.DangerLevel
	}
	return 0
}

func (m *ApplyUploadHitReqV2) GetTotalSpace() int64 {
	if m != nil {
		return m.TotalSpace
	}
	return 0
}

type ApplyUploadHitReqV3 struct {
	SenderUin     int64  `protobuf:"varint,10,opt,name=senderUin,proto3" json:"senderUin,omitempty"`
	RecverUin     int64  `protobuf:"varint,20,opt,name=recverUin,proto3" json:"recverUin,omitempty"`
	FileSize      int64  `protobuf:"varint,30,opt,name=fileSize,proto3" json:"fileSize,omitempty"`
	FileName      string `protobuf:"bytes,40,opt,name=fileName,proto3" json:"fileName,omitempty"`
	Bytes_10MMd5  []byte `protobuf:"bytes,50,opt,name=bytes_10mMd5,json=bytes10mMd5,proto3" json:"bytes_10mMd5,omitempty"`
	Sha           []byte `protobuf:"bytes,60,opt,name=sha,proto3" json:"sha,omitempty"`
	LocalFilepath string `protobuf:"bytes,70,opt,name=localFilepath,proto3" json:"localFilepath,omitempty"`
	DangerLevel   int32  `protobuf:"varint,80,opt,name=dangerLevel,proto3" json:"dangerLevel,omitempty"`
	TotalSpace    int64  `protobuf:"varint,90,opt,name=totalSpace,proto3" json:"totalSpace,omitempty"`
}

func (m *ApplyUploadHitReqV3) Reset()         { *m = ApplyUploadHitReqV3{} }
func (m *ApplyUploadHitReqV3) String() string { return proto.CompactTextString(m) }
func (*ApplyUploadHitReqV3) ProtoMessage()    {}
func (*ApplyUploadHitReqV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{17}
}
func (m *ApplyUploadHitReqV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyUploadHitReqV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyUploadHitReqV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplyUploadHitReqV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyUploadHitReqV3.Merge(m, src)
}
func (m *ApplyUploadHitReqV3) XXX_Size() int {
	return m.Size()
}
func (m *ApplyUploadHitReqV3) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyUploadHitReqV3.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyUploadHitReqV3 proto.InternalMessageInfo

func (m *ApplyUploadHitReqV3) GetSenderUin() int64 {
	if m != nil {
		return m.SenderUin
	}
	return 0
}

func (m *ApplyUploadHitReqV3) GetRecverUin() int64 {
	if m != nil {
		return m.RecverUin
	}
	return 0
}

func (m *ApplyUploadHitReqV3) GetFileSize() int64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *ApplyUploadHitReqV3) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *ApplyUploadHitReqV3) GetBytes_10MMd5() []byte {
	if m != nil {
		return m.Bytes_10MMd5
	}
	return nil
}

func (m *ApplyUploadHitReqV3) GetSha() []byte {
	if m != nil {
		return m.Sha
	}
	return nil
}

func (m *ApplyUploadHitReqV3) GetLocalFilepath() string {
	if m != nil {
		return m.LocalFilepath
	}
	return ""
}

func (m *ApplyUploadHitReqV3) GetDangerLevel() int32 {
	if m != nil {
		return m.DangerLevel
	}
	return 0
}

func (m *ApplyUploadHitReqV3) GetTotalSpace() int64 {
	if m != nil {
		return m.TotalSpace
	}
	return 0
}

type ApplyUploadHitRsp struct {
	RetCode      int32  `protobuf:"varint,10,opt,name=retCode,proto3" json:"retCode,omitempty"`
	RetMsg       string `protobuf:"bytes,20,opt,name=retMsg,proto3" json:"retMsg,omitempty"`
	UploadIp     string `protobuf:"bytes,30,opt,name=uploadIp,proto3" json:"uploadIp,omitempty"`
	UploadPort   int32  `protobuf:"varint,40,opt,name=uploadPort,proto3" json:"uploadPort,omitempty"`
	UploadDomain string `protobuf:"bytes,50,opt,name=uploadDomain,proto3" json:"uploadDomain,omitempty"`
	Uuid         []byte `protobuf:"bytes,60,opt,name=uuid,proto3" json:"uuid,omitempty"`
	UploadKey    []byte `protobuf:"bytes,70,opt,name=uploadKey,proto3" json:"uploadKey,omitempty"`
	TotalSpace   int64  `protobuf:"varint,80,opt,name=totalSpace,proto3" json:"totalSpace,omitempty"`
	UsedSpace    int64  `protobuf:"varint,90,opt,name=usedSpace,proto3" json:"usedSpace,omitempty"`
}

func (m *ApplyUploadHitRsp) Reset()         { *m = ApplyUploadHitRsp{} }
func (m *ApplyUploadHitRsp) String() string { return proto.CompactTextString(m) }
func (*ApplyUploadHitRsp) ProtoMessage()    {}
func (*ApplyUploadHitRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{18}
}
func (m *ApplyUploadHitRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyUploadHitRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyUploadHitRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplyUploadHitRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyUploadHitRsp.Merge(m, src)
}
func (m *ApplyUploadHitRsp) XXX_Size() int {
	return m.Size()
}
func (m *ApplyUploadHitRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyUploadHitRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyUploadHitRsp proto.InternalMessageInfo

func (m *ApplyUploadHitRsp) GetRetCode() int32 {
	if m != nil {
		return m.RetCode
	}
	return 0
}

func (m *ApplyUploadHitRsp) GetRetMsg() string {
	if m != nil {
		return m.RetMsg
	}
	return ""
}

func (m *ApplyUploadHitRsp) GetUploadIp() string {
	if m != nil {
		return m.UploadIp
	}
	return ""
}

func (m *ApplyUploadHitRsp) GetUploadPort() int32 {
	if m != nil {
		return m.UploadPort
	}
	return 0
}

func (m *ApplyUploadHitRsp) GetUploadDomain() string {
	if m != nil {
		return m.UploadDomain
	}
	return ""
}

func (m *ApplyUploadHitRsp) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *ApplyUploadHitRsp) GetUploadKey() []byte {
	if m != nil {
		return m.UploadKey
	}
	return nil
}

func (m *ApplyUploadHitRsp) GetTotalSpace() int64 {
	if m != nil {
		return m.TotalSpace
	}
	return 0
}

func (m *ApplyUploadHitRsp) GetUsedSpace() int64 {
	if m != nil {
		return m.UsedSpace
	}
	return 0
}

type ApplyUploadHitRspV2 struct {
	RetCode      int32  `protobuf:"varint,10,opt,name=retCode,proto3" json:"retCode,omitempty"`
	RetMsg       string `protobuf:"bytes,20,opt,name=retMsg,proto3" json:"retMsg,omitempty"`
	UploadIp     string `protobuf:"bytes,30,opt,name=uploadIp,proto3" json:"uploadIp,omitempty"`
	UploadPort   int32  `protobuf:"varint,40,opt,name=uploadPort,proto3" json:"uploadPort,omitempty"`
	UploadDomain string `protobuf:"bytes,50,opt,name=uploadDomain,proto3" json:"uploadDomain,omitempty"`
	Uuid         []byte `protobuf:"bytes,60,opt,name=uuid,proto3" json:"uuid,omitempty"`
	UploadKey    []byte `protobuf:"bytes,70,opt,name=uploadKey,proto3" json:"uploadKey,omitempty"`
	TotalSpace   int64  `protobuf:"varint,80,opt,name=totalSpace,proto3" json:"totalSpace,omitempty"`
	UsedSpace    int64  `protobuf:"varint,90,opt,name=usedSpace,proto3" json:"usedSpace,omitempty"`
}

func (m *ApplyUploadHitRspV2) Reset()         { *m = ApplyUploadHitRspV2{} }
func (m *ApplyUploadHitRspV2) String() string { return proto.CompactTextString(m) }
func (*ApplyUploadHitRspV2) ProtoMessage()    {}
func (*ApplyUploadHitRspV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{19}
}
func (m *ApplyUploadHitRspV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyUploadHitRspV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyUploadHitRspV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplyUploadHitRspV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyUploadHitRspV2.Merge(m, src)
}
func (m *ApplyUploadHitRspV2) XXX_Size() int {
	return m.Size()
}
func (m *ApplyUploadHitRspV2) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyUploadHitRspV2.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyUploadHitRspV2 proto.InternalMessageInfo

func (m *ApplyUploadHitRspV2) GetRetCode() int32 {
	if m != nil {
		return m.RetCode
	}
	return 0
}

func (m *ApplyUploadHitRspV2) GetRetMsg() string {
	if m != nil {
		return m.RetMsg
	}
	return ""
}

func (m *ApplyUploadHitRspV2) GetUploadIp() string {
	if m != nil {
		return m.UploadIp
	}
	return ""
}

func (m *ApplyUploadHitRspV2) GetUploadPort() int32 {
	if m != nil {
		return m.UploadPort
	}
	return 0
}

func (m *ApplyUploadHitRspV2) GetUploadDomain() string {
	if m != nil {
		return m.UploadDomain
	}
	return ""
}

func (m *ApplyUploadHitRspV2) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *ApplyUploadHitRspV2) GetUploadKey() []byte {
	if m != nil {
		return m.UploadKey
	}
	return nil
}

func (m *ApplyUploadHitRspV2) GetTotalSpace() int64 {
	if m != nil {
		return m.TotalSpace
	}
	return 0
}

func (m *ApplyUploadHitRspV2) GetUsedSpace() int64 {
	if m != nil {
		return m.UsedSpace
	}
	return 0
}

type ApplyUploadHitRspV3 struct {
	RetCode      int32  `protobuf:"varint,10,opt,name=retCode,proto3" json:"retCode,omitempty"`
	RetMsg       string `protobuf:"bytes,20,opt,name=retMsg,proto3" json:"retMsg,omitempty"`
	UploadIp     string `protobuf:"bytes,30,opt,name=uploadIp,proto3" json:"uploadIp,omitempty"`
	UploadPort   int32  `protobuf:"varint,40,opt,name=uploadPort,proto3" json:"uploadPort,omitempty"`
	UploadDomain string `protobuf:"bytes,50,opt,name=uploadDomain,proto3" json:"uploadDomain,omitempty"`
	Uuid         []byte `protobuf:"bytes,60,opt,name=uuid,proto3" json:"uuid,omitempty"`
	UploadKey    []byte `protobuf:"bytes,70,opt,name=uploadKey,proto3" json:"uploadKey,omitempty"`
	TotalSpace   int64  `protobuf:"varint,80,opt,name=totalSpace,proto3" json:"totalSpace,omitempty"`
	UsedSpace    int64  `protobuf:"varint,90,opt,name=usedSpace,proto3" json:"usedSpace,omitempty"`
}

func (m *ApplyUploadHitRspV3) Reset()         { *m = ApplyUploadHitRspV3{} }
func (m *ApplyUploadHitRspV3) String() string { return proto.CompactTextString(m) }
func (*ApplyUploadHitRspV3) ProtoMessage()    {}
func (*ApplyUploadHitRspV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{20}
}
func (m *ApplyUploadHitRspV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyUploadHitRspV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyUploadHitRspV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplyUploadHitRspV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyUploadHitRspV3.Merge(m, src)
}
func (m *ApplyUploadHitRspV3) XXX_Size() int {
	return m.Size()
}
func (m *ApplyUploadHitRspV3) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyUploadHitRspV3.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyUploadHitRspV3 proto.InternalMessageInfo

func (m *ApplyUploadHitRspV3) GetRetCode() int32 {
	if m != nil {
		return m.RetCode
	}
	return 0
}

func (m *ApplyUploadHitRspV3) GetRetMsg() string {
	if m != nil {
		return m.RetMsg
	}
	return ""
}

func (m *ApplyUploadHitRspV3) GetUploadIp() string {
	if m != nil {
		return m.UploadIp
	}
	return ""
}

func (m *ApplyUploadHitRspV3) GetUploadPort() int32 {
	if m != nil {
		return m.UploadPort
	}
	return 0
}

func (m *ApplyUploadHitRspV3) GetUploadDomain() string {
	if m != nil {
		return m.UploadDomain
	}
	return ""
}

func (m *ApplyUploadHitRspV3) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *ApplyUploadHitRspV3) GetUploadKey() []byte {
	if m != nil {
		return m.UploadKey
	}
	return nil
}

func (m *ApplyUploadHitRspV3) GetTotalSpace() int64 {
	if m != nil {
		return m.TotalSpace
	}
	return 0
}

func (m *ApplyUploadHitRspV3) GetUsedSpace() int64 {
	if m != nil {
		return m.UsedSpace
	}
	return 0
}

type ApplyUploadReq struct {
	SenderUin     int64  `protobuf:"varint,10,opt,name=senderUin,proto3" json:"senderUin,omitempty"`
	RecverUin     int64  `protobuf:"varint,20,opt,name=recverUin,proto3" json:"recverUin,omitempty"`
	FileType      int32  `protobuf:"varint,30,opt,name=fileType,proto3" json:"fileType,omitempty"`
	FileSize      int64  `protobuf:"varint,40,opt,name=fileSize,proto3" json:"fileSize,omitempty"`
	FileName      string `protobuf:"bytes,50,opt,name=fileName,proto3" json:"fileName,omitempty"`
	Bytes_10MMd5  []byte `protobuf:"bytes,60,opt,name=bytes_10mMd5,json=bytes10mMd5,proto3" json:"bytes_10mMd5,omitempty"`
	LocalFilepath string `protobuf:"bytes,70,opt,name=localFilepath,proto3" json:"localFilepath,omitempty"`
	DangerLevel   int32  `protobuf:"varint,80,opt,name=dangerLevel,proto3" json:"dangerLevel,omitempty"`
	TotalSpace    int64  `protobuf:"varint,90,opt,name=totalSpace,proto3" json:"totalSpace,omitempty"`
}

func (m *ApplyUploadReq) Reset()         { *m = ApplyUploadReq{} }
func (m *ApplyUploadReq) String() string { return proto.CompactTextString(m) }
func (*ApplyUploadReq) ProtoMessage()    {}
func (*ApplyUploadReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{21}
}
func (m *ApplyUploadReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyUploadReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyUploadReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplyUploadReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyUploadReq.Merge(m, src)
}
func (m *ApplyUploadReq) XXX_Size() int {
	return m.Size()
}
func (m *ApplyUploadReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyUploadReq.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyUploadReq proto.InternalMessageInfo

func (m *ApplyUploadReq) GetSenderUin() int64 {
	if m != nil {
		return m.SenderUin
	}
	return 0
}

func (m *ApplyUploadReq) GetRecverUin() int64 {
	if m != nil {
		return m.RecverUin
	}
	return 0
}

func (m *ApplyUploadReq) GetFileType() int32 {
	if m != nil {
		return m.FileType
	}
	return 0
}

func (m *ApplyUploadReq) GetFileSize() int64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *ApplyUploadReq) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *ApplyUploadReq) GetBytes_10MMd5() []byte {
	if m != nil {
		return m.Bytes_10MMd5
	}
	return nil
}

func (m *ApplyUploadReq) GetLocalFilepath() string {
	if m != nil {
		return m.LocalFilepath
	}
	return ""
}

func (m *ApplyUploadReq) GetDangerLevel() int32 {
	if m != nil {
		return m.DangerLevel
	}
	return 0
}

func (m *ApplyUploadReq) GetTotalSpace() int64 {
	if m != nil {
		return m.TotalSpace
	}
	return 0
}

type ApplyUploadReqV2 struct {
	SenderUin     int64  `protobuf:"varint,10,opt,name=senderUin,proto3" json:"senderUin,omitempty"`
	RecverUin     int64  `protobuf:"varint,20,opt,name=recverUin,proto3" json:"recverUin,omitempty"`
	FileSize      int64  `protobuf:"varint,30,opt,name=fileSize,proto3" json:"fileSize,omitempty"`
	FileName      string `protobuf:"bytes,40,opt,name=fileName,proto3" json:"fileName,omitempty"`
	Bytes_10MMd5  []byte `protobuf:"bytes,50,opt,name=bytes_10mMd5,json=bytes10mMd5,proto3" json:"bytes_10mMd5,omitempty"`
	Bytes_3Sha    []byte `protobuf:"bytes,60,opt,name=bytes_3sha,json=bytes3sha,proto3" json:"bytes_3sha,omitempty"`
	LocalFilepath string `protobuf:"bytes,70,opt,name=localFilepath,proto3" json:"localFilepath,omitempty"`
	DangerLevel   int32  `protobuf:"varint,80,opt,name=dangerLevel,proto3" json:"dangerLevel,omitempty"`
	TotalSpace    int64  `protobuf:"varint,90,opt,name=totalSpace,proto3" json:"totalSpace,omitempty"`
}

func (m *ApplyUploadReqV2) Reset()         { *m = ApplyUploadReqV2{} }
func (m *ApplyUploadReqV2) String() string { return proto.CompactTextString(m) }
func (*ApplyUploadReqV2) ProtoMessage()    {}
func (*ApplyUploadReqV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{22}
}
func (m *ApplyUploadReqV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyUploadReqV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyUploadReqV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplyUploadReqV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyUploadReqV2.Merge(m, src)
}
func (m *ApplyUploadReqV2) XXX_Size() int {
	return m.Size()
}
func (m *ApplyUploadReqV2) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyUploadReqV2.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyUploadReqV2 proto.InternalMessageInfo

func (m *ApplyUploadReqV2) GetSenderUin() int64 {
	if m != nil {
		return m.SenderUin
	}
	return 0
}

func (m *ApplyUploadReqV2) GetRecverUin() int64 {
	if m != nil {
		return m.RecverUin
	}
	return 0
}

func (m *ApplyUploadReqV2) GetFileSize() int64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *ApplyUploadReqV2) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *ApplyUploadReqV2) GetBytes_10MMd5() []byte {
	if m != nil {
		return m.Bytes_10MMd5
	}
	return nil
}

func (m *ApplyUploadReqV2) GetBytes_3Sha() []byte {
	if m != nil {
		return m.Bytes_3Sha
	}
	return nil
}

func (m *ApplyUploadReqV2) GetLocalFilepath() string {
	if m != nil {
		return m.LocalFilepath
	}
	return ""
}

func (m *ApplyUploadReqV2) GetDangerLevel() int32 {
	if m != nil {
		return m.DangerLevel
	}
	return 0
}

func (m *ApplyUploadReqV2) GetTotalSpace() int64 {
	if m != nil {
		return m.TotalSpace
	}
	return 0
}

type ApplyUploadReqV3 struct {
	SenderUin     int64  `protobuf:"varint,10,opt,name=senderUin,proto3" json:"senderUin,omitempty"`
	RecverUin     int64  `protobuf:"varint,20,opt,name=recverUin,proto3" json:"recverUin,omitempty"`
	FileSize      int64  `protobuf:"varint,30,opt,name=fileSize,proto3" json:"fileSize,omitempty"`
	FileName      string `protobuf:"bytes,40,opt,name=fileName,proto3" json:"fileName,omitempty"`
	Bytes_10MMd5  []byte `protobuf:"bytes,50,opt,name=bytes_10mMd5,json=bytes10mMd5,proto3" json:"bytes_10mMd5,omitempty"`
	Sha           []byte `protobuf:"bytes,60,opt,name=sha,proto3" json:"sha,omitempty"`
	LocalFilepath string `protobuf:"bytes,70,opt,name=localFilepath,proto3" json:"localFilepath,omitempty"`
	DangerLevel   int32  `protobuf:"varint,80,opt,name=dangerLevel,proto3" json:"dangerLevel,omitempty"`
	TotalSpace    int64  `protobuf:"varint,90,opt,name=totalSpace,proto3" json:"totalSpace,omitempty"`
}

func (m *ApplyUploadReqV3) Reset()         { *m = ApplyUploadReqV3{} }
func (m *ApplyUploadReqV3) String() string { return proto.CompactTextString(m) }
func (*ApplyUploadReqV3) ProtoMessage()    {}
func (*ApplyUploadReqV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{23}
}
func (m *ApplyUploadReqV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyUploadReqV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyUploadReqV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplyUploadReqV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyUploadReqV3.Merge(m, src)
}
func (m *ApplyUploadReqV3) XXX_Size() int {
	return m.Size()
}
func (m *ApplyUploadReqV3) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyUploadReqV3.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyUploadReqV3 proto.InternalMessageInfo

func (m *ApplyUploadReqV3) GetSenderUin() int64 {
	if m != nil {
		return m.SenderUin
	}
	return 0
}

func (m *ApplyUploadReqV3) GetRecverUin() int64 {
	if m != nil {
		return m.RecverUin
	}
	return 0
}

func (m *ApplyUploadReqV3) GetFileSize() int64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *ApplyUploadReqV3) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *ApplyUploadReqV3) GetBytes_10MMd5() []byte {
	if m != nil {
		return m.Bytes_10MMd5
	}
	return nil
}

func (m *ApplyUploadReqV3) GetSha() []byte {
	if m != nil {
		return m.Sha
	}
	return nil
}

func (m *ApplyUploadReqV3) GetLocalFilepath() string {
	if m != nil {
		return m.LocalFilepath
	}
	return ""
}

func (m *ApplyUploadReqV3) GetDangerLevel() int32 {
	if m != nil {
		return m.DangerLevel
	}
	return 0
}

func (m *ApplyUploadReqV3) GetTotalSpace() int64 {
	if m != nil {
		return m.TotalSpace
	}
	return 0
}

type ApplyUploadRsp struct {
	RetCode       int32    `protobuf:"varint,10,opt,name=retCode,proto3" json:"retCode,omitempty"`
	RetMsg        string   `protobuf:"bytes,20,opt,name=retMsg,proto3" json:"retMsg,omitempty"`
	TotalSpace    int64    `protobuf:"varint,30,opt,name=totalSpace,proto3" json:"totalSpace,omitempty"`
	UsedSpace     int64    `protobuf:"varint,40,opt,name=usedSpace,proto3" json:"usedSpace,omitempty"`
	UploadedSize  int64    `protobuf:"varint,50,opt,name=uploadedSize,proto3" json:"uploadedSize,omitempty"`
	UploadIp      string   `protobuf:"bytes,60,opt,name=uploadIp,proto3" json:"uploadIp,omitempty"`
	UploadDomain  string   `protobuf:"bytes,70,opt,name=uploadDomain,proto3" json:"uploadDomain,omitempty"`
	UploadPort    int32    `protobuf:"varint,80,opt,name=uploadPort,proto3" json:"uploadPort,omitempty"`
	Uuid          []byte   `protobuf:"bytes,90,opt,name=uuid,proto3" json:"uuid,omitempty"`
	UploadKey     []byte   `protobuf:"bytes,100,opt,name=uploadKey,proto3" json:"uploadKey,omitempty"`
	BoolFileExist bool     `protobuf:"varint,110,opt,name=boolFileExist,proto3" json:"boolFileExist,omitempty"`
	PackSize      int32    `protobuf:"varint,120,opt,name=packSize,proto3" json:"packSize,omitempty"`
	UploadipList  []string `protobuf:"bytes,130,rep,name=uploadipList,proto3" json:"uploadipList,omitempty"`
}

func (m *ApplyUploadRsp) Reset()         { *m = ApplyUploadRsp{} }
func (m *ApplyUploadRsp) String() string { return proto.CompactTextString(m) }
func (*ApplyUploadRsp) ProtoMessage()    {}
func (*ApplyUploadRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{24}
}
func (m *ApplyUploadRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyUploadRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyUploadRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplyUploadRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyUploadRsp.Merge(m, src)
}
func (m *ApplyUploadRsp) XXX_Size() int {
	return m.Size()
}
func (m *ApplyUploadRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyUploadRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyUploadRsp proto.InternalMessageInfo

func (m *ApplyUploadRsp) GetRetCode() int32 {
	if m != nil {
		return m.RetCode
	}
	return 0
}

func (m *ApplyUploadRsp) GetRetMsg() string {
	if m != nil {
		return m.RetMsg
	}
	return ""
}

func (m *ApplyUploadRsp) GetTotalSpace() int64 {
	if m != nil {
		return m.TotalSpace
	}
	return 0
}

func (m *ApplyUploadRsp) GetUsedSpace() int64 {
	if m != nil {
		return m.UsedSpace
	}
	return 0
}

func (m *ApplyUploadRsp) GetUploadedSize() int64 {
	if m != nil {
		return m.UploadedSize
	}
	return 0
}

func (m *ApplyUploadRsp) GetUploadIp() string {
	if m != nil {
		return m.UploadIp
	}
	return ""
}

func (m *ApplyUploadRsp) GetUploadDomain() string {
	if m != nil {
		return m.UploadDomain
	}
	return ""
}

func (m *ApplyUploadRsp) GetUploadPort() int32 {
	if m != nil {
		return m.UploadPort
	}
	return 0
}

func (m *ApplyUploadRsp) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *ApplyUploadRsp) GetUploadKey() []byte {
	if m != nil {
		return m.UploadKey
	}
	return nil
}

func (m *ApplyUploadRsp) GetBoolFileExist() bool {
	if m != nil {
		return m.BoolFileExist
	}
	return false
}

func (m *ApplyUploadRsp) GetPackSize() int32 {
	if m != nil {
		return m.PackSize
	}
	return 0
}

func (m *ApplyUploadRsp) GetUploadipList() []string {
	if m != nil {
		return m.UploadipList
	}
	return nil
}

type ApplyUploadRspV2 struct {
	RetCode       int32    `protobuf:"varint,10,opt,name=retCode,proto3" json:"retCode,omitempty"`
	RetMsg        string   `protobuf:"bytes,20,opt,name=retMsg,proto3" json:"retMsg,omitempty"`
	TotalSpace    int64    `protobuf:"varint,30,opt,name=totalSpace,proto3" json:"totalSpace,omitempty"`
	UsedSpace     int64    `protobuf:"varint,40,opt,name=usedSpace,proto3" json:"usedSpace,omitempty"`
	UploadedSize  int64    `protobuf:"varint,50,opt,name=uploadedSize,proto3" json:"uploadedSize,omitempty"`
	UploadIp      string   `protobuf:"bytes,60,opt,name=uploadIp,proto3" json:"uploadIp,omitempty"`
	UploadDomain  string   `protobuf:"bytes,70,opt,name=uploadDomain,proto3" json:"uploadDomain,omitempty"`
	UploadPort    int32    `protobuf:"varint,80,opt,name=uploadPort,proto3" json:"uploadPort,omitempty"`
	Uuid          []byte   `protobuf:"bytes,90,opt,name=uuid,proto3" json:"uuid,omitempty"`
	UploadKey     []byte   `protobuf:"bytes,100,opt,name=uploadKey,proto3" json:"uploadKey,omitempty"`
	BoolFileExist bool     `protobuf:"varint,110,opt,name=boolFileExist,proto3" json:"boolFileExist,omitempty"`
	PackSize      int32    `protobuf:"varint,120,opt,name=packSize,proto3" json:"packSize,omitempty"`
	UploadipList  []string `protobuf:"bytes,130,rep,name=uploadipList,proto3" json:"uploadipList,omitempty"`
	HttpsvrApiVer int32    `protobuf:"varint,140,opt,name=httpsvrApiVer,proto3" json:"httpsvrApiVer,omitempty"`
	Sha           []byte   `protobuf:"bytes,141,opt,name=sha,proto3" json:"sha,omitempty"`
}

func (m *ApplyUploadRspV2) Reset()         { *m = ApplyUploadRspV2{} }
func (m *ApplyUploadRspV2) String() string { return proto.CompactTextString(m) }
func (*ApplyUploadRspV2) ProtoMessage()    {}
func (*ApplyUploadRspV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{25}
}
func (m *ApplyUploadRspV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyUploadRspV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyUploadRspV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplyUploadRspV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyUploadRspV2.Merge(m, src)
}
func (m *ApplyUploadRspV2) XXX_Size() int {
	return m.Size()
}
func (m *ApplyUploadRspV2) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyUploadRspV2.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyUploadRspV2 proto.InternalMessageInfo

func (m *ApplyUploadRspV2) GetRetCode() int32 {
	if m != nil {
		return m.RetCode
	}
	return 0
}

func (m *ApplyUploadRspV2) GetRetMsg() string {
	if m != nil {
		return m.RetMsg
	}
	return ""
}

func (m *ApplyUploadRspV2) GetTotalSpace() int64 {
	if m != nil {
		return m.TotalSpace
	}
	return 0
}

func (m *ApplyUploadRspV2) GetUsedSpace() int64 {
	if m != nil {
		return m.UsedSpace
	}
	return 0
}

func (m *ApplyUploadRspV2) GetUploadedSize() int64 {
	if m != nil {
		return m.UploadedSize
	}
	return 0
}

func (m *ApplyUploadRspV2) GetUploadIp() string {
	if m != nil {
		return m.UploadIp
	}
	return ""
}

func (m *ApplyUploadRspV2) GetUploadDomain() string {
	if m != nil {
		return m.UploadDomain
	}
	return ""
}

func (m *ApplyUploadRspV2) GetUploadPort() int32 {
	if m != nil {
		return m.UploadPort
	}
	return 0
}

func (m *ApplyUploadRspV2) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *ApplyUploadRspV2) GetUploadKey() []byte {
	if m != nil {
		return m.UploadKey
	}
	return nil
}

func (m *ApplyUploadRspV2) GetBoolFileExist() bool {
	if m != nil {
		return m.BoolFileExist
	}
	return false
}

func (m *ApplyUploadRspV2) GetPackSize() int32 {
	if m != nil {
		return m.PackSize
	}
	return 0
}

func (m *ApplyUploadRspV2) GetUploadipList() []string {
	if m != nil {
		return m.UploadipList
	}
	return nil
}

func (m *ApplyUploadRspV2) GetHttpsvrApiVer() int32 {
	if m != nil {
		return m.HttpsvrApiVer
	}
	return 0
}

func (m *ApplyUploadRspV2) GetSha() []byte {
	if m != nil {
		return m.Sha
	}
	return nil
}

type ApplyUploadRspV3 struct {
	RetCode       int32    `protobuf:"varint,10,opt,name=retCode,proto3" json:"retCode,omitempty"`
	RetMsg        string   `protobuf:"bytes,20,opt,name=retMsg,proto3" json:"retMsg,omitempty"`
	TotalSpace    int64    `protobuf:"varint,30,opt,name=totalSpace,proto3" json:"totalSpace,omitempty"`
	UsedSpace     int64    `protobuf:"varint,40,opt,name=usedSpace,proto3" json:"usedSpace,omitempty"`
	UploadedSize  int64    `protobuf:"varint,50,opt,name=uploadedSize,proto3" json:"uploadedSize,omitempty"`
	UploadIp      string   `protobuf:"bytes,60,opt,name=uploadIp,proto3" json:"uploadIp,omitempty"`
	UploadDomain  string   `protobuf:"bytes,70,opt,name=uploadDomain,proto3" json:"uploadDomain,omitempty"`
	UploadPort    int32    `protobuf:"varint,80,opt,name=uploadPort,proto3" json:"uploadPort,omitempty"`
	Uuid          []byte   `protobuf:"bytes,90,opt,name=uuid,proto3" json:"uuid,omitempty"`
	UploadKey     []byte   `protobuf:"bytes,100,opt,name=uploadKey,proto3" json:"uploadKey,omitempty"`
	BoolFileExist bool     `protobuf:"varint,110,opt,name=boolFileExist,proto3" json:"boolFileExist,omitempty"`
	PackSize      int32    `protobuf:"varint,120,opt,name=packSize,proto3" json:"packSize,omitempty"`
	UploadipList  []string `protobuf:"bytes,130,rep,name=uploadipList,proto3" json:"uploadipList,omitempty"`
}

func (m *ApplyUploadRspV3) Reset()         { *m = ApplyUploadRspV3{} }
func (m *ApplyUploadRspV3) String() string { return proto.CompactTextString(m) }
func (*ApplyUploadRspV3) ProtoMessage()    {}
func (*ApplyUploadRspV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{26}
}
func (m *ApplyUploadRspV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyUploadRspV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyUploadRspV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplyUploadRspV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyUploadRspV3.Merge(m, src)
}
func (m *ApplyUploadRspV3) XXX_Size() int {
	return m.Size()
}
func (m *ApplyUploadRspV3) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyUploadRspV3.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyUploadRspV3 proto.InternalMessageInfo

func (m *ApplyUploadRspV3) GetRetCode() int32 {
	if m != nil {
		return m.RetCode
	}
	return 0
}

func (m *ApplyUploadRspV3) GetRetMsg() string {
	if m != nil {
		return m.RetMsg
	}
	return ""
}

func (m *ApplyUploadRspV3) GetTotalSpace() int64 {
	if m != nil {
		return m.TotalSpace
	}
	return 0
}

func (m *ApplyUploadRspV3) GetUsedSpace() int64 {
	if m != nil {
		return m.UsedSpace
	}
	return 0
}

func (m *ApplyUploadRspV3) GetUploadedSize() int64 {
	if m != nil {
		return m.UploadedSize
	}
	return 0
}

func (m *ApplyUploadRspV3) GetUploadIp() string {
	if m != nil {
		return m.UploadIp
	}
	return ""
}

func (m *ApplyUploadRspV3) GetUploadDomain() string {
	if m != nil {
		return m.UploadDomain
	}
	return ""
}

func (m *ApplyUploadRspV3) GetUploadPort() int32 {
	if m != nil {
		return m.UploadPort
	}
	return 0
}

func (m *ApplyUploadRspV3) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *ApplyUploadRspV3) GetUploadKey() []byte {
	if m != nil {
		return m.UploadKey
	}
	return nil
}

func (m *ApplyUploadRspV3) GetBoolFileExist() bool {
	if m != nil {
		return m.BoolFileExist
	}
	return false
}

func (m *ApplyUploadRspV3) GetPackSize() int32 {
	if m != nil {
		return m.PackSize
	}
	return 0
}

func (m *ApplyUploadRspV3) GetUploadipList() []string {
	if m != nil {
		return m.UploadipList
	}
	return nil
}

type DelMessageReq struct {
	UinSender   int64 `protobuf:"varint,1,opt,name=uinSender,proto3" json:"uinSender,omitempty"`
	UinReceiver int64 `protobuf:"varint,2,opt,name=uinReceiver,proto3" json:"uinReceiver,omitempty"`
	Time        int32 `protobuf:"varint,10,opt,name=time,proto3" json:"time,omitempty"`
	Random      int32 `protobuf:"varint,20,opt,name=random,proto3" json:"random,omitempty"`
	SeqNo       int32 `protobuf:"varint,30,opt,name=seqNo,proto3" json:"seqNo,omitempty"`
}

func (m *DelMessageReq) Reset()         { *m = DelMessageReq{} }
func (m *DelMessageReq) String() string { return proto.CompactTextString(m) }
func (*DelMessageReq) ProtoMessage()    {}
func (*DelMessageReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{27}
}
func (m *DelMessageReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelMessageReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelMessageReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelMessageReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelMessageReq.Merge(m, src)
}
func (m *DelMessageReq) XXX_Size() int {
	return m.Size()
}
func (m *DelMessageReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DelMessageReq.DiscardUnknown(m)
}

var xxx_messageInfo_DelMessageReq proto.InternalMessageInfo

func (m *DelMessageReq) GetUinSender() int64 {
	if m != nil {
		return m.UinSender
	}
	return 0
}

func (m *DelMessageReq) GetUinReceiver() int64 {
	if m != nil {
		return m.UinReceiver
	}
	return 0
}

func (m *DelMessageReq) GetTime() int32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *DelMessageReq) GetRandom() int32 {
	if m != nil {
		return m.Random
	}
	return 0
}

func (m *DelMessageReq) GetSeqNo() int32 {
	if m != nil {
		return m.SeqNo
	}
	return 0
}

type DeleteFileReq struct {
	Uin        int64  `protobuf:"varint,10,opt,name=uin,proto3" json:"uin,omitempty"`
	PeerUin    int64  `protobuf:"varint,20,opt,name=peerUin,proto3" json:"peerUin,omitempty"`
	DeleteType int32  `protobuf:"varint,30,opt,name=deleteType,proto3" json:"deleteType,omitempty"`
	Uuid       []byte `protobuf:"bytes,40,opt,name=uuid,proto3" json:"uuid,omitempty"`
}

func (m *DeleteFileReq) Reset()         { *m = DeleteFileReq{} }
func (m *DeleteFileReq) String() string { return proto.CompactTextString(m) }
func (*DeleteFileReq) ProtoMessage()    {}
func (*DeleteFileReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{28}
}
func (m *DeleteFileReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteFileReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteFileReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteFileReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteFileReq.Merge(m, src)
}
func (m *DeleteFileReq) XXX_Size() int {
	return m.Size()
}
func (m *DeleteFileReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteFileReq.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteFileReq proto.InternalMessageInfo

func (m *DeleteFileReq) GetUin() int64 {
	if m != nil {
		return m.Uin
	}
	return 0
}

func (m *DeleteFileReq) GetPeerUin() int64 {
	if m != nil {
		return m.PeerUin
	}
	return 0
}

func (m *DeleteFileReq) GetDeleteType() int32 {
	if m != nil {
		return m.DeleteType
	}
	return 0
}

func (m *DeleteFileReq) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

type DeleteFileRsp struct {
	RetCode int32  `protobuf:"varint,10,opt,name=retCode,proto3" json:"retCode,omitempty"`
	RetMsg  string `protobuf:"bytes,20,opt,name=retMsg,proto3" json:"retMsg,omitempty"`
}

func (m *DeleteFileRsp) Reset()         { *m = DeleteFileRsp{} }
func (m *DeleteFileRsp) String() string { return proto.CompactTextString(m) }
func (*DeleteFileRsp) ProtoMessage()    {}
func (*DeleteFileRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{29}
}
func (m *DeleteFileRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteFileRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteFileRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteFileRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteFileRsp.Merge(m, src)
}
func (m *DeleteFileRsp) XXX_Size() int {
	return m.Size()
}
func (m *DeleteFileRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteFileRsp.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteFileRsp proto.InternalMessageInfo

func (m *DeleteFileRsp) GetRetCode() int32 {
	if m != nil {
		return m.RetCode
	}
	return 0
}

func (m *DeleteFileRsp) GetRetMsg() string {
	if m != nil {
		return m.RetMsg
	}
	return ""
}

type DownloadInfo struct {
	DownloadKey    []byte   `protobuf:"bytes,10,opt,name=downloadKey,proto3" json:"downloadKey,omitempty"`
	DownloadIp     string   `protobuf:"bytes,20,opt,name=downloadIp,proto3" json:"downloadIp,omitempty"`
	DownloadDomain string   `protobuf:"bytes,30,opt,name=downloadDomain,proto3" json:"downloadDomain,omitempty"`
	Port           int32    `protobuf:"varint,40,opt,name=port,proto3" json:"port,omitempty"`
	DownloadUrl    string   `protobuf:"bytes,50,opt,name=downloadUrl,proto3" json:"downloadUrl,omitempty"`
	DownloadipList []string `protobuf:"bytes,60,rep,name=downloadipList,proto3" json:"downloadipList,omitempty"`
	Cookie         string   `protobuf:"bytes,70,opt,name=cookie,proto3" json:"cookie,omitempty"`
}

func (m *DownloadInfo) Reset()         { *m = DownloadInfo{} }
func (m *DownloadInfo) String() string { return proto.CompactTextString(m) }
func (*DownloadInfo) ProtoMessage()    {}
func (*DownloadInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{30}
}
func (m *DownloadInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownloadInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DownloadInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DownloadInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadInfo.Merge(m, src)
}
func (m *DownloadInfo) XXX_Size() int {
	return m.Size()
}
func (m *DownloadInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadInfo proto.InternalMessageInfo

func (m *DownloadInfo) GetDownloadKey() []byte {
	if m != nil {
		return m.DownloadKey
	}
	return nil
}

func (m *DownloadInfo) GetDownloadIp() string {
	if m != nil {
		return m.DownloadIp
	}
	return ""
}

func (m *DownloadInfo) GetDownloadDomain() string {
	if m != nil {
		return m.DownloadDomain
	}
	return ""
}

func (m *DownloadInfo) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *DownloadInfo) GetDownloadUrl() string {
	if m != nil {
		return m.DownloadUrl
	}
	return ""
}

func (m *DownloadInfo) GetDownloadipList() []string {
	if m != nil {
		return m.DownloadipList
	}
	return nil
}

func (m *DownloadInfo) GetCookie() string {
	if m != nil {
		return m.Cookie
	}
	return ""
}

type DownloadSuccReq struct {
	Uin  int64  `protobuf:"varint,10,opt,name=uin,proto3" json:"uin,omitempty"`
	Uuid []byte `protobuf:"bytes,20,opt,name=uuid,proto3" json:"uuid,omitempty"`
}

func (m *DownloadSuccReq) Reset()         { *m = DownloadSuccReq{} }
func (m *DownloadSuccReq) String() string { return proto.CompactTextString(m) }
func (*DownloadSuccReq) ProtoMessage()    {}
func (*DownloadSuccReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{31}
}
func (m *DownloadSuccReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownloadSuccReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DownloadSuccReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DownloadSuccReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadSuccReq.Merge(m, src)
}
func (m *DownloadSuccReq) XXX_Size() int {
	return m.Size()
}
func (m *DownloadSuccReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadSuccReq.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadSuccReq proto.InternalMessageInfo

func (m *DownloadSuccReq) GetUin() int64 {
	if m != nil {
		return m.Uin
	}
	return 0
}

func (m *DownloadSuccReq) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

type DownloadSuccRsp struct {
	RetCode  int32  `protobuf:"varint,10,opt,name=retCode,proto3" json:"retCode,omitempty"`
	RetMsg   string `protobuf:"bytes,20,opt,name=retMsg,proto3" json:"retMsg,omitempty"`
	DownStat int32  `protobuf:"varint,30,opt,name=downStat,proto3" json:"downStat,omitempty"`
}

func (m *DownloadSuccRsp) Reset()         { *m = DownloadSuccRsp{} }
func (m *DownloadSuccRsp) String() string { return proto.CompactTextString(m) }
func (*DownloadSuccRsp) ProtoMessage()    {}
func (*DownloadSuccRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{32}
}
func (m *DownloadSuccRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownloadSuccRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DownloadSuccRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DownloadSuccRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadSuccRsp.Merge(m, src)
}
func (m *DownloadSuccRsp) XXX_Size() int {
	return m.Size()
}
func (m *DownloadSuccRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadSuccRsp.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadSuccRsp proto.InternalMessageInfo

func (m *DownloadSuccRsp) GetRetCode() int32 {
	if m != nil {
		return m.RetCode
	}
	return 0
}

func (m *DownloadSuccRsp) GetRetMsg() string {
	if m != nil {
		return m.RetMsg
	}
	return ""
}

func (m *DownloadSuccRsp) GetDownStat() int32 {
	if m != nil {
		return m.DownStat
	}
	return 0
}

type ExtensionReq struct {
	Id               int64          `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Type             int64          `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
	DstPhonenum      string         `protobuf:"bytes,3,opt,name=dstPhonenum,proto3" json:"dstPhonenum,omitempty"`
	PhoneConvertType int32          `protobuf:"varint,4,opt,name=phoneConvertType,proto3" json:"phoneConvertType,omitempty"`
	Sig              []byte         `protobuf:"bytes,20,opt,name=sig,proto3" json:"sig,omitempty"`
	RouteId          int64          `protobuf:"varint,100,opt,name=routeId,proto3" json:"routeId,omitempty"`
	DelMessageReq    *DelMessageReq `protobuf:"bytes,90100,opt,name=delMessageReq,proto3" json:"delMessageReq,omitempty"`
	DownloadUrlType  int32          `protobuf:"varint,90200,opt,name=downloadUrlType,proto3" json:"downloadUrlType,omitempty"`
	PttFormat        int32          `protobuf:"varint,90300,opt,name=pttFormat,proto3" json:"pttFormat,omitempty"`
	IsNeedInnerIp    int32          `protobuf:"varint,90400,opt,name=isNeedInnerIp,proto3" json:"isNeedInnerIp,omitempty"`
	NetType          int32          `protobuf:"varint,90500,opt,name=netType,proto3" json:"netType,omitempty"`
	VoiceType        int32          `protobuf:"varint,90600,opt,name=voiceType,proto3" json:"voiceType,omitempty"`
	FileType         int32          `protobuf:"varint,90700,opt,name=fileType,proto3" json:"fileType,omitempty"`
	PttTime          int32          `protobuf:"varint,90800,opt,name=pttTime,proto3" json:"pttTime,omitempty"`
}

func (m *ExtensionReq) Reset()         { *m = ExtensionReq{} }
func (m *ExtensionReq) String() string { return proto.CompactTextString(m) }
func (*ExtensionReq) ProtoMessage()    {}
func (*ExtensionReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{33}
}
func (m *ExtensionReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExtensionReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExtensionReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExtensionReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtensionReq.Merge(m, src)
}
func (m *ExtensionReq) XXX_Size() int {
	return m.Size()
}
func (m *ExtensionReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtensionReq.DiscardUnknown(m)
}

var xxx_messageInfo_ExtensionReq proto.InternalMessageInfo

func (m *ExtensionReq) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ExtensionReq) GetType() int64 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *ExtensionReq) GetDstPhonenum() string {
	if m != nil {
		return m.DstPhonenum
	}
	return ""
}

func (m *ExtensionReq) GetPhoneConvertType() int32 {
	if m != nil {
		return m.PhoneConvertType
	}
	return 0
}

func (m *ExtensionReq) GetSig() []byte {
	if m != nil {
		return m.Sig
	}
	return nil
}

func (m *ExtensionReq) GetRouteId() int64 {
	if m != nil {
		return m.RouteId
	}
	return 0
}

func (m *ExtensionReq) GetDelMessageReq() *DelMessageReq {
	if m != nil {
		return m.DelMessageReq
	}
	return nil
}

func (m *ExtensionReq) GetDownloadUrlType() int32 {
	if m != nil {
		return m.DownloadUrlType
	}
	return 0
}

func (m *ExtensionReq) GetPttFormat() int32 {
	if m != nil {
		return m.PttFormat
	}
	return 0
}

func (m *ExtensionReq) GetIsNeedInnerIp() int32 {
	if m != nil {
		return m.IsNeedInnerIp
	}
	return 0
}

func (m *ExtensionReq) GetNetType() int32 {
	if m != nil {
		return m.NetType
	}
	return 0
}

func (m *ExtensionReq) GetVoiceType() int32 {
	if m != nil {
		return m.VoiceType
	}
	return 0
}

func (m *ExtensionReq) GetFileType() int32 {
	if m != nil {
		return m.FileType
	}
	return 0
}

func (m *ExtensionReq) GetPttTime() int32 {
	if m != nil {
		return m.PttTime
	}
	return 0
}

type ExtensionRsp struct {
}

func (m *ExtensionRsp) Reset()         { *m = ExtensionRsp{} }
func (m *ExtensionRsp) String() string { return proto.CompactTextString(m) }
func (*ExtensionRsp) ProtoMessage()    {}
func (*ExtensionRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{34}
}
func (m *ExtensionRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExtensionRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExtensionRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExtensionRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtensionRsp.Merge(m, src)
}
func (m *ExtensionRsp) XXX_Size() int {
	return m.Size()
}
func (m *ExtensionRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtensionRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ExtensionRsp proto.InternalMessageInfo

type FileInfo struct {
	Uin          int64  `protobuf:"varint,1,opt,name=uin,proto3" json:"uin,omitempty"`
	DangerEvel   int32  `protobuf:"varint,2,opt,name=dangerEvel,proto3" json:"dangerEvel,omitempty"`
	FileSize     int64  `protobuf:"varint,3,opt,name=fileSize,proto3" json:"fileSize,omitempty"`
	LifeTime     int32  `protobuf:"varint,4,opt,name=lifeTime,proto3" json:"lifeTime,omitempty"`
	UploadTime   int32  `protobuf:"varint,5,opt,name=uploadTime,proto3" json:"uploadTime,omitempty"`
	Uuid         []byte `protobuf:"bytes,6,opt,name=uuid,proto3" json:"uuid,omitempty"`
	FileName     string `protobuf:"bytes,7,opt,name=fileName,proto3" json:"fileName,omitempty"`
	AbsFileType  int32  `protobuf:"varint,90,opt,name=absFileType,proto3" json:"absFileType,omitempty"`
	Bytes_10MMd5 []byte `protobuf:"bytes,100,opt,name=bytes_10mMd5,json=bytes10mMd5,proto3" json:"bytes_10mMd5,omitempty"`
	Sha          []byte `protobuf:"bytes,101,opt,name=sha,proto3" json:"sha,omitempty"`
	ClientType   int32  `protobuf:"varint,110,opt,name=clientType,proto3" json:"clientType,omitempty"`
	OwnerUin     int64  `protobuf:"varint,120,opt,name=ownerUin,proto3" json:"ownerUin,omitempty"`
	PeerUin      int64  `protobuf:"varint,121,opt,name=peerUin,proto3" json:"peerUin,omitempty"`
	ExpireTime   int32  `protobuf:"varint,130,opt,name=expireTime,proto3" json:"expireTime,omitempty"`
}

func (m *FileInfo) Reset()         { *m = FileInfo{} }
func (m *FileInfo) String() string { return proto.CompactTextString(m) }
func (*FileInfo) ProtoMessage()    {}
func (*FileInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{35}
}
func (m *FileInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileInfo.Merge(m, src)
}
func (m *FileInfo) XXX_Size() int {
	return m.Size()
}
func (m *FileInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FileInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FileInfo proto.InternalMessageInfo

func (m *FileInfo) GetUin() int64 {
	if m != nil {
		return m.Uin
	}
	return 0
}

func (m *FileInfo) GetDangerEvel() int32 {
	if m != nil {
		return m.DangerEvel
	}
	return 0
}

func (m *FileInfo) GetFileSize() int64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *FileInfo) GetLifeTime() int32 {
	if m != nil {
		return m.LifeTime
	}
	return 0
}

func (m *FileInfo) GetUploadTime() int32 {
	if m != nil {
		return m.UploadTime
	}
	return 0
}

func (m *FileInfo) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *FileInfo) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *FileInfo) GetAbsFileType() int32 {
	if m != nil {
		return m.AbsFileType
	}
	return 0
}

func (m *FileInfo) GetBytes_10MMd5() []byte {
	if m != nil {
		return m.Bytes_10MMd5
	}
	return nil
}

func (m *FileInfo) GetSha() []byte {
	if m != nil {
		return m.Sha
	}
	return nil
}

func (m *FileInfo) GetClientType() int32 {
	if m != nil {
		return m.ClientType
	}
	return 0
}

func (m *FileInfo) GetOwnerUin() int64 {
	if m != nil {
		return m.OwnerUin
	}
	return 0
}

func (m *FileInfo) GetPeerUin() int64 {
	if m != nil {
		return m.PeerUin
	}
	return 0
}

func (m *FileInfo) GetExpireTime() int32 {
	if m != nil {
		return m.ExpireTime
	}
	return 0
}

type FileQueryReq struct {
	Uin  int64  `protobuf:"varint,10,opt,name=uin,proto3" json:"uin,omitempty"`
	Uuid []byte `protobuf:"bytes,20,opt,name=uuid,proto3" json:"uuid,omitempty"`
}

func (m *FileQueryReq) Reset()         { *m = FileQueryReq{} }
func (m *FileQueryReq) String() string { return proto.CompactTextString(m) }
func (*FileQueryReq) ProtoMessage()    {}
func (*FileQueryReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{36}
}
func (m *FileQueryReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileQueryReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileQueryReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileQueryReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileQueryReq.Merge(m, src)
}
func (m *FileQueryReq) XXX_Size() int {
	return m.Size()
}
func (m *FileQueryReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FileQueryReq.DiscardUnknown(m)
}

var xxx_messageInfo_FileQueryReq proto.InternalMessageInfo

func (m *FileQueryReq) GetUin() int64 {
	if m != nil {
		return m.Uin
	}
	return 0
}

func (m *FileQueryReq) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

type FileQueryRsp struct {
	RetCode  int32     `protobuf:"varint,10,opt,name=retCode,proto3" json:"retCode,omitempty"`
	RetMsg   string    `protobuf:"bytes,20,opt,name=retMsg,proto3" json:"retMsg,omitempty"`
	FileInfo *FileInfo `protobuf:"bytes,30,opt,name=fileInfo,proto3" json:"fileInfo,omitempty"`
}

func (m *FileQueryRsp) Reset()         { *m = FileQueryRsp{} }
func (m *FileQueryRsp) String() string { return proto.CompactTextString(m) }
func (*FileQueryRsp) ProtoMessage()    {}
func (*FileQueryRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{37}
}
func (m *FileQueryRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileQueryRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileQueryRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileQueryRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileQueryRsp.Merge(m, src)
}
func (m *FileQueryRsp) XXX_Size() int {
	return m.Size()
}
func (m *FileQueryRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_FileQueryRsp.DiscardUnknown(m)
}

var xxx_messageInfo_FileQueryRsp proto.InternalMessageInfo

func (m *FileQueryRsp) GetRetCode() int32 {
	if m != nil {
		return m.RetCode
	}
	return 0
}

func (m *FileQueryRsp) GetRetMsg() string {
	if m != nil {
		return m.RetMsg
	}
	return ""
}

func (m *FileQueryRsp) GetFileInfo() *FileInfo {
	if m != nil {
		return m.FileInfo
	}
	return nil
}

type RecallFileReq struct {
	Uin  int64  `protobuf:"varint,1,opt,name=uin,proto3" json:"uin,omitempty"`
	Uuid []byte `protobuf:"bytes,2,opt,name=uuid,proto3" json:"uuid,omitempty"`
}

func (m *RecallFileReq) Reset()         { *m = RecallFileReq{} }
func (m *RecallFileReq) String() string { return proto.CompactTextString(m) }
func (*RecallFileReq) ProtoMessage()    {}
func (*RecallFileReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{38}
}
func (m *RecallFileReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecallFileReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecallFileReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecallFileReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecallFileReq.Merge(m, src)
}
func (m *RecallFileReq) XXX_Size() int {
	return m.Size()
}
func (m *RecallFileReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RecallFileReq.DiscardUnknown(m)
}

var xxx_messageInfo_RecallFileReq proto.InternalMessageInfo

func (m *RecallFileReq) GetUin() int64 {
	if m != nil {
		return m.Uin
	}
	return 0
}

func (m *RecallFileReq) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

type RecallFileRsp struct {
	RetCode int32  `protobuf:"varint,1,opt,name=retCode,proto3" json:"retCode,omitempty"`
	RetMsg  string `protobuf:"bytes,2,opt,name=retMsg,proto3" json:"retMsg,omitempty"`
}

func (m *RecallFileRsp) Reset()         { *m = RecallFileRsp{} }
func (m *RecallFileRsp) String() string { return proto.CompactTextString(m) }
func (*RecallFileRsp) ProtoMessage()    {}
func (*RecallFileRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{39}
}
func (m *RecallFileRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecallFileRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecallFileRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecallFileRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecallFileRsp.Merge(m, src)
}
func (m *RecallFileRsp) XXX_Size() int {
	return m.Size()
}
func (m *RecallFileRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_RecallFileRsp.DiscardUnknown(m)
}

var xxx_messageInfo_RecallFileRsp proto.InternalMessageInfo

func (m *RecallFileRsp) GetRetCode() int32 {
	if m != nil {
		return m.RetCode
	}
	return 0
}

func (m *RecallFileRsp) GetRetMsg() string {
	if m != nil {
		return m.RetMsg
	}
	return ""
}

type RecvListQueryReq struct {
	Uin        int64 `protobuf:"varint,1,opt,name=uin,proto3" json:"uin,omitempty"`
	BeginIndex int32 `protobuf:"varint,2,opt,name=beginIndex,proto3" json:"beginIndex,omitempty"`
	ReqCount   int32 `protobuf:"varint,3,opt,name=reqCount,proto3" json:"reqCount,omitempty"`
}

func (m *RecvListQueryReq) Reset()         { *m = RecvListQueryReq{} }
func (m *RecvListQueryReq) String() string { return proto.CompactTextString(m) }
func (*RecvListQueryReq) ProtoMessage()    {}
func (*RecvListQueryReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{40}
}
func (m *RecvListQueryReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecvListQueryReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecvListQueryReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecvListQueryReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecvListQueryReq.Merge(m, src)
}
func (m *RecvListQueryReq) XXX_Size() int {
	return m.Size()
}
func (m *RecvListQueryReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RecvListQueryReq.DiscardUnknown(m)
}

var xxx_messageInfo_RecvListQueryReq proto.InternalMessageInfo

func (m *RecvListQueryReq) GetUin() int64 {
	if m != nil {
		return m.Uin
	}
	return 0
}

func (m *RecvListQueryReq) GetBeginIndex() int32 {
	if m != nil {
		return m.BeginIndex
	}
	return 0
}

func (m *RecvListQueryReq) GetReqCount() int32 {
	if m != nil {
		return m.ReqCount
	}
	return 0
}

type RecvListQueryRsp struct {
	RetCode      int32       `protobuf:"varint,1,opt,name=retCode,proto3" json:"retCode,omitempty"`
	RetMsg       string      `protobuf:"bytes,2,opt,name=retMsg,proto3" json:"retMsg,omitempty"`
	FileTotCount int32       `protobuf:"varint,3,opt,name=fileTotCount,proto3" json:"fileTotCount,omitempty"`
	BeginIndex   int32       `protobuf:"varint,4,opt,name=beginIndex,proto3" json:"beginIndex,omitempty"`
	RspFileCount int32       `protobuf:"varint,5,opt,name=rspFileCount,proto3" json:"rspFileCount,omitempty"`
	IsEnd        int32       `protobuf:"varint,6,opt,name=isEnd,proto3" json:"isEnd,omitempty"`
	FileList     []*FileInfo `protobuf:"bytes,7,rep,name=fileList,proto3" json:"fileList,omitempty"`
}

func (m *RecvListQueryRsp) Reset()         { *m = RecvListQueryRsp{} }
func (m *RecvListQueryRsp) String() string { return proto.CompactTextString(m) }
func (*RecvListQueryRsp) ProtoMessage()    {}
func (*RecvListQueryRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{41}
}
func (m *RecvListQueryRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecvListQueryRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecvListQueryRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecvListQueryRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecvListQueryRsp.Merge(m, src)
}
func (m *RecvListQueryRsp) XXX_Size() int {
	return m.Size()
}
func (m *RecvListQueryRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_RecvListQueryRsp.DiscardUnknown(m)
}

var xxx_messageInfo_RecvListQueryRsp proto.InternalMessageInfo

func (m *RecvListQueryRsp) GetRetCode() int32 {
	if m != nil {
		return m.RetCode
	}
	return 0
}

func (m *RecvListQueryRsp) GetRetMsg() string {
	if m != nil {
		return m.RetMsg
	}
	return ""
}

func (m *RecvListQueryRsp) GetFileTotCount() int32 {
	if m != nil {
		return m.FileTotCount
	}
	return 0
}

func (m *RecvListQueryRsp) GetBeginIndex() int32 {
	if m != nil {
		return m.BeginIndex
	}
	return 0
}

func (m *RecvListQueryRsp) GetRspFileCount() int32 {
	if m != nil {
		return m.RspFileCount
	}
	return 0
}

func (m *RecvListQueryRsp) GetIsEnd() int32 {
	if m != nil {
		return m.IsEnd
	}
	return 0
}

func (m *RecvListQueryRsp) GetFileList() []*FileInfo {
	if m != nil {
		return m.FileList
	}
	return nil
}

type RenewFileReq struct {
	Uin    int64  `protobuf:"varint,1,opt,name=uin,proto3" json:"uin,omitempty"`
	Uuid   []byte `protobuf:"bytes,2,opt,name=uuid,proto3" json:"uuid,omitempty"`
	AddTtl int32  `protobuf:"varint,3,opt,name=addTtl,proto3" json:"addTtl,omitempty"`
}

func (m *RenewFileReq) Reset()         { *m = RenewFileReq{} }
func (m *RenewFileReq) String() string { return proto.CompactTextString(m) }
func (*RenewFileReq) ProtoMessage()    {}
func (*RenewFileReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{42}
}
func (m *RenewFileReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RenewFileReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RenewFileReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RenewFileReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RenewFileReq.Merge(m, src)
}
func (m *RenewFileReq) XXX_Size() int {
	return m.Size()
}
func (m *RenewFileReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RenewFileReq.DiscardUnknown(m)
}

var xxx_messageInfo_RenewFileReq proto.InternalMessageInfo

func (m *RenewFileReq) GetUin() int64 {
	if m != nil {
		return m.Uin
	}
	return 0
}

func (m *RenewFileReq) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *RenewFileReq) GetAddTtl() int32 {
	if m != nil {
		return m.AddTtl
	}
	return 0
}

type RenewFileRsp struct {
	RetCode int32  `protobuf:"varint,1,opt,name=retCode,proto3" json:"retCode,omitempty"`
	RetMsg  string `protobuf:"bytes,2,opt,name=retMsg,proto3" json:"retMsg,omitempty"`
}

func (m *RenewFileRsp) Reset()         { *m = RenewFileRsp{} }
func (m *RenewFileRsp) String() string { return proto.CompactTextString(m) }
func (*RenewFileRsp) ProtoMessage()    {}
func (*RenewFileRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{43}
}
func (m *RenewFileRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RenewFileRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RenewFileRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RenewFileRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RenewFileRsp.Merge(m, src)
}
func (m *RenewFileRsp) XXX_Size() int {
	return m.Size()
}
func (m *RenewFileRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_RenewFileRsp.DiscardUnknown(m)
}

var xxx_messageInfo_RenewFileRsp proto.InternalMessageInfo

func (m *RenewFileRsp) GetRetCode() int32 {
	if m != nil {
		return m.RetCode
	}
	return 0
}

func (m *RenewFileRsp) GetRetMsg() string {
	if m != nil {
		return m.RetMsg
	}
	return ""
}

type C346ReqBody struct {
	Cmd                  int32                 `protobuf:"varint,1,opt,name=cmd,proto3" json:"cmd,omitempty"`
	Seq                  int32                 `protobuf:"varint,2,opt,name=seq,proto3" json:"seq,omitempty"`
	RecvListQueryReq     *RecvListQueryReq     `protobuf:"bytes,3,opt,name=recvListQueryReq,proto3" json:"recvListQueryReq,omitempty"`
	SendListQueryReq     *SendListQueryReq     `protobuf:"bytes,4,opt,name=sendListQueryReq,proto3" json:"sendListQueryReq,omitempty"`
	RenewFileReq         *RenewFileReq         `protobuf:"bytes,5,opt,name=renewFileReq,proto3" json:"renewFileReq,omitempty"`
	RecallFileReq        *RecallFileReq        `protobuf:"bytes,6,opt,name=recallFileReq,proto3" json:"recallFileReq,omitempty"`
	ApplyUploadReq       *ApplyUploadReq       `protobuf:"bytes,7,opt,name=applyUploadReq,proto3" json:"applyUploadReq,omitempty"`
	ApplyUploadHitReq    *ApplyUploadHitReq    `protobuf:"bytes,8,opt,name=applyUploadHitReq,proto3" json:"applyUploadHitReq,omitempty"`
	ApplyForwardFileReq  *ApplyForwardFileReq  `protobuf:"bytes,9,opt,name=applyForwardFileReq,proto3" json:"applyForwardFileReq,omitempty"`
	UploadSuccReq        *UploadSuccReq        `protobuf:"bytes,10,opt,name=uploadSuccReq,proto3" json:"uploadSuccReq,omitempty"`
	DeleteFileReq        *DeleteFileReq        `protobuf:"bytes,11,opt,name=deleteFileReq,proto3" json:"deleteFileReq,omitempty"`
	DownloadSuccReq      *DownloadSuccReq      `protobuf:"bytes,12,opt,name=downloadSuccReq,proto3" json:"downloadSuccReq,omitempty"`
	ApplyDownloadAbsReq  *ApplyDownloadAbsReq  `protobuf:"bytes,13,opt,name=applyDownloadAbsReq,proto3" json:"applyDownloadAbsReq,omitempty"`
	ApplyDownloadReq     *ApplyDownloadReq     `protobuf:"bytes,14,opt,name=applyDownloadReq,proto3" json:"applyDownloadReq,omitempty"`
	ApplyListDownloadReq *ApplyListDownloadReq `protobuf:"bytes,15,opt,name=applyListDownloadReq,proto3" json:"applyListDownloadReq,omitempty"`
	FileQueryReq         *FileQueryReq         `protobuf:"bytes,16,opt,name=fileQueryReq,proto3" json:"fileQueryReq,omitempty"`
	ApplyCopyFromReq     *ApplyCopyFromReq     `protobuf:"bytes,17,opt,name=applyCopyFromReq,proto3" json:"applyCopyFromReq,omitempty"`
	ApplyUploadReqV2     *ApplyUploadReqV2     `protobuf:"bytes,18,opt,name=applyUploadReqV2,proto3" json:"applyUploadReqV2,omitempty"`
	ApplyUploadReqV3     *ApplyUploadReqV3     `protobuf:"bytes,19,opt,name=applyUploadReqV3,proto3" json:"applyUploadReqV3,omitempty"`
	ApplyUploadHitReqV2  *ApplyUploadHitReqV2  `protobuf:"bytes,20,opt,name=applyUploadHitReqV2,proto3" json:"applyUploadHitReqV2,omitempty"`
	ApplyUploadHitReqV3  *ApplyUploadHitReqV3  `protobuf:"bytes,21,opt,name=applyUploadHitReqV3,proto3" json:"applyUploadHitReqV3,omitempty"`
	BusinessId           int32                 `protobuf:"varint,101,opt,name=businessId,proto3" json:"businessId,omitempty"`
	ClientType           int32                 `protobuf:"varint,102,opt,name=clientType,proto3" json:"clientType,omitempty"`
	ApplyCopyToReq       *ApplyCopyToReq       `protobuf:"bytes,90000,opt,name=applyCopyToReq,proto3" json:"applyCopyToReq,omitempty"`
	//ApplyCleanTrafficReq applyCleanTrafficReq = 90001; empty message
	ApplyGetTrafficReq *ApplyGetTrafficReq `protobuf:"bytes,90002,opt,name=applyGetTrafficReq,proto3" json:"applyGetTrafficReq,omitempty"`
	ExtensionReq       *ExtensionReq       `protobuf:"bytes,99999,opt,name=extensionReq,proto3" json:"extensionReq,omitempty"`
}

func (m *C346ReqBody) Reset()         { *m = C346ReqBody{} }
func (m *C346ReqBody) String() string { return proto.CompactTextString(m) }
func (*C346ReqBody) ProtoMessage()    {}
func (*C346ReqBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{44}
}
func (m *C346ReqBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C346ReqBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C346ReqBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C346ReqBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C346ReqBody.Merge(m, src)
}
func (m *C346ReqBody) XXX_Size() int {
	return m.Size()
}
func (m *C346ReqBody) XXX_DiscardUnknown() {
	xxx_messageInfo_C346ReqBody.DiscardUnknown(m)
}

var xxx_messageInfo_C346ReqBody proto.InternalMessageInfo

func (m *C346ReqBody) GetCmd() int32 {
	if m != nil {
		return m.Cmd
	}
	return 0
}

func (m *C346ReqBody) GetSeq() int32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *C346ReqBody) GetRecvListQueryReq() *RecvListQueryReq {
	if m != nil {
		return m.RecvListQueryReq
	}
	return nil
}

func (m *C346ReqBody) GetSendListQueryReq() *SendListQueryReq {
	if m != nil {
		return m.SendListQueryReq
	}
	return nil
}

func (m *C346ReqBody) GetRenewFileReq() *RenewFileReq {
	if m != nil {
		return m.RenewFileReq
	}
	return nil
}

func (m *C346ReqBody) GetRecallFileReq() *RecallFileReq {
	if m != nil {
		return m.RecallFileReq
	}
	return nil
}

func (m *C346ReqBody) GetApplyUploadReq() *ApplyUploadReq {
	if m != nil {
		return m.ApplyUploadReq
	}
	return nil
}

func (m *C346ReqBody) GetApplyUploadHitReq() *ApplyUploadHitReq {
	if m != nil {
		return m.ApplyUploadHitReq
	}
	return nil
}

func (m *C346ReqBody) GetApplyForwardFileReq() *ApplyForwardFileReq {
	if m != nil {
		return m.ApplyForwardFileReq
	}
	return nil
}

func (m *C346ReqBody) GetUploadSuccReq() *UploadSuccReq {
	if m != nil {
		return m.UploadSuccReq
	}
	return nil
}

func (m *C346ReqBody) GetDeleteFileReq() *DeleteFileReq {
	if m != nil {
		return m.DeleteFileReq
	}
	return nil
}

func (m *C346ReqBody) GetDownloadSuccReq() *DownloadSuccReq {
	if m != nil {
		return m.DownloadSuccReq
	}
	return nil
}

func (m *C346ReqBody) GetApplyDownloadAbsReq() *ApplyDownloadAbsReq {
	if m != nil {
		return m.ApplyDownloadAbsReq
	}
	return nil
}

func (m *C346ReqBody) GetApplyDownloadReq() *ApplyDownloadReq {
	if m != nil {
		return m.ApplyDownloadReq
	}
	return nil
}

func (m *C346ReqBody) GetApplyListDownloadReq() *ApplyListDownloadReq {
	if m != nil {
		return m.ApplyListDownloadReq
	}
	return nil
}

func (m *C346ReqBody) GetFileQueryReq() *FileQueryReq {
	if m != nil {
		return m.FileQueryReq
	}
	return nil
}

func (m *C346ReqBody) GetApplyCopyFromReq() *ApplyCopyFromReq {
	if m != nil {
		return m.ApplyCopyFromReq
	}
	return nil
}

func (m *C346ReqBody) GetApplyUploadReqV2() *ApplyUploadReqV2 {
	if m != nil {
		return m.ApplyUploadReqV2
	}
	return nil
}

func (m *C346ReqBody) GetApplyUploadReqV3() *ApplyUploadReqV3 {
	if m != nil {
		return m.ApplyUploadReqV3
	}
	return nil
}

func (m *C346ReqBody) GetApplyUploadHitReqV2() *ApplyUploadHitReqV2 {
	if m != nil {
		return m.ApplyUploadHitReqV2
	}
	return nil
}

func (m *C346ReqBody) GetApplyUploadHitReqV3() *ApplyUploadHitReqV3 {
	if m != nil {
		return m.ApplyUploadHitReqV3
	}
	return nil
}

func (m *C346ReqBody) GetBusinessId() int32 {
	if m != nil {
		return m.BusinessId
	}
	return 0
}

func (m *C346ReqBody) GetClientType() int32 {
	if m != nil {
		return m.ClientType
	}
	return 0
}

func (m *C346ReqBody) GetApplyCopyToReq() *ApplyCopyToReq {
	if m != nil {
		return m.ApplyCopyToReq
	}
	return nil
}

func (m *C346ReqBody) GetApplyGetTrafficReq() *ApplyGetTrafficReq {
	if m != nil {
		return m.ApplyGetTrafficReq
	}
	return nil
}

func (m *C346ReqBody) GetExtensionReq() *ExtensionReq {
	if m != nil {
		return m.ExtensionReq
	}
	return nil
}

type C346RspBody struct {
	Cmd                  int32                 `protobuf:"varint,1,opt,name=cmd,proto3" json:"cmd,omitempty"`
	Seq                  int32                 `protobuf:"varint,2,opt,name=seq,proto3" json:"seq,omitempty"`
	RecvListQueryRsp     *RecvListQueryRsp     `protobuf:"bytes,3,opt,name=recvListQueryRsp,proto3" json:"recvListQueryRsp,omitempty"`
	SendListQueryRsp     *SendListQueryRsp     `protobuf:"bytes,4,opt,name=sendListQueryRsp,proto3" json:"sendListQueryRsp,omitempty"`
	RenewFileRsp         *RenewFileRsp         `protobuf:"bytes,5,opt,name=renewFileRsp,proto3" json:"renewFileRsp,omitempty"`
	RecallFileRsp        *RecallFileRsp        `protobuf:"bytes,6,opt,name=recallFileRsp,proto3" json:"recallFileRsp,omitempty"`
	ApplyUploadRsp       *ApplyUploadRsp       `protobuf:"bytes,7,opt,name=applyUploadRsp,proto3" json:"applyUploadRsp,omitempty"`
	ApplyUploadHitRsp    *ApplyUploadHitRsp    `protobuf:"bytes,8,opt,name=applyUploadHitRsp,proto3" json:"applyUploadHitRsp,omitempty"`
	ApplyForwardFileRsp  *ApplyForwardFileRsp  `protobuf:"bytes,9,opt,name=applyForwardFileRsp,proto3" json:"applyForwardFileRsp,omitempty"`
	UploadSuccRsp        *UploadSuccRsp        `protobuf:"bytes,10,opt,name=uploadSuccRsp,proto3" json:"uploadSuccRsp,omitempty"`
	DeleteFileRsp        *DeleteFileRsp        `protobuf:"bytes,11,opt,name=deleteFileRsp,proto3" json:"deleteFileRsp,omitempty"`
	DownloadSuccRsp      *DownloadSuccRsp      `protobuf:"bytes,12,opt,name=downloadSuccRsp,proto3" json:"downloadSuccRsp,omitempty"`
	ApplyDownloadAbsRsp  *ApplyDownloadAbsRsp  `protobuf:"bytes,13,opt,name=applyDownloadAbsRsp,proto3" json:"applyDownloadAbsRsp,omitempty"`
	ApplyDownloadRsp     *ApplyDownloadRsp     `protobuf:"bytes,14,opt,name=applyDownloadRsp,proto3" json:"applyDownloadRsp,omitempty"`
	ApplyListDownloadRsp *ApplyListDownloadRsp `protobuf:"bytes,15,opt,name=applyListDownloadRsp,proto3" json:"applyListDownloadRsp,omitempty"`
	FileQueryRsp         *FileQueryRsp         `protobuf:"bytes,16,opt,name=fileQueryRsp,proto3" json:"fileQueryRsp,omitempty"`
	ApplyCopyFromRsp     *ApplyCopyFromRsp     `protobuf:"bytes,17,opt,name=applyCopyFromRsp,proto3" json:"applyCopyFromRsp,omitempty"`
	ApplyUploadRspV2     *ApplyUploadRspV2     `protobuf:"bytes,18,opt,name=applyUploadRspV2,proto3" json:"applyUploadRspV2,omitempty"`
	ApplyUploadRspV3     *ApplyUploadRspV3     `protobuf:"bytes,19,opt,name=applyUploadRspV3,proto3" json:"applyUploadRspV3,omitempty"`
	ApplyUploadHitRspV2  *ApplyUploadHitRspV2  `protobuf:"bytes,20,opt,name=applyUploadHitRspV2,proto3" json:"applyUploadHitRspV2,omitempty"`
	ApplyUploadHitRspV3  *ApplyUploadHitRspV3  `protobuf:"bytes,21,opt,name=applyUploadHitRspV3,proto3" json:"applyUploadHitRspV3,omitempty"`
	BusinessId           int32                 `protobuf:"varint,101,opt,name=businessId,proto3" json:"businessId,omitempty"`
	ClientType           int32                 `protobuf:"varint,102,opt,name=clientType,proto3" json:"clientType,omitempty"`
	ApplyCopyToRsp       *ApplyCopyToRsp       `protobuf:"bytes,90000,opt,name=applyCopyToRsp,proto3" json:"applyCopyToRsp,omitempty"`
	ApplyCleanTrafficRsp *ApplyCleanTrafficRsp `protobuf:"bytes,90001,opt,name=applyCleanTrafficRsp,proto3" json:"applyCleanTrafficRsp,omitempty"`
	ApplyGetTrafficRsp   *ApplyGetTrafficRsp   `protobuf:"bytes,90002,opt,name=applyGetTrafficRsp,proto3" json:"applyGetTrafficRsp,omitempty"`
	ExtensionRsp         *ExtensionRsp         `protobuf:"bytes,99999,opt,name=extensionRsp,proto3" json:"extensionRsp,omitempty"`
}

func (m *C346RspBody) Reset()         { *m = C346RspBody{} }
func (m *C346RspBody) String() string { return proto.CompactTextString(m) }
func (*C346RspBody) ProtoMessage()    {}
func (*C346RspBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{45}
}
func (m *C346RspBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C346RspBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C346RspBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C346RspBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C346RspBody.Merge(m, src)
}
func (m *C346RspBody) XXX_Size() int {
	return m.Size()
}
func (m *C346RspBody) XXX_DiscardUnknown() {
	xxx_messageInfo_C346RspBody.DiscardUnknown(m)
}

var xxx_messageInfo_C346RspBody proto.InternalMessageInfo

func (m *C346RspBody) GetCmd() int32 {
	if m != nil {
		return m.Cmd
	}
	return 0
}

func (m *C346RspBody) GetSeq() int32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *C346RspBody) GetRecvListQueryRsp() *RecvListQueryRsp {
	if m != nil {
		return m.RecvListQueryRsp
	}
	return nil
}

func (m *C346RspBody) GetSendListQueryRsp() *SendListQueryRsp {
	if m != nil {
		return m.SendListQueryRsp
	}
	return nil
}

func (m *C346RspBody) GetRenewFileRsp() *RenewFileRsp {
	if m != nil {
		return m.RenewFileRsp
	}
	return nil
}

func (m *C346RspBody) GetRecallFileRsp() *RecallFileRsp {
	if m != nil {
		return m.RecallFileRsp
	}
	return nil
}

func (m *C346RspBody) GetApplyUploadRsp() *ApplyUploadRsp {
	if m != nil {
		return m.ApplyUploadRsp
	}
	return nil
}

func (m *C346RspBody) GetApplyUploadHitRsp() *ApplyUploadHitRsp {
	if m != nil {
		return m.ApplyUploadHitRsp
	}
	return nil
}

func (m *C346RspBody) GetApplyForwardFileRsp() *ApplyForwardFileRsp {
	if m != nil {
		return m.ApplyForwardFileRsp
	}
	return nil
}

func (m *C346RspBody) GetUploadSuccRsp() *UploadSuccRsp {
	if m != nil {
		return m.UploadSuccRsp
	}
	return nil
}

func (m *C346RspBody) GetDeleteFileRsp() *DeleteFileRsp {
	if m != nil {
		return m.DeleteFileRsp
	}
	return nil
}

func (m *C346RspBody) GetDownloadSuccRsp() *DownloadSuccRsp {
	if m != nil {
		return m.DownloadSuccRsp
	}
	return nil
}

func (m *C346RspBody) GetApplyDownloadAbsRsp() *ApplyDownloadAbsRsp {
	if m != nil {
		return m.ApplyDownloadAbsRsp
	}
	return nil
}

func (m *C346RspBody) GetApplyDownloadRsp() *ApplyDownloadRsp {
	if m != nil {
		return m.ApplyDownloadRsp
	}
	return nil
}

func (m *C346RspBody) GetApplyListDownloadRsp() *ApplyListDownloadRsp {
	if m != nil {
		return m.ApplyListDownloadRsp
	}
	return nil
}

func (m *C346RspBody) GetFileQueryRsp() *FileQueryRsp {
	if m != nil {
		return m.FileQueryRsp
	}
	return nil
}

func (m *C346RspBody) GetApplyCopyFromRsp() *ApplyCopyFromRsp {
	if m != nil {
		return m.ApplyCopyFromRsp
	}
	return nil
}

func (m *C346RspBody) GetApplyUploadRspV2() *ApplyUploadRspV2 {
	if m != nil {
		return m.ApplyUploadRspV2
	}
	return nil
}

func (m *C346RspBody) GetApplyUploadRspV3() *ApplyUploadRspV3 {
	if m != nil {
		return m.ApplyUploadRspV3
	}
	return nil
}

func (m *C346RspBody) GetApplyUploadHitRspV2() *ApplyUploadHitRspV2 {
	if m != nil {
		return m.ApplyUploadHitRspV2
	}
	return nil
}

func (m *C346RspBody) GetApplyUploadHitRspV3() *ApplyUploadHitRspV3 {
	if m != nil {
		return m.ApplyUploadHitRspV3
	}
	return nil
}

func (m *C346RspBody) GetBusinessId() int32 {
	if m != nil {
		return m.BusinessId
	}
	return 0
}

func (m *C346RspBody) GetClientType() int32 {
	if m != nil {
		return m.ClientType
	}
	return 0
}

func (m *C346RspBody) GetApplyCopyToRsp() *ApplyCopyToRsp {
	if m != nil {
		return m.ApplyCopyToRsp
	}
	return nil
}

func (m *C346RspBody) GetApplyCleanTrafficRsp() *ApplyCleanTrafficRsp {
	if m != nil {
		return m.ApplyCleanTrafficRsp
	}
	return nil
}

func (m *C346RspBody) GetApplyGetTrafficRsp() *ApplyGetTrafficRsp {
	if m != nil {
		return m.ApplyGetTrafficRsp
	}
	return nil
}

func (m *C346RspBody) GetExtensionRsp() *ExtensionRsp {
	if m != nil {
		return m.ExtensionRsp
	}
	return nil
}

type SendListQueryReq struct {
	Uin        int64 `protobuf:"varint,1,opt,name=uin,proto3" json:"uin,omitempty"`
	BeginIndex int32 `protobuf:"varint,2,opt,name=beginIndex,proto3" json:"beginIndex,omitempty"`
	ReqCount   int32 `protobuf:"varint,3,opt,name=reqCount,proto3" json:"reqCount,omitempty"`
}

func (m *SendListQueryReq) Reset()         { *m = SendListQueryReq{} }
func (m *SendListQueryReq) String() string { return proto.CompactTextString(m) }
func (*SendListQueryReq) ProtoMessage()    {}
func (*SendListQueryReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{46}
}
func (m *SendListQueryReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendListQueryReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendListQueryReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendListQueryReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendListQueryReq.Merge(m, src)
}
func (m *SendListQueryReq) XXX_Size() int {
	return m.Size()
}
func (m *SendListQueryReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SendListQueryReq.DiscardUnknown(m)
}

var xxx_messageInfo_SendListQueryReq proto.InternalMessageInfo

func (m *SendListQueryReq) GetUin() int64 {
	if m != nil {
		return m.Uin
	}
	return 0
}

func (m *SendListQueryReq) GetBeginIndex() int32 {
	if m != nil {
		return m.BeginIndex
	}
	return 0
}

func (m *SendListQueryReq) GetReqCount() int32 {
	if m != nil {
		return m.ReqCount
	}
	return 0
}

type SendListQueryRsp struct {
	RetCode      int32       `protobuf:"varint,1,opt,name=retCode,proto3" json:"retCode,omitempty"`
	RetMsg       string      `protobuf:"bytes,2,opt,name=retMsg,proto3" json:"retMsg,omitempty"`
	FileTotCount int32       `protobuf:"varint,3,opt,name=fileTotCount,proto3" json:"fileTotCount,omitempty"`
	BeginIndex   int32       `protobuf:"varint,4,opt,name=beginIndex,proto3" json:"beginIndex,omitempty"`
	RspFileCount int32       `protobuf:"varint,5,opt,name=rspFileCount,proto3" json:"rspFileCount,omitempty"`
	IsEnd        int32       `protobuf:"varint,6,opt,name=isEnd,proto3" json:"isEnd,omitempty"`
	TotLimit     int64       `protobuf:"varint,7,opt,name=totLimit,proto3" json:"totLimit,omitempty"`
	UsedLimit    int64       `protobuf:"varint,8,opt,name=usedLimit,proto3" json:"usedLimit,omitempty"`
	FileList     []*FileInfo `protobuf:"bytes,9,rep,name=fileList,proto3" json:"fileList,omitempty"`
}

func (m *SendListQueryRsp) Reset()         { *m = SendListQueryRsp{} }
func (m *SendListQueryRsp) String() string { return proto.CompactTextString(m) }
func (*SendListQueryRsp) ProtoMessage()    {}
func (*SendListQueryRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{47}
}
func (m *SendListQueryRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendListQueryRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendListQueryRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendListQueryRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendListQueryRsp.Merge(m, src)
}
func (m *SendListQueryRsp) XXX_Size() int {
	return m.Size()
}
func (m *SendListQueryRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_SendListQueryRsp.DiscardUnknown(m)
}

var xxx_messageInfo_SendListQueryRsp proto.InternalMessageInfo

func (m *SendListQueryRsp) GetRetCode() int32 {
	if m != nil {
		return m.RetCode
	}
	return 0
}

func (m *SendListQueryRsp) GetRetMsg() string {
	if m != nil {
		return m.RetMsg
	}
	return ""
}

func (m *SendListQueryRsp) GetFileTotCount() int32 {
	if m != nil {
		return m.FileTotCount
	}
	return 0
}

func (m *SendListQueryRsp) GetBeginIndex() int32 {
	if m != nil {
		return m.BeginIndex
	}
	return 0
}

func (m *SendListQueryRsp) GetRspFileCount() int32 {
	if m != nil {
		return m.RspFileCount
	}
	return 0
}

func (m *SendListQueryRsp) GetIsEnd() int32 {
	if m != nil {
		return m.IsEnd
	}
	return 0
}

func (m *SendListQueryRsp) GetTotLimit() int64 {
	if m != nil {
		return m.TotLimit
	}
	return 0
}

func (m *SendListQueryRsp) GetUsedLimit() int64 {
	if m != nil {
		return m.UsedLimit
	}
	return 0
}

func (m *SendListQueryRsp) GetFileList() []*FileInfo {
	if m != nil {
		return m.FileList
	}
	return nil
}

type UploadSuccReq struct {
	SenderUin int64  `protobuf:"varint,10,opt,name=senderUin,proto3" json:"senderUin,omitempty"`
	RecverUin int64  `protobuf:"varint,20,opt,name=recverUin,proto3" json:"recverUin,omitempty"`
	Uuid      []byte `protobuf:"bytes,30,opt,name=uuid,proto3" json:"uuid,omitempty"`
}

func (m *UploadSuccReq) Reset()         { *m = UploadSuccReq{} }
func (m *UploadSuccReq) String() string { return proto.CompactTextString(m) }
func (*UploadSuccReq) ProtoMessage()    {}
func (*UploadSuccReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{48}
}
func (m *UploadSuccReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadSuccReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadSuccReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadSuccReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadSuccReq.Merge(m, src)
}
func (m *UploadSuccReq) XXX_Size() int {
	return m.Size()
}
func (m *UploadSuccReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadSuccReq.DiscardUnknown(m)
}

var xxx_messageInfo_UploadSuccReq proto.InternalMessageInfo

func (m *UploadSuccReq) GetSenderUin() int64 {
	if m != nil {
		return m.SenderUin
	}
	return 0
}

func (m *UploadSuccReq) GetRecverUin() int64 {
	if m != nil {
		return m.RecverUin
	}
	return 0
}

func (m *UploadSuccReq) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

type UploadSuccRsp struct {
	RetCode  int32     `protobuf:"varint,10,opt,name=retCode,proto3" json:"retCode,omitempty"`
	RetMsg   string    `protobuf:"bytes,20,opt,name=retMsg,proto3" json:"retMsg,omitempty"`
	FileInfo *FileInfo `protobuf:"bytes,30,opt,name=fileInfo,proto3" json:"fileInfo,omitempty"`
}

func (m *UploadSuccRsp) Reset()         { *m = UploadSuccRsp{} }
func (m *UploadSuccRsp) String() string { return proto.CompactTextString(m) }
func (*UploadSuccRsp) ProtoMessage()    {}
func (*UploadSuccRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cae71bbfd9eed02, []int{49}
}
func (m *UploadSuccRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadSuccRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadSuccRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadSuccRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadSuccRsp.Merge(m, src)
}
func (m *UploadSuccRsp) XXX_Size() int {
	return m.Size()
}
func (m *UploadSuccRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadSuccRsp.DiscardUnknown(m)
}

var xxx_messageInfo_UploadSuccRsp proto.InternalMessageInfo

func (m *UploadSuccRsp) GetRetCode() int32 {
	if m != nil {
		return m.RetCode
	}
	return 0
}

func (m *UploadSuccRsp) GetRetMsg() string {
	if m != nil {
		return m.RetMsg
	}
	return ""
}

func (m *UploadSuccRsp) GetFileInfo() *FileInfo {
	if m != nil {
		return m.FileInfo
	}
	return nil
}

func init() {
	proto.RegisterType((*ApplyCleanTrafficRsp)(nil), "ApplyCleanTrafficRsp")
	proto.RegisterType((*ApplyCopyFromReq)(nil), "ApplyCopyFromReq")
	proto.RegisterType((*ApplyCopyFromRsp)(nil), "ApplyCopyFromRsp")
	proto.RegisterType((*ApplyCopyToReq)(nil), "ApplyCopyToReq")
	proto.RegisterType((*ApplyCopyToRsp)(nil), "ApplyCopyToRsp")
	proto.RegisterType((*ApplyDownloadAbsReq)(nil), "ApplyDownloadAbsReq")
	proto.RegisterType((*ApplyDownloadAbsRsp)(nil), "ApplyDownloadAbsRsp")
	proto.RegisterType((*ApplyDownloadReq)(nil), "ApplyDownloadReq")
	proto.RegisterType((*ApplyDownloadRsp)(nil), "ApplyDownloadRsp")
	proto.RegisterType((*ApplyForwardFileReq)(nil), "ApplyForwardFileReq")
	proto.RegisterType((*ApplyForwardFileRsp)(nil), "ApplyForwardFileRsp")
	proto.RegisterType((*ApplyGetTrafficReq)(nil), "ApplyGetTrafficReq")
	proto.RegisterType((*ApplyGetTrafficRsp)(nil), "ApplyGetTrafficRsp")
	proto.RegisterType((*ApplyListDownloadReq)(nil), "ApplyListDownloadReq")
	proto.RegisterType((*ApplyListDownloadRsp)(nil), "ApplyListDownloadRsp")
	proto.RegisterType((*ApplyUploadHitReq)(nil), "ApplyUploadHitReq")
	proto.RegisterType((*ApplyUploadHitReqV2)(nil), "ApplyUploadHitReqV2")
	proto.RegisterType((*ApplyUploadHitReqV3)(nil), "ApplyUploadHitReqV3")
	proto.RegisterType((*ApplyUploadHitRsp)(nil), "ApplyUploadHitRsp")
	proto.RegisterType((*ApplyUploadHitRspV2)(nil), "ApplyUploadHitRspV2")
	proto.RegisterType((*ApplyUploadHitRspV3)(nil), "ApplyUploadHitRspV3")
	proto.RegisterType((*ApplyUploadReq)(nil), "ApplyUploadReq")
	proto.RegisterType((*ApplyUploadReqV2)(nil), "ApplyUploadReqV2")
	proto.RegisterType((*ApplyUploadReqV3)(nil), "ApplyUploadReqV3")
	proto.RegisterType((*ApplyUploadRsp)(nil), "ApplyUploadRsp")
	proto.RegisterType((*ApplyUploadRspV2)(nil), "ApplyUploadRspV2")
	proto.RegisterType((*ApplyUploadRspV3)(nil), "ApplyUploadRspV3")
	proto.RegisterType((*DelMessageReq)(nil), "DelMessageReq")
	proto.RegisterType((*DeleteFileReq)(nil), "DeleteFileReq")
	proto.RegisterType((*DeleteFileRsp)(nil), "DeleteFileRsp")
	proto.RegisterType((*DownloadInfo)(nil), "DownloadInfo")
	proto.RegisterType((*DownloadSuccReq)(nil), "DownloadSuccReq")
	proto.RegisterType((*DownloadSuccRsp)(nil), "DownloadSuccRsp")
	proto.RegisterType((*ExtensionReq)(nil), "ExtensionReq")
	proto.RegisterType((*ExtensionRsp)(nil), "ExtensionRsp")
	proto.RegisterType((*FileInfo)(nil), "FileInfo")
	proto.RegisterType((*FileQueryReq)(nil), "FileQueryReq")
	proto.RegisterType((*FileQueryRsp)(nil), "FileQueryRsp")
	proto.RegisterType((*RecallFileReq)(nil), "RecallFileReq")
	proto.RegisterType((*RecallFileRsp)(nil), "RecallFileRsp")
	proto.RegisterType((*RecvListQueryReq)(nil), "RecvListQueryReq")
	proto.RegisterType((*RecvListQueryRsp)(nil), "RecvListQueryRsp")
	proto.RegisterType((*RenewFileReq)(nil), "RenewFileReq")
	proto.RegisterType((*RenewFileRsp)(nil), "RenewFileRsp")
	proto.RegisterType((*C346ReqBody)(nil), "C346ReqBody")
	proto.RegisterType((*C346RspBody)(nil), "C346RspBody")
	proto.RegisterType((*SendListQueryReq)(nil), "SendListQueryReq")
	proto.RegisterType((*SendListQueryRsp)(nil), "SendListQueryRsp")
	proto.RegisterType((*UploadSuccReq)(nil), "UploadSuccReq")
	proto.RegisterType((*UploadSuccRsp)(nil), "UploadSuccRsp")
}

func init() { proto.RegisterFile("cmd0x346.proto", fileDescriptor_5cae71bbfd9eed02) }

var fileDescriptor_5cae71bbfd9eed02 = []byte{
	// 2615 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5a, 0xcf, 0x6f, 0xdc, 0xc6,
	0xf5, 0x0f, 0x77, 0x2d, 0x4b, 0x3b, 0xda, 0x95, 0x64, 0x5a, 0xf9, 0x82, 0x30, 0x92, 0xfd, 0xaa,
	0xac, 0x13, 0x2c, 0x72, 0x58, 0xc4, 0xbb, 0x8e, 0x83, 0x36, 0x2a, 0x10, 0xc7, 0xf6, 0x26, 0x42,
	0x6c, 0x43, 0x1d, 0xd9, 0x3e, 0x08, 0x05, 0x5c, 0x6a, 0x39, 0x92, 0x89, 0xec, 0x92, 0x23, 0x0e,
	0x57, 0x96, 0x72, 0x0c, 0x7a, 0x6c, 0x80, 0xc4, 0x40, 0x51, 0xe4, 0xd0, 0xa6, 0x40, 0x80, 0xf6,
	0xd0, 0x4b, 0xfe, 0x80, 0x02, 0xfd, 0x19, 0xa0, 0x28, 0x82, 0x22, 0xe8, 0x29, 0xbd, 0xb5, 0x76,
	0x0f, 0xed, 0xa5, 0xa7, 0xfc, 0x01, 0xc5, 0xfc, 0x20, 0x39, 0xbf, 0x28, 0xa9, 0x1b, 0x3b, 0x75,
	0x00, 0xdf, 0xf8, 0xde, 0xbc, 0x37, 0xf3, 0xe6, 0xcd, 0x9b, 0xcf, 0x7b, 0x9c, 0x19, 0xb0, 0x30,
	0x1c, 0x87, 0x2f, 0xee, 0xf7, 0xcf, 0x5f, 0xe8, 0xe2, 0x34, 0xc9, 0x12, 0xff, 0x0d, 0xb0, 0x7c,
	0x11, 0xe3, 0xd1, 0xc1, 0xa5, 0x11, 0x0a, 0xe2, 0x1b, 0x69, 0xb0, 0xbd, 0x1d, 0x0d, 0x21, 0xc1,
	0xae, 0x07, 0x66, 0x53, 0x94, 0x5d, 0x4a, 0x42, 0xe4, 0x81, 0x15, 0xa7, 0x33, 0x03, 0x73, 0xd2,
	0xfd, 0x3f, 0x70, 0x32, 0x45, 0xd9, 0x35, 0xb2, 0xe3, 0x2d, 0xaf, 0x38, 0x9d, 0x06, 0x14, 0x94,
	0xff, 0x97, 0x1a, 0x58, 0xe2, 0x5d, 0x25, 0xf8, 0x60, 0x90, 0x26, 0x63, 0x88, 0x76, 0xa9, 0x30,
	0x49, 0x87, 0x37, 0xa3, 0x98, 0xf5, 0x52, 0x87, 0x82, 0x72, 0xcf, 0x80, 0x39, 0x92, 0x0e, 0x5f,
	0x4f, 0x93, 0x09, 0x66, 0xdd, 0xd4, 0x61, 0x41, 0x8b, 0xb6, 0x8d, 0xbd, 0x61, 0x14, 0x7a, 0x6d,
	0x36, 0x76, 0x41, 0xbb, 0x1d, 0xb0, 0x48, 0xd2, 0xe1, 0x7a, 0x90, 0xa2, 0x38, 0xdb, 0x4e, 0x46,
	0x21, 0x4a, 0xbd, 0xce, 0x8a, 0xd3, 0x69, 0x42, 0x9d, 0x4d, 0x27, 0x40, 0xc7, 0x9a, 0x44, 0xa1,
	0xd7, 0x63, 0x12, 0x39, 0x49, 0x5b, 0xb6, 0xa3, 0x11, 0xba, 0x16, 0xbe, 0xe4, 0xad, 0xf2, 0x16,
	0x41, 0x52, 0x6b, 0x43, 0x92, 0x51, 0x6b, 0x07, 0xdc, 0x5a, 0x4e, 0x51, 0x8b, 0xa8, 0xc8, 0x46,
	0xf4, 0x36, 0xf2, 0xd6, 0xb9, 0xb5, 0x39, 0x9d, 0xb7, 0x5d, 0x0f, 0xc6, 0xc8, 0xdb, 0x64, 0x0e,
	0x29, 0x68, 0x77, 0x05, 0xcc, 0x87, 0x41, 0xbc, 0x83, 0xd2, 0xab, 0x68, 0x0f, 0x8d, 0xbc, 0x90,
	0x4d, 0x46, 0x66, 0xb9, 0x6d, 0x00, 0xb2, 0x24, 0x0b, 0x46, 0x1b, 0x38, 0x18, 0x22, 0x2f, 0x66,
	0x7d, 0x4b, 0x1c, 0x7f, 0x5f, 0xf7, 0xe9, 0x34, 0x4b, 0xe3, 0xba, 0xe0, 0xc4, 0x64, 0x22, 0xbc,
	0xd9, 0x84, 0xec, 0x5b, 0x1b, 0xb9, 0x63, 0x8c, 0xfc, 0x0f, 0x07, 0x2c, 0x14, 0x43, 0xdf, 0x48,
	0xe8, 0x62, 0x2e, 0x83, 0x99, 0x90, 0x64, 0x6b, 0xa1, 0x58, 0x4b, 0x4e, 0x48, 0x4e, 0x5b, 0xd6,
	0x9d, 0x16, 0x92, 0x4c, 0x59, 0xc6, 0x9c, 0x96, 0xc2, 0xa2, 0xa3, 0x87, 0x45, 0xe1, 0xe8, 0xde,
	0x21, 0x8e, 0x5e, 0xd5, 0x1c, 0x7d, 0x16, 0xb4, 0x46, 0xc9, 0x30, 0x18, 0x0d, 0xa2, 0x11, 0xc2,
	0x41, 0x76, 0x87, 0xad, 0x5f, 0x03, 0xaa, 0xcc, 0xc2, 0x0d, 0xeb, 0xa5, 0x1b, 0xfc, 0xef, 0xa9,
	0xb3, 0x9c, 0xca, 0xbd, 0x22, 0xa0, 0xde, 0x44, 0x07, 0x6c, 0xa2, 0x0d, 0x98, 0x93, 0xfe, 0x2b,
	0xe0, 0x34, 0xeb, 0xfd, 0x72, 0x72, 0x37, 0x1e, 0x25, 0x41, 0x78, 0x71, 0x8b, 0x50, 0x47, 0x2e,
	0x81, 0xfa, 0xa4, 0xd8, 0x12, 0xf4, 0xb3, 0x30, 0x6d, 0x59, 0x32, 0xed, 0x6d, 0x8b, 0xf2, 0x54,
	0xf6, 0x9d, 0x03, 0xcd, 0x50, 0xf4, 0xb1, 0x16, 0x6f, 0x27, 0xcc, 0xc8, 0xf9, 0x5e, 0xab, 0x7b,
	0x59, 0x62, 0x42, 0x45, 0xc4, 0x9f, 0x88, 0xb8, 0xcb, 0x45, 0x8e, 0x6d, 0xb5, 0xfb, 0x0c, 0x68,
	0x24, 0x77, 0x63, 0x94, 0xde, 0x38, 0xc0, 0x48, 0xac, 0x7b, 0xc9, 0x70, 0x9f, 0x05, 0x0d, 0xb4,
	0x9f, 0xad, 0xc5, 0x19, 0x6d, 0xfd, 0xa2, 0xce, 0x9b, 0x0b, 0x8e, 0xff, 0x53, 0x47, 0x1f, 0xf7,
	0x2b, 0x9a, 0xb0, 0xfb, 0x1c, 0x8f, 0x2e, 0x26, 0xde, 0x61, 0xe2, 0x8d, 0xee, 0x40, 0x30, 0x60,
	0xd1, 0xe4, 0xff, 0xc2, 0x11, 0x8b, 0x32, 0x48, 0xd2, 0xbb, 0x41, 0x1a, 0x52, 0x11, 0xea, 0x9b,
	0x67, 0x40, 0x83, 0xa0, 0x38, 0x44, 0x69, 0x09, 0x75, 0x25, 0x83, 0xb6, 0xa6, 0x68, 0xb8, 0xc7,
	0x5b, 0xf9, 0x2e, 0x29, 0x19, 0xd6, 0xdd, 0xa9, 0x21, 0x47, 0xe7, 0x28, 0xe4, 0xe8, 0x19, 0xfb,
	0xf7, 0x03, 0x9b, 0xa5, 0x53, 0x79, 0x53, 0x1d, 0xa9, 0xad, 0x8f, 0x44, 0x67, 0x37, 0x21, 0x28,
	0x94, 0x81, 0xa4, 0x64, 0x14, 0xb3, 0xeb, 0x49, 0x91, 0xbd, 0x0c, 0x5c, 0x66, 0xda, 0xeb, 0x28,
	0xcb, 0x53, 0x0e, 0xda, 0xf5, 0xff, 0xe4, 0x98, 0xec, 0xa9, 0x0c, 0x5e, 0x01, 0xf3, 0x13, 0x82,
	0x06, 0x39, 0x90, 0x70, 0x8b, 0x65, 0x16, 0x9d, 0x92, 0x20, 0xaf, 0x4f, 0xc6, 0xc2, 0xbb, 0x12,
	0x87, 0xf6, 0x10, 0x8c, 0x46, 0x03, 0x15, 0x8a, 0x64, 0x16, 0xed, 0x41, 0x90, 0xb4, 0x87, 0x55,
	0xde, 0x43, 0xc9, 0xf1, 0x43, 0x91, 0x57, 0xaf, 0x46, 0x24, 0x3b, 0x7c, 0x13, 0xb5, 0x01, 0xd8,
	0x42, 0x3b, 0x51, 0xbc, 0x16, 0x87, 0x68, 0x9f, 0xcd, 0x64, 0x06, 0x4a, 0x1c, 0x8a, 0x7b, 0x29,
	0xda, 0xbd, 0x94, 0x4c, 0xe2, 0x2c, 0xc7, 0xd1, 0x9c, 0xf6, 0xff, 0xee, 0xd8, 0x86, 0xf9, 0x52,
	0xab, 0x2c, 0x0f, 0x24, 0x71, 0x34, 0x33, 0x3b, 0x56, 0x33, 0x09, 0xe6, 0xda, 0x3d, 0x61, 0xa6,
	0xa0, 0x69, 0xe2, 0x88, 0xc8, 0x95, 0x38, 0x14, 0x7e, 0xe2, 0x44, 0xbe, 0xe5, 0xa8, 0xe9, 0xde,
	0x60, 0xa5, 0x6e, 0xd9, 0x72, 0xb4, 0xc9, 0xbf, 0x57, 0x03, 0xa7, 0xd8, 0x1c, 0x6f, 0x62, 0x3a,
	0xbb, 0x37, 0xa2, 0xec, 0xcb, 0x6e, 0x38, 0x39, 0xcb, 0xb4, 0x0f, 0xc9, 0x32, 0x1d, 0x2d, 0xcb,
	0x7c, 0x03, 0x34, 0xb7, 0x0e, 0x32, 0x44, 0x6e, 0x9f, 0x7b, 0x71, 0x4c, 0xab, 0x07, 0x1e, 0xd2,
	0xf3, 0x8c, 0xc7, 0x59, 0x66, 0x22, 0x5a, 0xb5, 0x25, 0x22, 0x6d, 0x77, 0x0f, 0x8e, 0xda, 0xdd,
	0xeb, 0xc6, 0xee, 0xfe, 0xa4, 0x26, 0x76, 0xb7, 0xec, 0x94, 0x5b, 0xbd, 0xc7, 0xd5, 0x2d, 0xcf,
	0x02, 0xc0, 0x45, 0xfa, 0xe4, 0x4e, 0x20, 0xaa, 0xae, 0x06, 0xe3, 0x50, 0x06, 0xdd, 0x14, 0x94,
	0x3f, 0x60, 0x7c, 0xfa, 0x69, 0xfa, 0x71, 0xfd, 0x18, 0x7e, 0xdc, 0x3c, 0xca, 0x8f, 0xa1, 0xe1,
	0xc7, 0x9f, 0x5b, 0xfd, 0xd8, 0x7f, 0x5c, 0xfd, 0x28, 0x1c, 0xb5, 0x7a, 0x88, 0xa3, 0x06, 0xc7,
	0x70, 0xd4, 0xfa, 0x51, 0x8e, 0xda, 0x34, 0x1c, 0xf5, 0x23, 0x73, 0x17, 0x4e, 0x05, 0x33, 0x67,
	0xc0, 0xdc, 0x84, 0xf5, 0xb0, 0x86, 0x45, 0xb1, 0x54, 0xd0, 0x0c, 0x95, 0xd9, 0xf7, 0x7a, 0x92,
	0x66, 0x05, 0x2a, 0x17, 0x1c, 0xd7, 0x07, 0x4d, 0x4e, 0x5d, 0x4e, 0xc6, 0x41, 0x14, 0x33, 0x07,
	0x35, 0xa0, 0xc2, 0x2b, 0xd2, 0xcd, 0xaa, 0x5a, 0x92, 0x70, 0x19, 0x5a, 0xa1, 0xf1, 0x20, 0x2b,
	0x19, 0x47, 0x6d, 0x35, 0x35, 0xbd, 0x6d, 0x6a, 0xe9, 0xcd, 0xff, 0xb1, 0x19, 0x40, 0x04, 0xdf,
	0xea, 0x3d, 0xf1, 0x4c, 0x85, 0x67, 0xfa, 0x4f, 0x3c, 0xe3, 0xff, 0xb2, 0x26, 0x7e, 0x3a, 0xb8,
	0x67, 0x1e, 0x52, 0x3a, 0x93, 0x0a, 0xee, 0x82, 0x56, 0xb0, 0xa8, 0x73, 0x08, 0x16, 0xf5, 0x8e,
	0xc0, 0xa2, 0xd5, 0x63, 0xa4, 0xba, 0x47, 0x84, 0x3c, 0x1f, 0xe7, 0xe7, 0x0a, 0x85, 0xb7, 0xbe,
	0xb6, 0x79, 0xee, 0xab, 0x72, 0xd9, 0x47, 0xa6, 0xcb, 0x9e, 0xa4, 0x34, 0xc3, 0x4b, 0x3f, 0xa9,
	0xab, 0xdb, 0xf0, 0x7f, 0xf0, 0x73, 0x54, 0xa0, 0x13, 0x0a, 0xa5, 0x1f, 0x0d, 0x85, 0xa7, 0xa0,
	0xdf, 0xaa, 0x86, 0x7e, 0x3a, 0xba, 0x0d, 0x2c, 0xe8, 0xa6, 0x22, 0xe4, 0xba, 0x81, 0x90, 0x39,
	0xfa, 0x6d, 0x56, 0xa1, 0x5f, 0xa8, 0xa3, 0xdf, 0x59, 0xd0, 0xda, 0x4a, 0x12, 0xb6, 0x14, 0x57,
	0xf6, 0x69, 0xf5, 0x1e, 0xaf, 0x38, 0x9d, 0x39, 0xa8, 0x32, 0xa9, 0xdd, 0x38, 0x18, 0xbe, 0xc5,
	0xe6, 0xb5, 0xcf, 0x61, 0x29, 0xa7, 0xdd, 0x6f, 0xe6, 0x76, 0x47, 0x98, 0x95, 0xff, 0xef, 0x38,
	0x2b, 0xf5, 0xd2, 0x70, 0xce, 0xf4, 0xff, 0x5a, 0x57, 0xa3, 0x78, 0xca, 0xbc, 0xfa, 0x64, 0x85,
	0x1e, 0xd5, 0x0a, 0xb9, 0xcf, 0x81, 0xd6, 0x9d, 0x2c, 0xc3, 0x64, 0x2f, 0xbd, 0x88, 0xa3, 0x5b,
	0x28, 0xf5, 0x7e, 0xe8, 0xb0, 0x6e, 0x54, 0xae, 0x7b, 0x8a, 0x6f, 0xf1, 0x77, 0x9d, 0x62, 0x8f,
	0xfb, 0x1f, 0x9a, 0x6b, 0xdb, 0x7f, 0xb2, 0xb6, 0x8f, 0xd3, 0xee, 0x7b, 0xdf, 0x01, 0xad, 0xcb,
	0x68, 0x74, 0x0d, 0x11, 0x12, 0xec, 0xe4, 0x67, 0x5c, 0x93, 0x28, 0xde, 0x60, 0x29, 0xc3, 0x73,
	0x84, 0x33, 0x73, 0x06, 0x3b, 0x74, 0x89, 0x62, 0x88, 0x86, 0x28, 0xda, 0x43, 0xa9, 0x57, 0x13,
	0x87, 0x2e, 0x25, 0x8b, 0x4e, 0x35, 0x8b, 0xc6, 0xf9, 0xda, 0xb2, 0x6f, 0xb6, 0xb0, 0x41, 0x1c,
	0x26, 0x63, 0x71, 0xf0, 0x21, 0x28, 0x77, 0x19, 0xcc, 0x10, 0xb4, 0x7b, 0x3d, 0x11, 0x05, 0x0d,
	0x27, 0xfc, 0x84, 0x99, 0x84, 0x32, 0x94, 0x1f, 0xbb, 0x99, 0xa7, 0x29, 0x1e, 0x98, 0xc5, 0x48,
	0xce, 0x62, 0x39, 0x49, 0x57, 0x22, 0x64, 0xca, 0x52, 0xa1, 0x24, 0x71, 0x8a, 0x95, 0xe8, 0x48,
	0x07, 0x55, 0x17, 0x95, 0x01, 0xa7, 0xba, 0x16, 0xf9, 0xb7, 0x03, 0x9a, 0xf2, 0xb9, 0x23, 0x4b,
	0x5c, 0x82, 0xa6, 0xeb, 0x0b, 0x78, 0x4a, 0x94, 0x58, 0xcc, 0xd2, 0x5c, 0x03, 0x8b, 0xee, 0x24,
	0x8e, 0xfb, 0x3c, 0x58, 0xc8, 0x29, 0x11, 0x79, 0xbc, 0x2a, 0xd6, 0xb8, 0x74, 0x46, 0xb8, 0xac,
	0x8a, 0xd9, 0xb7, 0x3c, 0xfa, 0xcd, 0x74, 0x24, 0xea, 0x3e, 0x99, 0x25, 0xf7, 0x2e, 0xe2, 0x63,
	0x95, 0x85, 0x87, 0xc6, 0xa5, 0x13, 0x1e, 0x26, 0xc9, 0x5b, 0x11, 0x12, 0x71, 0x2f, 0x28, 0xff,
	0x65, 0xb0, 0x98, 0xcf, 0x77, 0x63, 0x32, 0x1c, 0x1e, 0xff, 0xbc, 0xfb, 0xb6, 0xa6, 0x38, 0xed,
	0xff, 0x25, 0xb5, 0x73, 0x23, 0x0b, 0x8a, 0xd3, 0xb2, 0x9c, 0xf6, 0xff, 0x5c, 0x07, 0xcd, 0x2b,
	0xfb, 0x19, 0x8a, 0x49, 0x94, 0xc4, 0xd4, 0xae, 0x05, 0x50, 0x8b, 0x42, 0x11, 0xca, 0xb5, 0x28,
	0x64, 0x11, 0x4a, 0x83, 0x83, 0x07, 0x2f, 0xfb, 0x66, 0x0e, 0x23, 0xd9, 0xfa, 0x9d, 0x24, 0x46,
	0xf1, 0x64, 0xec, 0xd5, 0x85, 0xc3, 0x4a, 0x96, 0xfb, 0x02, 0x58, 0xc2, 0xf4, 0xfb, 0x52, 0x12,
	0xef, 0xa1, 0x34, 0x63, 0xe1, 0x75, 0x82, 0x0d, 0x6d, 0xf0, 0x59, 0xb5, 0x13, 0xed, 0x88, 0x69,
	0xd3, 0x4f, 0x36, 0xc5, 0x64, 0x92, 0xa1, 0xb5, 0x50, 0x1c, 0x4f, 0xe4, 0xa4, 0x7b, 0x01, 0xb4,
	0x42, 0x79, 0x03, 0x7a, 0x5f, 0xfc, 0x7a, 0x86, 0x9d, 0x4c, 0x2f, 0x74, 0x95, 0x8d, 0x09, 0x55,
	0x31, 0xf7, 0x05, 0xb0, 0x28, 0xad, 0x27, 0x33, 0xe7, 0xf3, 0xdf, 0xcc, 0x30, 0x83, 0xf4, 0x06,
	0xb7, 0x0d, 0x1a, 0x38, 0xcb, 0x06, 0x49, 0x3a, 0x0e, 0x32, 0xef, 0x57, 0xbf, 0xe5, 0x52, 0x25,
	0xcb, 0x7d, 0x1e, 0xb4, 0x22, 0x72, 0x1d, 0xa1, 0x70, 0x2d, 0x8e, 0x51, 0xba, 0x86, 0xbd, 0x9f,
	0xfd, 0x8e, 0xcb, 0xa8, 0x6c, 0xf7, 0x0c, 0x98, 0x8d, 0x11, 0x9f, 0xfa, 0x0f, 0x7e, 0xcf, 0x25,
	0x72, 0x06, 0x1d, 0x63, 0x2f, 0x89, 0x86, 0x7c, 0xdf, 0xfd, 0x53, 0xb4, 0x96, 0x2c, 0xf7, 0x19,
	0xe9, 0xff, 0xe5, 0xd3, 0x3f, 0xcc, 0x18, 0x7f, 0x30, 0xb3, 0x38, 0xcb, 0x6e, 0x50, 0xe0, 0xf8,
	0xf8, 0x13, 0xd1, 0xb3, 0x60, 0xf8, 0x0b, 0xf2, 0x7a, 0x12, 0xec, 0xdf, 0xab, 0x83, 0xb9, 0xfc,
	0x04, 0x31, 0x0f, 0x3a, 0x47, 0x39, 0x69, 0xe5, 0xf5, 0xe1, 0x15, 0x5a, 0x31, 0xd6, 0x04, 0x02,
	0x14, 0x1c, 0xa5, 0xca, 0xad, 0x9b, 0x55, 0xee, 0x28, 0xda, 0x46, 0xcc, 0x0e, 0xbe, 0xb8, 0x05,
	0x5d, 0x62, 0x3c, 0x6b, 0x9d, 0x91, 0x31, 0x9e, 0xb5, 0xe7, 0xc1, 0x7e, 0x52, 0xc2, 0x78, 0xb9,
	0x6a, 0x9e, 0x35, 0xaf, 0x0d, 0x83, 0x2d, 0x32, 0xc8, 0x7d, 0x22, 0x8e, 0xb5, 0x24, 0x96, 0x51,
	0x57, 0x87, 0x95, 0x75, 0x35, 0x2a, 0xeb, 0xea, 0x36, 0x00, 0xc3, 0x51, 0x84, 0x62, 0xbe, 0x4c,
	0x31, 0x37, 0xb3, 0xe4, 0x50, 0x93, 0xd8, 0x45, 0x0d, 0xc5, 0xce, 0x7d, 0x3e, 0xfd, 0x9c, 0x96,
	0x61, 0xf5, 0x40, 0x85, 0xd5, 0xff, 0x07, 0x00, 0xed, 0xe3, 0x28, 0xe5, 0xae, 0x79, 0x87, 0x17,
	0x00, 0x12, 0xcb, 0x3f, 0x0f, 0x9a, 0xd4, 0xee, 0xef, 0x4e, 0x50, 0x7a, 0x70, 0x7c, 0x30, 0xd8,
	0x91, 0xb5, 0xa6, 0x42, 0x02, 0xf9, 0x46, 0xa7, 0x5d, 0x7d, 0xa3, 0xf3, 0x12, 0x68, 0x41, 0x34,
	0x14, 0x27, 0xf7, 0x92, 0x7d, 0x8e, 0x69, 0x5f, 0x4d, 0xcd, 0x0c, 0x92, 0x9a, 0x6a, 0xa0, 0x53,
	0x65, 0x60, 0x4d, 0xc9, 0x0c, 0xdf, 0x07, 0x4b, 0x10, 0x0d, 0xf7, 0x28, 0x98, 0xea, 0xce, 0x71,
	0xaa, 0xae, 0x07, 0x6a, 0x87, 0x5e, 0x0f, 0xd4, 0xb5, 0xeb, 0x81, 0x7f, 0x39, 0xfa, 0x10, 0xd3,
	0x18, 0x4a, 0xeb, 0x1c, 0xb6, 0x1d, 0x93, 0x4c, 0x1e, 0x46, 0xe1, 0x69, 0x66, 0x9e, 0x30, 0xcc,
	0xf4, 0x41, 0x33, 0x25, 0x98, 0x3a, 0x8b, 0xf7, 0xc1, 0x77, 0x89, 0xc2, 0x2b, 0xaf, 0x09, 0x4e,
	0x56, 0x5d, 0x13, 0xcc, 0x56, 0x5f, 0x13, 0x5c, 0x05, 0x4d, 0x88, 0x62, 0x74, 0xf7, 0xbf, 0x5a,
	0x46, 0x3a, 0xe5, 0x20, 0x0c, 0x6f, 0x64, 0x23, 0x31, 0x29, 0x41, 0xf9, 0xaf, 0xca, 0xbd, 0x4d,
	0xb5, 0xba, 0x9f, 0xce, 0x83, 0xf9, 0x4b, 0xfd, 0xf3, 0x17, 0x20, 0xda, 0x7d, 0x2d, 0x09, 0x0f,
	0xa8, 0x3d, 0xc3, 0x71, 0x28, 0xb4, 0xe9, 0x27, 0xdb, 0xa1, 0x68, 0x57, 0x2c, 0x29, 0xfd, 0x74,
	0xbf, 0x03, 0x96, 0x52, 0x2d, 0x22, 0x98, 0x5d, 0xf3, 0xbd, 0x53, 0x5d, 0x3d, 0x54, 0xa0, 0x21,
	0x4a, 0xd5, 0xe9, 0x0f, 0xbd, 0xa2, 0x7e, 0x42, 0xa8, 0x6f, 0x68, 0x0d, 0xd0, 0x10, 0x75, 0xcf,
	0x81, 0x66, 0x2a, 0x79, 0xd0, 0x9b, 0x11, 0xb7, 0xa6, 0xb2, 0x5b, 0xa1, 0x22, 0xe2, 0x9e, 0x07,
	0xad, 0x54, 0xde, 0x3c, 0x6c, 0xe5, 0x68, 0x82, 0x52, 0xb6, 0x14, 0x54, 0x85, 0xdc, 0x97, 0xc1,
	0x42, 0xa0, 0x9c, 0x4e, 0x30, 0x04, 0x9c, 0xef, 0x2d, 0x76, 0xd5, 0x43, 0x0b, 0xa8, 0x89, 0xb9,
	0xaf, 0x82, 0x53, 0x81, 0x7e, 0x58, 0xef, 0xcd, 0x31, 0x5d, 0xb7, 0x6b, 0x1c, 0xe3, 0x43, 0x53,
	0xd8, 0x1d, 0x80, 0xd3, 0x81, 0x79, 0x7d, 0xeb, 0x35, 0x58, 0x1f, 0xcb, 0x5d, 0xcb, 0xd5, 0x2e,
	0xb4, 0x29, 0xd0, 0x89, 0x73, 0x80, 0x17, 0x25, 0x0e, 0x03, 0x25, 0x3a, 0xf1, 0x9b, 0x32, 0x17,
	0xaa, 0x42, 0x54, 0x2b, 0x94, 0xeb, 0x57, 0x6f, 0xbe, 0xcc, 0xe7, 0x25, 0x17, 0xaa, 0x42, 0xee,
	0xb7, 0xcb, 0x7c, 0x9e, 0x8f, 0xd6, 0x64, 0x7a, 0x4b, 0x5d, 0xad, 0xd0, 0x82, 0xba, 0x60, 0x31,
	0x5f, 0xf5, 0x01, 0x82, 0xd7, 0x92, 0xe7, 0xab, 0xb6, 0x41, 0x9b, 0x02, 0x0d, 0xad, 0x40, 0x7b,
	0x0f, 0xe0, 0x2d, 0x88, 0xd0, 0xd2, 0x1f, 0x0a, 0x40, 0x43, 0xd4, 0x5d, 0x03, 0xcb, 0x81, 0xe5,
	0x36, 0xd4, 0x5b, 0x64, 0x5d, 0x3c, 0xdd, 0xb5, 0x5d, 0x95, 0x42, 0xab, 0x0a, 0x8d, 0xd2, 0x6d,
	0x29, 0x9d, 0x78, 0x4b, 0x22, 0x4a, 0xe5, 0x1c, 0x03, 0x15, 0x91, 0xc2, 0x78, 0xe9, 0x61, 0x92,
	0x77, 0x4a, 0x36, 0x5e, 0x6a, 0x80, 0x86, 0x68, 0xa1, 0x2e, 0x9d, 0x3f, 0x7a, 0xae, 0xac, 0x2e,
	0x35, 0x40, 0x43, 0xd4, 0xa2, 0xde, 0xf7, 0x4e, 0xdb, 0xd5, 0xfb, 0x86, 0x7a, 0xbf, 0x58, 0x41,
	0xf5, 0xa2, 0x8f, 0xe5, 0xba, 0x62, 0x05, 0xd5, 0x36, 0x68, 0x53, 0xb0, 0xf7, 0xd3, 0xf7, 0x9e,
	0xae, 0xec, 0xa7, 0x6f, 0xeb, 0xa7, 0xcf, 0x80, 0x7e, 0x42, 0xa2, 0x18, 0x11, 0xb2, 0x16, 0xb2,
	0xf2, 0x82, 0x02, 0x7d, 0xc1, 0xd1, 0xaa, 0x8c, 0x6d, 0xa3, 0xca, 0xf8, 0x96, 0xd8, 0xfc, 0xc5,
	0xb3, 0x22, 0xef, 0x3d, 0x51, 0xd6, 0x2e, 0x76, 0xd5, 0xf7, 0x46, 0x50, 0x13, 0x74, 0xaf, 0x00,
	0x37, 0x30, 0x9e, 0x0d, 0x78, 0xf7, 0x84, 0xfa, 0xe9, 0xae, 0xf9, 0xa6, 0x00, 0x5a, 0x14, 0xdc,
	0x3e, 0x68, 0x22, 0xe9, 0x2f, 0xc0, 0xfb, 0xf0, 0xdd, 0x93, 0x22, 0x86, 0xe4, 0x9f, 0x03, 0xa8,
	0x08, 0xf9, 0x1f, 0x34, 0x05, 0x9c, 0x13, 0x3c, 0x3d, 0x9c, 0x13, 0x5c, 0x01, 0xe7, 0x04, 0x43,
	0x43, 0xd4, 0x84, 0x73, 0x82, 0x2b, 0xe0, 0x9c, 0xaa, 0xeb, 0xa2, 0x2a, 0x9c, 0x13, 0x6c, 0x81,
	0x73, 0x82, 0xa1, 0x22, 0xa2, 0xc1, 0x39, 0xc1, 0x36, 0x38, 0x27, 0x18, 0xaa, 0x42, 0x3a, 0x9c,
	0x13, 0x6c, 0x85, 0x73, 0x82, 0xa1, 0x26, 0x66, 0x81, 0x73, 0x82, 0xab, 0xe0, 0x9c, 0x60, 0x68,
	0x0a, 0x5b, 0xe1, 0x9c, 0xe0, 0x6a, 0x38, 0x27, 0x18, 0xda, 0x14, 0x34, 0x38, 0x27, 0xd8, 0x06,
	0xe7, 0x74, 0xe2, 0x8a, 0x90, 0x06, 0xe7, 0x04, 0xdb, 0xe0, 0x9c, 0x6a, 0x29, 0x42, 0x06, 0x9c,
	0x13, 0x6c, 0x87, 0x73, 0x82, 0xa1, 0x2e, 0x68, 0x85, 0x73, 0x82, 0xab, 0xe1, 0xbc, 0x98, 0xaf,
	0xf6, 0x86, 0xcc, 0x80, 0x73, 0x82, 0x2b, 0xe0, 0x9c, 0x86, 0x96, 0x2e, 0x6a, 0x87, 0x73, 0x82,
	0x0f, 0x81, 0x73, 0x82, 0xa1, 0x55, 0x45, 0x85, 0x73, 0x82, 0x2d, 0x70, 0x4e, 0xa3, 0x54, 0x16,
	0x31, 0xe1, 0x9c, 0xe0, 0x0a, 0x38, 0x2f, 0x8c, 0x97, 0x9f, 0x4f, 0x6a, 0x78, 0x4c, 0x70, 0x05,
	0x9c, 0xd3, 0x06, 0x68, 0x88, 0x5a, 0xd4, 0xed, 0x70, 0x4e, 0x1b, 0x0c, 0x75, 0x1b, 0x9c, 0x33,
	0x03, 0x2a, 0xe0, 0x9c, 0xd9, 0x60, 0x53, 0xb0, 0xf7, 0x53, 0x09, 0xe7, 0xcc, 0x18, 0x9b, 0xc2,
	0xc3, 0x86, 0x73, 0x82, 0x2b, 0xe0, 0xbc, 0xd8, 0xfe, 0xe5, 0x43, 0xcb, 0x37, 0x45, 0x14, 0x69,
	0x4f, 0x8f, 0xbd, 0xf7, 0x45, 0x07, 0x22, 0x8e, 0xb4, 0x66, 0x68, 0x55, 0xb2, 0xe5, 0x06, 0x82,
	0x0f, 0xc9, 0x0d, 0x04, 0x43, 0x8b, 0x82, 0x9a, 0x1b, 0x08, 0xb6, 0xe6, 0x06, 0x1a, 0x90, 0xb2,
	0x10, 0xfd, 0x91, 0xd3, 0xcb, 0xeb, 0x87, 0xfc, 0x23, 0xf7, 0x51, 0x4d, 0x1f, 0xe2, 0x6b, 0xf8,
	0x23, 0x77, 0x06, 0xcc, 0x65, 0x49, 0x76, 0x35, 0x1a, 0x47, 0x19, 0xcb, 0x10, 0x75, 0x58, 0xd0,
	0xf9, 0x41, 0x3d, 0x6f, 0x9c, 0x2b, 0x0f, 0xea, 0x79, 0xab, 0xfc, 0x0b, 0xd8, 0xa8, 0xfe, 0x05,
	0xbc, 0x0d, 0x5a, 0x4a, 0xf9, 0xfd, 0xb0, 0x5f, 0x65, 0xfa, 0x77, 0x94, 0x01, 0x1e, 0xe1, 0xa9,
	0xc4, 0x6b, 0x67, 0xff, 0x78, 0xbf, 0xed, 0x7c, 0x76, 0xbf, 0xed, 0xfc, 0xed, 0x7e, 0xdb, 0x79,
	0xef, 0x41, 0xfb, 0xa9, 0xcf, 0x1e, 0xb4, 0x9f, 0xfa, 0xfc, 0x41, 0xfb, 0xa9, 0x4d, 0xd0, 0x7d,
	0x25, 0x7f, 0xc2, 0xbf, 0x75, 0x92, 0xbd, 0xe1, 0xef, 0xff, 0x27, 0x00, 0x00, 0xff, 0xff, 0xd7,
	0x53, 0xaa, 0xd9, 0xd5, 0x2f, 0x00, 0x00,
}

func (m *ApplyCleanTrafficRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyCleanTrafficRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplyCleanTrafficRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RetMsg) > 0 {
		i -= len(m.RetMsg)
		copy(dAtA[i:], m.RetMsg)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.RetMsg)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.RetCode != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.RetCode))
		i--
		dAtA[i] = 0x50
	}
	return len(dAtA) - i, nil
}

func (m *ApplyCopyFromReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyCopyFromReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplyCopyFromReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalSpace != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.TotalSpace))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xf0
	}
	if m.DangerLevel != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.DangerLevel))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if len(m.FileName) > 0 {
		i -= len(m.FileName)
		copy(dAtA[i:], m.FileName)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.FileName)))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xd2
	}
	if m.FileSize != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.FileSize))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x80
	}
	if m.DstUin != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.DstUin))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb0
	}
	if len(m.FileMd5) > 0 {
		i -= len(m.FileMd5)
		copy(dAtA[i:], m.FileMd5)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.FileMd5)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe2
	}
	if len(m.SrcUuid) > 0 {
		i -= len(m.SrcUuid)
		copy(dAtA[i:], m.SrcUuid)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.SrcUuid)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	if len(m.SrcParentfolder) > 0 {
		i -= len(m.SrcParentfolder)
		copy(dAtA[i:], m.SrcParentfolder)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.SrcParentfolder)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	if m.SrcSvcid != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.SrcSvcid))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.SrcGroup != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.SrcGroup))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.SrcUin != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.SrcUin))
		i--
		dAtA[i] = 0x50
	}
	return len(dAtA) - i, nil
}

func (m *ApplyCopyFromRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyCopyFromRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplyCopyFromRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalSpace != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.TotalSpace))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if len(m.RetMsg) > 0 {
		i -= len(m.RetMsg)
		copy(dAtA[i:], m.RetMsg)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.RetMsg)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.RetCode != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.RetCode))
		i--
		dAtA[i] = 0x50
	}
	return len(dAtA) - i, nil
}

func (m *ApplyCopyToReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyCopyToReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplyCopyToReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x82
	}
	if len(m.LocalFilepath) > 0 {
		i -= len(m.LocalFilepath)
		copy(dAtA[i:], m.LocalFilepath)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.LocalFilepath)))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb2
	}
	if len(m.FileName) > 0 {
		i -= len(m.FileName)
		copy(dAtA[i:], m.FileName)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.FileName)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe2
	}
	if m.FileSize != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.FileSize))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x90
	}
	if m.SrcUin != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.SrcUin))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if m.DstSvcid != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.DstSvcid))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.DstUin != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.DstUin))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.DstId != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.DstId))
		i--
		dAtA[i] = 0x50
	}
	return len(dAtA) - i, nil
}

func (m *ApplyCopyToRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyCopyToRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplyCopyToRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FileKey) > 0 {
		i -= len(m.FileKey)
		copy(dAtA[i:], m.FileKey)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.FileKey)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if len(m.RetMsg) > 0 {
		i -= len(m.RetMsg)
		copy(dAtA[i:], m.RetMsg)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.RetMsg)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.RetCode != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.RetCode))
		i--
		dAtA[i] = 0x50
	}
	return len(dAtA) - i, nil
}

func (m *ApplyDownloadAbsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyDownloadAbsReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplyDownloadAbsReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.Uin != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.Uin))
		i--
		dAtA[i] = 0x50
	}
	return len(dAtA) - i, nil
}

func (m *ApplyDownloadAbsRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyDownloadAbsRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplyDownloadAbsRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DownloadInfo != nil {
		{
			size, err := m.DownloadInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if len(m.RetMsg) > 0 {
		i -= len(m.RetMsg)
		copy(dAtA[i:], m.RetMsg)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.RetMsg)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.RetCode != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.RetCode))
		i--
		dAtA[i] = 0x50
	}
	return len(dAtA) - i, nil
}

func (m *ApplyDownloadReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyDownloadReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplyDownloadReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExtIntype != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.ExtIntype))
		i--
		dAtA[i] = 0x1f
		i--
		dAtA[i] = 0xa0
	}
	if m.OwnerType != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.OwnerType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.Uin != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.Uin))
		i--
		dAtA[i] = 0x50
	}
	return len(dAtA) - i, nil
}

func (m *ApplyDownloadRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyDownloadRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplyDownloadRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FileInfo != nil {
		{
			size, err := m.FileInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	if m.DownloadInfo != nil {
		{
			size, err := m.DownloadInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if len(m.RetMsg) > 0 {
		i -= len(m.RetMsg)
		copy(dAtA[i:], m.RetMsg)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.RetMsg)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.RetCode != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.RetCode))
		i--
		dAtA[i] = 0x50
	}
	return len(dAtA) - i, nil
}

func (m *ApplyForwardFileReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyForwardFileReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplyForwardFileReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalSpace != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.TotalSpace))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x90
	}
	if m.DangerLevel != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.DangerLevel))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.RecverUin != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.RecverUin))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.SenderUin != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.SenderUin))
		i--
		dAtA[i] = 0x50
	}
	return len(dAtA) - i, nil
}

func (m *ApplyForwardFileRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyForwardFileRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplyForwardFileRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	if m.UsedSpace != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.UsedSpace))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if m.TotalSpace != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.TotalSpace))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if len(m.RetMsg) > 0 {
		i -= len(m.RetMsg)
		copy(dAtA[i:], m.RetMsg)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.RetMsg)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.RetCode != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.RetCode))
		i--
		dAtA[i] = 0x50
	}
	return len(dAtA) - i, nil
}

func (m *ApplyGetTrafficReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyGetTrafficReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplyGetTrafficReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ApplyGetTrafficRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyGetTrafficRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplyGetTrafficRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AllFileNum != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.AllFileNum))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe0
	}
	if m.AllFileSize != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.AllFileSize))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x90
	}
	if m.UseFileNum != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.UseFileNum))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if m.UseFileSize != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.UseFileSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if len(m.RetMsg) > 0 {
		i -= len(m.RetMsg)
		copy(dAtA[i:], m.RetMsg)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.RetMsg)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.RetCode != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.RetCode))
		i--
		dAtA[i] = 0x50
	}
	return len(dAtA) - i, nil
}

func (m *ApplyListDownloadReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyListDownloadReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplyListDownloadReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReqCount != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.ReqCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.BeginIndex != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.BeginIndex))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.Uin != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.Uin))
		i--
		dAtA[i] = 0x50
	}
	return len(dAtA) - i, nil
}

func (m *ApplyListDownloadRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyListDownloadRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplyListDownloadRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FileList) > 0 {
		for iNdEx := len(m.FileList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FileList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCmd0X346(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0xb2
		}
	}
	if m.IsEnd != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.IsEnd))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe0
	}
	if m.RspCount != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.RspCount))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x90
	}
	if m.BeginIndex != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.BeginIndex))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if m.TotalCount != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.TotalCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if len(m.RetMsg) > 0 {
		i -= len(m.RetMsg)
		copy(dAtA[i:], m.RetMsg)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.RetMsg)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.RetCode != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.RetCode))
		i--
		dAtA[i] = 0x50
	}
	return len(dAtA) - i, nil
}

func (m *ApplyUploadHitReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyUploadHitReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplyUploadHitReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalSpace != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.TotalSpace))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x80
	}
	if m.DangerLevel != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.DangerLevel))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb0
	}
	if len(m.LocalFilepath) > 0 {
		i -= len(m.LocalFilepath)
		copy(dAtA[i:], m.LocalFilepath)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.LocalFilepath)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe2
	}
	if len(m.Bytes_10MMd5) > 0 {
		i -= len(m.Bytes_10MMd5)
		copy(dAtA[i:], m.Bytes_10MMd5)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.Bytes_10MMd5)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	if len(m.FileName) > 0 {
		i -= len(m.FileName)
		copy(dAtA[i:], m.FileName)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.FileName)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	if m.FileSize != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.FileSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.RecverUin != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.RecverUin))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.SenderUin != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.SenderUin))
		i--
		dAtA[i] = 0x50
	}
	return len(dAtA) - i, nil
}

func (m *ApplyUploadHitReqV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyUploadHitReqV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplyUploadHitReqV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalSpace != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.TotalSpace))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.DangerLevel != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.DangerLevel))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xd0
	}
	if len(m.LocalFilepath) > 0 {
		i -= len(m.LocalFilepath)
		copy(dAtA[i:], m.LocalFilepath)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.LocalFilepath)))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x82
	}
	if len(m.Sha) > 0 {
		i -= len(m.Sha)
		copy(dAtA[i:], m.Sha)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.Sha)))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb2
	}
	if len(m.Bytes_3Sha) > 0 {
		i -= len(m.Bytes_3Sha)
		copy(dAtA[i:], m.Bytes_3Sha)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.Bytes_3Sha)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe2
	}
	if len(m.Bytes_10MMd5) > 0 {
		i -= len(m.Bytes_10MMd5)
		copy(dAtA[i:], m.Bytes_10MMd5)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.Bytes_10MMd5)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	if len(m.FileName) > 0 {
		i -= len(m.FileName)
		copy(dAtA[i:], m.FileName)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.FileName)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	if m.FileSize != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.FileSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.RecverUin != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.RecverUin))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.SenderUin != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.SenderUin))
		i--
		dAtA[i] = 0x50
	}
	return len(dAtA) - i, nil
}

func (m *ApplyUploadHitReqV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyUploadHitReqV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplyUploadHitReqV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalSpace != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.TotalSpace))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xd0
	}
	if m.DangerLevel != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.DangerLevel))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x80
	}
	if len(m.LocalFilepath) > 0 {
		i -= len(m.LocalFilepath)
		copy(dAtA[i:], m.LocalFilepath)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.LocalFilepath)))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb2
	}
	if len(m.Sha) > 0 {
		i -= len(m.Sha)
		copy(dAtA[i:], m.Sha)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.Sha)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe2
	}
	if len(m.Bytes_10MMd5) > 0 {
		i -= len(m.Bytes_10MMd5)
		copy(dAtA[i:], m.Bytes_10MMd5)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.Bytes_10MMd5)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	if len(m.FileName) > 0 {
		i -= len(m.FileName)
		copy(dAtA[i:], m.FileName)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.FileName)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	if m.FileSize != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.FileSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.RecverUin != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.RecverUin))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.SenderUin != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.SenderUin))
		i--
		dAtA[i] = 0x50
	}
	return len(dAtA) - i, nil
}

func (m *ApplyUploadHitRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyUploadHitRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplyUploadHitRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UsedSpace != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.UsedSpace))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xd0
	}
	if m.TotalSpace != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.TotalSpace))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x80
	}
	if len(m.UploadKey) > 0 {
		i -= len(m.UploadKey)
		copy(dAtA[i:], m.UploadKey)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.UploadKey)))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb2
	}
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe2
	}
	if len(m.UploadDomain) > 0 {
		i -= len(m.UploadDomain)
		copy(dAtA[i:], m.UploadDomain)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.UploadDomain)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	if m.UploadPort != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.UploadPort))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if len(m.UploadIp) > 0 {
		i -= len(m.UploadIp)
		copy(dAtA[i:], m.UploadIp)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.UploadIp)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if len(m.RetMsg) > 0 {
		i -= len(m.RetMsg)
		copy(dAtA[i:], m.RetMsg)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.RetMsg)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.RetCode != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.RetCode))
		i--
		dAtA[i] = 0x50
	}
	return len(dAtA) - i, nil
}

func (m *ApplyUploadHitRspV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyUploadHitRspV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplyUploadHitRspV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UsedSpace != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.UsedSpace))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xd0
	}
	if m.TotalSpace != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.TotalSpace))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x80
	}
	if len(m.UploadKey) > 0 {
		i -= len(m.UploadKey)
		copy(dAtA[i:], m.UploadKey)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.UploadKey)))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb2
	}
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe2
	}
	if len(m.UploadDomain) > 0 {
		i -= len(m.UploadDomain)
		copy(dAtA[i:], m.UploadDomain)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.UploadDomain)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	if m.UploadPort != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.UploadPort))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if len(m.UploadIp) > 0 {
		i -= len(m.UploadIp)
		copy(dAtA[i:], m.UploadIp)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.UploadIp)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if len(m.RetMsg) > 0 {
		i -= len(m.RetMsg)
		copy(dAtA[i:], m.RetMsg)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.RetMsg)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.RetCode != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.RetCode))
		i--
		dAtA[i] = 0x50
	}
	return len(dAtA) - i, nil
}

func (m *ApplyUploadHitRspV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyUploadHitRspV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplyUploadHitRspV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UsedSpace != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.UsedSpace))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xd0
	}
	if m.TotalSpace != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.TotalSpace))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x80
	}
	if len(m.UploadKey) > 0 {
		i -= len(m.UploadKey)
		copy(dAtA[i:], m.UploadKey)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.UploadKey)))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb2
	}
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe2
	}
	if len(m.UploadDomain) > 0 {
		i -= len(m.UploadDomain)
		copy(dAtA[i:], m.UploadDomain)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.UploadDomain)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	if m.UploadPort != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.UploadPort))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if len(m.UploadIp) > 0 {
		i -= len(m.UploadIp)
		copy(dAtA[i:], m.UploadIp)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.UploadIp)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if len(m.RetMsg) > 0 {
		i -= len(m.RetMsg)
		copy(dAtA[i:], m.RetMsg)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.RetMsg)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.RetCode != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.RetCode))
		i--
		dAtA[i] = 0x50
	}
	return len(dAtA) - i, nil
}

func (m *ApplyUploadReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyUploadReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplyUploadReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalSpace != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.TotalSpace))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xd0
	}
	if m.DangerLevel != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.DangerLevel))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x80
	}
	if len(m.LocalFilepath) > 0 {
		i -= len(m.LocalFilepath)
		copy(dAtA[i:], m.LocalFilepath)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.LocalFilepath)))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb2
	}
	if len(m.Bytes_10MMd5) > 0 {
		i -= len(m.Bytes_10MMd5)
		copy(dAtA[i:], m.Bytes_10MMd5)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.Bytes_10MMd5)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe2
	}
	if len(m.FileName) > 0 {
		i -= len(m.FileName)
		copy(dAtA[i:], m.FileName)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.FileName)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	if m.FileSize != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.FileSize))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if m.FileType != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.FileType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.RecverUin != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.RecverUin))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.SenderUin != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.SenderUin))
		i--
		dAtA[i] = 0x50
	}
	return len(dAtA) - i, nil
}

func (m *ApplyUploadReqV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyUploadReqV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplyUploadReqV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalSpace != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.TotalSpace))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xd0
	}
	if m.DangerLevel != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.DangerLevel))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x80
	}
	if len(m.LocalFilepath) > 0 {
		i -= len(m.LocalFilepath)
		copy(dAtA[i:], m.LocalFilepath)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.LocalFilepath)))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb2
	}
	if len(m.Bytes_3Sha) > 0 {
		i -= len(m.Bytes_3Sha)
		copy(dAtA[i:], m.Bytes_3Sha)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.Bytes_3Sha)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe2
	}
	if len(m.Bytes_10MMd5) > 0 {
		i -= len(m.Bytes_10MMd5)
		copy(dAtA[i:], m.Bytes_10MMd5)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.Bytes_10MMd5)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	if len(m.FileName) > 0 {
		i -= len(m.FileName)
		copy(dAtA[i:], m.FileName)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.FileName)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	if m.FileSize != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.FileSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.RecverUin != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.RecverUin))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.SenderUin != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.SenderUin))
		i--
		dAtA[i] = 0x50
	}
	return len(dAtA) - i, nil
}

func (m *ApplyUploadReqV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyUploadReqV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplyUploadReqV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalSpace != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.TotalSpace))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xd0
	}
	if m.DangerLevel != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.DangerLevel))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x80
	}
	if len(m.LocalFilepath) > 0 {
		i -= len(m.LocalFilepath)
		copy(dAtA[i:], m.LocalFilepath)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.LocalFilepath)))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb2
	}
	if len(m.Sha) > 0 {
		i -= len(m.Sha)
		copy(dAtA[i:], m.Sha)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.Sha)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe2
	}
	if len(m.Bytes_10MMd5) > 0 {
		i -= len(m.Bytes_10MMd5)
		copy(dAtA[i:], m.Bytes_10MMd5)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.Bytes_10MMd5)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	if len(m.FileName) > 0 {
		i -= len(m.FileName)
		copy(dAtA[i:], m.FileName)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.FileName)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	if m.FileSize != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.FileSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.RecverUin != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.RecverUin))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.SenderUin != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.SenderUin))
		i--
		dAtA[i] = 0x50
	}
	return len(dAtA) - i, nil
}

func (m *ApplyUploadRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyUploadRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplyUploadRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UploadipList) > 0 {
		for iNdEx := len(m.UploadipList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.UploadipList[iNdEx])
			copy(dAtA[i:], m.UploadipList[iNdEx])
			i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.UploadipList[iNdEx])))
			i--
			dAtA[i] = 0x8
			i--
			dAtA[i] = 0x92
		}
	}
	if m.PackSize != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.PackSize))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xc0
	}
	if m.BoolFileExist {
		i--
		if m.BoolFileExist {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xf0
	}
	if len(m.UploadKey) > 0 {
		i -= len(m.UploadKey)
		copy(dAtA[i:], m.UploadKey)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.UploadKey)))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa2
	}
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xd2
	}
	if m.UploadPort != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.UploadPort))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x80
	}
	if len(m.UploadDomain) > 0 {
		i -= len(m.UploadDomain)
		copy(dAtA[i:], m.UploadDomain)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.UploadDomain)))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb2
	}
	if len(m.UploadIp) > 0 {
		i -= len(m.UploadIp)
		copy(dAtA[i:], m.UploadIp)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.UploadIp)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe2
	}
	if m.UploadedSize != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.UploadedSize))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x90
	}
	if m.UsedSpace != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.UsedSpace))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if m.TotalSpace != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.TotalSpace))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if len(m.RetMsg) > 0 {
		i -= len(m.RetMsg)
		copy(dAtA[i:], m.RetMsg)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.RetMsg)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.RetCode != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.RetCode))
		i--
		dAtA[i] = 0x50
	}
	return len(dAtA) - i, nil
}

func (m *ApplyUploadRspV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyUploadRspV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplyUploadRspV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sha) > 0 {
		i -= len(m.Sha)
		copy(dAtA[i:], m.Sha)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.Sha)))
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xea
	}
	if m.HttpsvrApiVer != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.HttpsvrApiVer))
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xe0
	}
	if len(m.UploadipList) > 0 {
		for iNdEx := len(m.UploadipList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.UploadipList[iNdEx])
			copy(dAtA[i:], m.UploadipList[iNdEx])
			i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.UploadipList[iNdEx])))
			i--
			dAtA[i] = 0x8
			i--
			dAtA[i] = 0x92
		}
	}
	if m.PackSize != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.PackSize))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xc0
	}
	if m.BoolFileExist {
		i--
		if m.BoolFileExist {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xf0
	}
	if len(m.UploadKey) > 0 {
		i -= len(m.UploadKey)
		copy(dAtA[i:], m.UploadKey)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.UploadKey)))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa2
	}
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xd2
	}
	if m.UploadPort != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.UploadPort))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x80
	}
	if len(m.UploadDomain) > 0 {
		i -= len(m.UploadDomain)
		copy(dAtA[i:], m.UploadDomain)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.UploadDomain)))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb2
	}
	if len(m.UploadIp) > 0 {
		i -= len(m.UploadIp)
		copy(dAtA[i:], m.UploadIp)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.UploadIp)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe2
	}
	if m.UploadedSize != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.UploadedSize))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x90
	}
	if m.UsedSpace != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.UsedSpace))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if m.TotalSpace != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.TotalSpace))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if len(m.RetMsg) > 0 {
		i -= len(m.RetMsg)
		copy(dAtA[i:], m.RetMsg)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.RetMsg)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.RetCode != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.RetCode))
		i--
		dAtA[i] = 0x50
	}
	return len(dAtA) - i, nil
}

func (m *ApplyUploadRspV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyUploadRspV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplyUploadRspV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UploadipList) > 0 {
		for iNdEx := len(m.UploadipList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.UploadipList[iNdEx])
			copy(dAtA[i:], m.UploadipList[iNdEx])
			i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.UploadipList[iNdEx])))
			i--
			dAtA[i] = 0x8
			i--
			dAtA[i] = 0x92
		}
	}
	if m.PackSize != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.PackSize))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xc0
	}
	if m.BoolFileExist {
		i--
		if m.BoolFileExist {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xf0
	}
	if len(m.UploadKey) > 0 {
		i -= len(m.UploadKey)
		copy(dAtA[i:], m.UploadKey)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.UploadKey)))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa2
	}
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xd2
	}
	if m.UploadPort != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.UploadPort))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x80
	}
	if len(m.UploadDomain) > 0 {
		i -= len(m.UploadDomain)
		copy(dAtA[i:], m.UploadDomain)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.UploadDomain)))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb2
	}
	if len(m.UploadIp) > 0 {
		i -= len(m.UploadIp)
		copy(dAtA[i:], m.UploadIp)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.UploadIp)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe2
	}
	if m.UploadedSize != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.UploadedSize))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x90
	}
	if m.UsedSpace != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.UsedSpace))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if m.TotalSpace != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.TotalSpace))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if len(m.RetMsg) > 0 {
		i -= len(m.RetMsg)
		copy(dAtA[i:], m.RetMsg)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.RetMsg)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.RetCode != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.RetCode))
		i--
		dAtA[i] = 0x50
	}
	return len(dAtA) - i, nil
}

func (m *DelMessageReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelMessageReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelMessageReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SeqNo != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.SeqNo))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.Random != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.Random))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.Time != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x50
	}
	if m.UinReceiver != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.UinReceiver))
		i--
		dAtA[i] = 0x10
	}
	if m.UinSender != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.UinSender))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteFileReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteFileReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteFileReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	if m.DeleteType != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.DeleteType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.PeerUin != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.PeerUin))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.Uin != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.Uin))
		i--
		dAtA[i] = 0x50
	}
	return len(dAtA) - i, nil
}

func (m *DeleteFileRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteFileRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteFileRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RetMsg) > 0 {
		i -= len(m.RetMsg)
		copy(dAtA[i:], m.RetMsg)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.RetMsg)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.RetCode != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.RetCode))
		i--
		dAtA[i] = 0x50
	}
	return len(dAtA) - i, nil
}

func (m *DownloadInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownloadInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DownloadInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Cookie) > 0 {
		i -= len(m.Cookie)
		copy(dAtA[i:], m.Cookie)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.Cookie)))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb2
	}
	if len(m.DownloadipList) > 0 {
		for iNdEx := len(m.DownloadipList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DownloadipList[iNdEx])
			copy(dAtA[i:], m.DownloadipList[iNdEx])
			i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.DownloadipList[iNdEx])))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xe2
		}
	}
	if len(m.DownloadUrl) > 0 {
		i -= len(m.DownloadUrl)
		copy(dAtA[i:], m.DownloadUrl)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.DownloadUrl)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	if m.Port != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if len(m.DownloadDomain) > 0 {
		i -= len(m.DownloadDomain)
		copy(dAtA[i:], m.DownloadDomain)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.DownloadDomain)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if len(m.DownloadIp) > 0 {
		i -= len(m.DownloadIp)
		copy(dAtA[i:], m.DownloadIp)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.DownloadIp)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.DownloadKey) > 0 {
		i -= len(m.DownloadKey)
		copy(dAtA[i:], m.DownloadKey)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.DownloadKey)))
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}

func (m *DownloadSuccReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownloadSuccReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DownloadSuccReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.Uin != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.Uin))
		i--
		dAtA[i] = 0x50
	}
	return len(dAtA) - i, nil
}

func (m *DownloadSuccRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownloadSuccRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DownloadSuccRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DownStat != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.DownStat))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if len(m.RetMsg) > 0 {
		i -= len(m.RetMsg)
		copy(dAtA[i:], m.RetMsg)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.RetMsg)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.RetCode != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.RetCode))
		i--
		dAtA[i] = 0x50
	}
	return len(dAtA) - i, nil
}

func (m *ExtensionReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtensionReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExtensionReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PttTime != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.PttTime))
		i--
		dAtA[i] = 0x2c
		i--
		dAtA[i] = 0xab
		i--
		dAtA[i] = 0x80
	}
	if m.FileType != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.FileType))
		i--
		dAtA[i] = 0x2c
		i--
		dAtA[i] = 0xa4
		i--
		dAtA[i] = 0xe0
	}
	if m.VoiceType != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.VoiceType))
		i--
		dAtA[i] = 0x2c
		i--
		dAtA[i] = 0x9e
		i--
		dAtA[i] = 0xc0
	}
	if m.NetType != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.NetType))
		i--
		dAtA[i] = 0x2c
		i--
		dAtA[i] = 0x98
		i--
		dAtA[i] = 0xa0
	}
	if m.IsNeedInnerIp != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.IsNeedInnerIp))
		i--
		dAtA[i] = 0x2c
		i--
		dAtA[i] = 0x92
		i--
		dAtA[i] = 0x80
	}
	if m.PttFormat != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.PttFormat))
		i--
		dAtA[i] = 0x2c
		i--
		dAtA[i] = 0x8b
		i--
		dAtA[i] = 0xe0
	}
	if m.DownloadUrlType != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.DownloadUrlType))
		i--
		dAtA[i] = 0x2c
		i--
		dAtA[i] = 0x85
		i--
		dAtA[i] = 0xc0
	}
	if m.DelMessageReq != nil {
		{
			size, err := m.DelMessageReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2b
		i--
		dAtA[i] = 0xff
		i--
		dAtA[i] = 0xa2
	}
	if m.RouteId != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.RouteId))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if len(m.Sig) > 0 {
		i -= len(m.Sig)
		copy(dAtA[i:], m.Sig)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.Sig)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.PhoneConvertType != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.PhoneConvertType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.DstPhonenum) > 0 {
		i -= len(m.DstPhonenum)
		copy(dAtA[i:], m.DstPhonenum)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.DstPhonenum)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ExtensionRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtensionRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExtensionRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *FileInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpireTime != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.ExpireTime))
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0x90
	}
	if m.PeerUin != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.PeerUin))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xc8
	}
	if m.OwnerUin != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.OwnerUin))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xc0
	}
	if m.ClientType != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.ClientType))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xf0
	}
	if len(m.Sha) > 0 {
		i -= len(m.Sha)
		copy(dAtA[i:], m.Sha)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.Sha)))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xaa
	}
	if len(m.Bytes_10MMd5) > 0 {
		i -= len(m.Bytes_10MMd5)
		copy(dAtA[i:], m.Bytes_10MMd5)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.Bytes_10MMd5)))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa2
	}
	if m.AbsFileType != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.AbsFileType))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xd0
	}
	if len(m.FileName) > 0 {
		i -= len(m.FileName)
		copy(dAtA[i:], m.FileName)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.FileName)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0x32
	}
	if m.UploadTime != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.UploadTime))
		i--
		dAtA[i] = 0x28
	}
	if m.LifeTime != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.LifeTime))
		i--
		dAtA[i] = 0x20
	}
	if m.FileSize != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.FileSize))
		i--
		dAtA[i] = 0x18
	}
	if m.DangerEvel != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.DangerEvel))
		i--
		dAtA[i] = 0x10
	}
	if m.Uin != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.Uin))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FileQueryReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileQueryReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileQueryReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.Uin != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.Uin))
		i--
		dAtA[i] = 0x50
	}
	return len(dAtA) - i, nil
}

func (m *FileQueryRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileQueryRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileQueryRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FileInfo != nil {
		{
			size, err := m.FileInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if len(m.RetMsg) > 0 {
		i -= len(m.RetMsg)
		copy(dAtA[i:], m.RetMsg)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.RetMsg)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.RetCode != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.RetCode))
		i--
		dAtA[i] = 0x50
	}
	return len(dAtA) - i, nil
}

func (m *RecallFileReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecallFileReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecallFileReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0x12
	}
	if m.Uin != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.Uin))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RecallFileRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecallFileRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecallFileRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RetMsg) > 0 {
		i -= len(m.RetMsg)
		copy(dAtA[i:], m.RetMsg)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.RetMsg)))
		i--
		dAtA[i] = 0x12
	}
	if m.RetCode != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.RetCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RecvListQueryReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecvListQueryReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecvListQueryReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReqCount != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.ReqCount))
		i--
		dAtA[i] = 0x18
	}
	if m.BeginIndex != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.BeginIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.Uin != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.Uin))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RecvListQueryRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecvListQueryRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecvListQueryRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FileList) > 0 {
		for iNdEx := len(m.FileList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FileList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCmd0X346(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.IsEnd != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.IsEnd))
		i--
		dAtA[i] = 0x30
	}
	if m.RspFileCount != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.RspFileCount))
		i--
		dAtA[i] = 0x28
	}
	if m.BeginIndex != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.BeginIndex))
		i--
		dAtA[i] = 0x20
	}
	if m.FileTotCount != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.FileTotCount))
		i--
		dAtA[i] = 0x18
	}
	if len(m.RetMsg) > 0 {
		i -= len(m.RetMsg)
		copy(dAtA[i:], m.RetMsg)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.RetMsg)))
		i--
		dAtA[i] = 0x12
	}
	if m.RetCode != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.RetCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RenewFileReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RenewFileReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RenewFileReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AddTtl != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.AddTtl))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0x12
	}
	if m.Uin != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.Uin))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RenewFileRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RenewFileRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RenewFileRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RetMsg) > 0 {
		i -= len(m.RetMsg)
		copy(dAtA[i:], m.RetMsg)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.RetMsg)))
		i--
		dAtA[i] = 0x12
	}
	if m.RetCode != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.RetCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *C346ReqBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C346ReqBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C346ReqBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExtensionReq != nil {
		{
			size, err := m.ExtensionReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x30
		i--
		dAtA[i] = 0xe9
		i--
		dAtA[i] = 0xfa
	}
	if m.ApplyGetTrafficReq != nil {
		{
			size, err := m.ApplyGetTrafficReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2b
		i--
		dAtA[i] = 0xf9
		i--
		dAtA[i] = 0x92
	}
	if m.ApplyCopyToReq != nil {
		{
			size, err := m.ApplyCopyToReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2b
		i--
		dAtA[i] = 0xf9
		i--
		dAtA[i] = 0x82
	}
	if m.ClientType != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.ClientType))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb0
	}
	if m.BusinessId != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.BusinessId))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.ApplyUploadHitReqV3 != nil {
		{
			size, err := m.ApplyUploadHitReqV3.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.ApplyUploadHitReqV2 != nil {
		{
			size, err := m.ApplyUploadHitReqV2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.ApplyUploadReqV3 != nil {
		{
			size, err := m.ApplyUploadReqV3.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.ApplyUploadReqV2 != nil {
		{
			size, err := m.ApplyUploadReqV2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.ApplyCopyFromReq != nil {
		{
			size, err := m.ApplyCopyFromReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.FileQueryReq != nil {
		{
			size, err := m.FileQueryReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.ApplyListDownloadReq != nil {
		{
			size, err := m.ApplyListDownloadReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.ApplyDownloadReq != nil {
		{
			size, err := m.ApplyDownloadReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.ApplyDownloadAbsReq != nil {
		{
			size, err := m.ApplyDownloadAbsReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.DownloadSuccReq != nil {
		{
			size, err := m.DownloadSuccReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.DeleteFileReq != nil {
		{
			size, err := m.DeleteFileReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.UploadSuccReq != nil {
		{
			size, err := m.UploadSuccReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.ApplyForwardFileReq != nil {
		{
			size, err := m.ApplyForwardFileReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.ApplyUploadHitReq != nil {
		{
			size, err := m.ApplyUploadHitReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.ApplyUploadReq != nil {
		{
			size, err := m.ApplyUploadReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.RecallFileReq != nil {
		{
			size, err := m.RecallFileReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.RenewFileReq != nil {
		{
			size, err := m.RenewFileReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.SendListQueryReq != nil {
		{
			size, err := m.SendListQueryReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.RecvListQueryReq != nil {
		{
			size, err := m.RecvListQueryReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Seq != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x10
	}
	if m.Cmd != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.Cmd))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *C346RspBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C346RspBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C346RspBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExtensionRsp != nil {
		{
			size, err := m.ExtensionRsp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x30
		i--
		dAtA[i] = 0xe9
		i--
		dAtA[i] = 0xfa
	}
	if m.ApplyGetTrafficRsp != nil {
		{
			size, err := m.ApplyGetTrafficRsp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2b
		i--
		dAtA[i] = 0xf9
		i--
		dAtA[i] = 0x92
	}
	if m.ApplyCleanTrafficRsp != nil {
		{
			size, err := m.ApplyCleanTrafficRsp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2b
		i--
		dAtA[i] = 0xf9
		i--
		dAtA[i] = 0x8a
	}
	if m.ApplyCopyToRsp != nil {
		{
			size, err := m.ApplyCopyToRsp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2b
		i--
		dAtA[i] = 0xf9
		i--
		dAtA[i] = 0x82
	}
	if m.ClientType != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.ClientType))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb0
	}
	if m.BusinessId != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.BusinessId))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.ApplyUploadHitRspV3 != nil {
		{
			size, err := m.ApplyUploadHitRspV3.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.ApplyUploadHitRspV2 != nil {
		{
			size, err := m.ApplyUploadHitRspV2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.ApplyUploadRspV3 != nil {
		{
			size, err := m.ApplyUploadRspV3.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.ApplyUploadRspV2 != nil {
		{
			size, err := m.ApplyUploadRspV2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.ApplyCopyFromRsp != nil {
		{
			size, err := m.ApplyCopyFromRsp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.FileQueryRsp != nil {
		{
			size, err := m.FileQueryRsp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.ApplyListDownloadRsp != nil {
		{
			size, err := m.ApplyListDownloadRsp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.ApplyDownloadRsp != nil {
		{
			size, err := m.ApplyDownloadRsp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.ApplyDownloadAbsRsp != nil {
		{
			size, err := m.ApplyDownloadAbsRsp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.DownloadSuccRsp != nil {
		{
			size, err := m.DownloadSuccRsp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.DeleteFileRsp != nil {
		{
			size, err := m.DeleteFileRsp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.UploadSuccRsp != nil {
		{
			size, err := m.UploadSuccRsp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.ApplyForwardFileRsp != nil {
		{
			size, err := m.ApplyForwardFileRsp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.ApplyUploadHitRsp != nil {
		{
			size, err := m.ApplyUploadHitRsp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.ApplyUploadRsp != nil {
		{
			size, err := m.ApplyUploadRsp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.RecallFileRsp != nil {
		{
			size, err := m.RecallFileRsp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.RenewFileRsp != nil {
		{
			size, err := m.RenewFileRsp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.SendListQueryRsp != nil {
		{
			size, err := m.SendListQueryRsp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.RecvListQueryRsp != nil {
		{
			size, err := m.RecvListQueryRsp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Seq != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x10
	}
	if m.Cmd != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.Cmd))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SendListQueryReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendListQueryReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendListQueryReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReqCount != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.ReqCount))
		i--
		dAtA[i] = 0x18
	}
	if m.BeginIndex != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.BeginIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.Uin != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.Uin))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SendListQueryRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendListQueryRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendListQueryRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FileList) > 0 {
		for iNdEx := len(m.FileList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FileList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCmd0X346(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.UsedLimit != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.UsedLimit))
		i--
		dAtA[i] = 0x40
	}
	if m.TotLimit != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.TotLimit))
		i--
		dAtA[i] = 0x38
	}
	if m.IsEnd != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.IsEnd))
		i--
		dAtA[i] = 0x30
	}
	if m.RspFileCount != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.RspFileCount))
		i--
		dAtA[i] = 0x28
	}
	if m.BeginIndex != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.BeginIndex))
		i--
		dAtA[i] = 0x20
	}
	if m.FileTotCount != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.FileTotCount))
		i--
		dAtA[i] = 0x18
	}
	if len(m.RetMsg) > 0 {
		i -= len(m.RetMsg)
		copy(dAtA[i:], m.RetMsg)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.RetMsg)))
		i--
		dAtA[i] = 0x12
	}
	if m.RetCode != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.RetCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UploadSuccReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadSuccReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadSuccReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.RecverUin != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.RecverUin))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.SenderUin != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.SenderUin))
		i--
		dAtA[i] = 0x50
	}
	return len(dAtA) - i, nil
}

func (m *UploadSuccRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadSuccRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadSuccRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FileInfo != nil {
		{
			size, err := m.FileInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X346(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if len(m.RetMsg) > 0 {
		i -= len(m.RetMsg)
		copy(dAtA[i:], m.RetMsg)
		i = encodeVarintCmd0X346(dAtA, i, uint64(len(m.RetMsg)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.RetCode != 0 {
		i = encodeVarintCmd0X346(dAtA, i, uint64(m.RetCode))
		i--
		dAtA[i] = 0x50
	}
	return len(dAtA) - i, nil
}

func encodeVarintCmd0X346(dAtA []byte, offset int, v uint64) int {
	offset -= sovCmd0X346(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ApplyCleanTrafficRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RetCode != 0 {
		n += 1 + sovCmd0X346(uint64(m.RetCode))
	}
	l = len(m.RetMsg)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	return n
}

func (m *ApplyCopyFromReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrcUin != 0 {
		n += 1 + sovCmd0X346(uint64(m.SrcUin))
	}
	if m.SrcGroup != 0 {
		n += 2 + sovCmd0X346(uint64(m.SrcGroup))
	}
	if m.SrcSvcid != 0 {
		n += 2 + sovCmd0X346(uint64(m.SrcSvcid))
	}
	l = len(m.SrcParentfolder)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.SrcUuid)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.FileMd5)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.DstUin != 0 {
		n += 2 + sovCmd0X346(uint64(m.DstUin))
	}
	if m.FileSize != 0 {
		n += 2 + sovCmd0X346(uint64(m.FileSize))
	}
	l = len(m.FileName)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.DangerLevel != 0 {
		n += 2 + sovCmd0X346(uint64(m.DangerLevel))
	}
	if m.TotalSpace != 0 {
		n += 2 + sovCmd0X346(uint64(m.TotalSpace))
	}
	return n
}

func (m *ApplyCopyFromRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RetCode != 0 {
		n += 1 + sovCmd0X346(uint64(m.RetCode))
	}
	l = len(m.RetMsg)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.TotalSpace != 0 {
		n += 2 + sovCmd0X346(uint64(m.TotalSpace))
	}
	return n
}

func (m *ApplyCopyToReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DstId != 0 {
		n += 1 + sovCmd0X346(uint64(m.DstId))
	}
	if m.DstUin != 0 {
		n += 2 + sovCmd0X346(uint64(m.DstUin))
	}
	if m.DstSvcid != 0 {
		n += 2 + sovCmd0X346(uint64(m.DstSvcid))
	}
	if m.SrcUin != 0 {
		n += 2 + sovCmd0X346(uint64(m.SrcUin))
	}
	if m.FileSize != 0 {
		n += 2 + sovCmd0X346(uint64(m.FileSize))
	}
	l = len(m.FileName)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.LocalFilepath)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	return n
}

func (m *ApplyCopyToRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RetCode != 0 {
		n += 1 + sovCmd0X346(uint64(m.RetCode))
	}
	l = len(m.RetMsg)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.FileKey)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	return n
}

func (m *ApplyDownloadAbsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uin != 0 {
		n += 1 + sovCmd0X346(uint64(m.Uin))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	return n
}

func (m *ApplyDownloadAbsRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RetCode != 0 {
		n += 1 + sovCmd0X346(uint64(m.RetCode))
	}
	l = len(m.RetMsg)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.DownloadInfo != nil {
		l = m.DownloadInfo.Size()
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	return n
}

func (m *ApplyDownloadReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uin != 0 {
		n += 1 + sovCmd0X346(uint64(m.Uin))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.OwnerType != 0 {
		n += 2 + sovCmd0X346(uint64(m.OwnerType))
	}
	if m.ExtIntype != 0 {
		n += 2 + sovCmd0X346(uint64(m.ExtIntype))
	}
	return n
}

func (m *ApplyDownloadRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RetCode != 0 {
		n += 1 + sovCmd0X346(uint64(m.RetCode))
	}
	l = len(m.RetMsg)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.DownloadInfo != nil {
		l = m.DownloadInfo.Size()
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.FileInfo != nil {
		l = m.FileInfo.Size()
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	return n
}

func (m *ApplyForwardFileReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SenderUin != 0 {
		n += 1 + sovCmd0X346(uint64(m.SenderUin))
	}
	if m.RecverUin != 0 {
		n += 2 + sovCmd0X346(uint64(m.RecverUin))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.DangerLevel != 0 {
		n += 2 + sovCmd0X346(uint64(m.DangerLevel))
	}
	if m.TotalSpace != 0 {
		n += 2 + sovCmd0X346(uint64(m.TotalSpace))
	}
	return n
}

func (m *ApplyForwardFileRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RetCode != 0 {
		n += 1 + sovCmd0X346(uint64(m.RetCode))
	}
	l = len(m.RetMsg)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.TotalSpace != 0 {
		n += 2 + sovCmd0X346(uint64(m.TotalSpace))
	}
	if m.UsedSpace != 0 {
		n += 2 + sovCmd0X346(uint64(m.UsedSpace))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	return n
}

func (m *ApplyGetTrafficReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ApplyGetTrafficRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RetCode != 0 {
		n += 1 + sovCmd0X346(uint64(m.RetCode))
	}
	l = len(m.RetMsg)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.UseFileSize != 0 {
		n += 2 + sovCmd0X346(uint64(m.UseFileSize))
	}
	if m.UseFileNum != 0 {
		n += 2 + sovCmd0X346(uint64(m.UseFileNum))
	}
	if m.AllFileSize != 0 {
		n += 2 + sovCmd0X346(uint64(m.AllFileSize))
	}
	if m.AllFileNum != 0 {
		n += 2 + sovCmd0X346(uint64(m.AllFileNum))
	}
	return n
}

func (m *ApplyListDownloadReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uin != 0 {
		n += 1 + sovCmd0X346(uint64(m.Uin))
	}
	if m.BeginIndex != 0 {
		n += 2 + sovCmd0X346(uint64(m.BeginIndex))
	}
	if m.ReqCount != 0 {
		n += 2 + sovCmd0X346(uint64(m.ReqCount))
	}
	return n
}

func (m *ApplyListDownloadRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RetCode != 0 {
		n += 1 + sovCmd0X346(uint64(m.RetCode))
	}
	l = len(m.RetMsg)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.TotalCount != 0 {
		n += 2 + sovCmd0X346(uint64(m.TotalCount))
	}
	if m.BeginIndex != 0 {
		n += 2 + sovCmd0X346(uint64(m.BeginIndex))
	}
	if m.RspCount != 0 {
		n += 2 + sovCmd0X346(uint64(m.RspCount))
	}
	if m.IsEnd != 0 {
		n += 2 + sovCmd0X346(uint64(m.IsEnd))
	}
	if len(m.FileList) > 0 {
		for _, e := range m.FileList {
			l = e.Size()
			n += 2 + l + sovCmd0X346(uint64(l))
		}
	}
	return n
}

func (m *ApplyUploadHitReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SenderUin != 0 {
		n += 1 + sovCmd0X346(uint64(m.SenderUin))
	}
	if m.RecverUin != 0 {
		n += 2 + sovCmd0X346(uint64(m.RecverUin))
	}
	if m.FileSize != 0 {
		n += 2 + sovCmd0X346(uint64(m.FileSize))
	}
	l = len(m.FileName)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.Bytes_10MMd5)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.LocalFilepath)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.DangerLevel != 0 {
		n += 2 + sovCmd0X346(uint64(m.DangerLevel))
	}
	if m.TotalSpace != 0 {
		n += 2 + sovCmd0X346(uint64(m.TotalSpace))
	}
	return n
}

func (m *ApplyUploadHitReqV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SenderUin != 0 {
		n += 1 + sovCmd0X346(uint64(m.SenderUin))
	}
	if m.RecverUin != 0 {
		n += 2 + sovCmd0X346(uint64(m.RecverUin))
	}
	if m.FileSize != 0 {
		n += 2 + sovCmd0X346(uint64(m.FileSize))
	}
	l = len(m.FileName)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.Bytes_10MMd5)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.Bytes_3Sha)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.Sha)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.LocalFilepath)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.DangerLevel != 0 {
		n += 2 + sovCmd0X346(uint64(m.DangerLevel))
	}
	if m.TotalSpace != 0 {
		n += 2 + sovCmd0X346(uint64(m.TotalSpace))
	}
	return n
}

func (m *ApplyUploadHitReqV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SenderUin != 0 {
		n += 1 + sovCmd0X346(uint64(m.SenderUin))
	}
	if m.RecverUin != 0 {
		n += 2 + sovCmd0X346(uint64(m.RecverUin))
	}
	if m.FileSize != 0 {
		n += 2 + sovCmd0X346(uint64(m.FileSize))
	}
	l = len(m.FileName)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.Bytes_10MMd5)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.Sha)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.LocalFilepath)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.DangerLevel != 0 {
		n += 2 + sovCmd0X346(uint64(m.DangerLevel))
	}
	if m.TotalSpace != 0 {
		n += 2 + sovCmd0X346(uint64(m.TotalSpace))
	}
	return n
}

func (m *ApplyUploadHitRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RetCode != 0 {
		n += 1 + sovCmd0X346(uint64(m.RetCode))
	}
	l = len(m.RetMsg)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.UploadIp)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.UploadPort != 0 {
		n += 2 + sovCmd0X346(uint64(m.UploadPort))
	}
	l = len(m.UploadDomain)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.UploadKey)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.TotalSpace != 0 {
		n += 2 + sovCmd0X346(uint64(m.TotalSpace))
	}
	if m.UsedSpace != 0 {
		n += 2 + sovCmd0X346(uint64(m.UsedSpace))
	}
	return n
}

func (m *ApplyUploadHitRspV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RetCode != 0 {
		n += 1 + sovCmd0X346(uint64(m.RetCode))
	}
	l = len(m.RetMsg)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.UploadIp)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.UploadPort != 0 {
		n += 2 + sovCmd0X346(uint64(m.UploadPort))
	}
	l = len(m.UploadDomain)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.UploadKey)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.TotalSpace != 0 {
		n += 2 + sovCmd0X346(uint64(m.TotalSpace))
	}
	if m.UsedSpace != 0 {
		n += 2 + sovCmd0X346(uint64(m.UsedSpace))
	}
	return n
}

func (m *ApplyUploadHitRspV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RetCode != 0 {
		n += 1 + sovCmd0X346(uint64(m.RetCode))
	}
	l = len(m.RetMsg)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.UploadIp)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.UploadPort != 0 {
		n += 2 + sovCmd0X346(uint64(m.UploadPort))
	}
	l = len(m.UploadDomain)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.UploadKey)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.TotalSpace != 0 {
		n += 2 + sovCmd0X346(uint64(m.TotalSpace))
	}
	if m.UsedSpace != 0 {
		n += 2 + sovCmd0X346(uint64(m.UsedSpace))
	}
	return n
}

func (m *ApplyUploadReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SenderUin != 0 {
		n += 1 + sovCmd0X346(uint64(m.SenderUin))
	}
	if m.RecverUin != 0 {
		n += 2 + sovCmd0X346(uint64(m.RecverUin))
	}
	if m.FileType != 0 {
		n += 2 + sovCmd0X346(uint64(m.FileType))
	}
	if m.FileSize != 0 {
		n += 2 + sovCmd0X346(uint64(m.FileSize))
	}
	l = len(m.FileName)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.Bytes_10MMd5)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.LocalFilepath)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.DangerLevel != 0 {
		n += 2 + sovCmd0X346(uint64(m.DangerLevel))
	}
	if m.TotalSpace != 0 {
		n += 2 + sovCmd0X346(uint64(m.TotalSpace))
	}
	return n
}

func (m *ApplyUploadReqV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SenderUin != 0 {
		n += 1 + sovCmd0X346(uint64(m.SenderUin))
	}
	if m.RecverUin != 0 {
		n += 2 + sovCmd0X346(uint64(m.RecverUin))
	}
	if m.FileSize != 0 {
		n += 2 + sovCmd0X346(uint64(m.FileSize))
	}
	l = len(m.FileName)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.Bytes_10MMd5)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.Bytes_3Sha)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.LocalFilepath)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.DangerLevel != 0 {
		n += 2 + sovCmd0X346(uint64(m.DangerLevel))
	}
	if m.TotalSpace != 0 {
		n += 2 + sovCmd0X346(uint64(m.TotalSpace))
	}
	return n
}

func (m *ApplyUploadReqV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SenderUin != 0 {
		n += 1 + sovCmd0X346(uint64(m.SenderUin))
	}
	if m.RecverUin != 0 {
		n += 2 + sovCmd0X346(uint64(m.RecverUin))
	}
	if m.FileSize != 0 {
		n += 2 + sovCmd0X346(uint64(m.FileSize))
	}
	l = len(m.FileName)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.Bytes_10MMd5)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.Sha)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.LocalFilepath)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.DangerLevel != 0 {
		n += 2 + sovCmd0X346(uint64(m.DangerLevel))
	}
	if m.TotalSpace != 0 {
		n += 2 + sovCmd0X346(uint64(m.TotalSpace))
	}
	return n
}

func (m *ApplyUploadRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RetCode != 0 {
		n += 1 + sovCmd0X346(uint64(m.RetCode))
	}
	l = len(m.RetMsg)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.TotalSpace != 0 {
		n += 2 + sovCmd0X346(uint64(m.TotalSpace))
	}
	if m.UsedSpace != 0 {
		n += 2 + sovCmd0X346(uint64(m.UsedSpace))
	}
	if m.UploadedSize != 0 {
		n += 2 + sovCmd0X346(uint64(m.UploadedSize))
	}
	l = len(m.UploadIp)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.UploadDomain)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.UploadPort != 0 {
		n += 2 + sovCmd0X346(uint64(m.UploadPort))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.UploadKey)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.BoolFileExist {
		n += 3
	}
	if m.PackSize != 0 {
		n += 2 + sovCmd0X346(uint64(m.PackSize))
	}
	if len(m.UploadipList) > 0 {
		for _, s := range m.UploadipList {
			l = len(s)
			n += 2 + l + sovCmd0X346(uint64(l))
		}
	}
	return n
}

func (m *ApplyUploadRspV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RetCode != 0 {
		n += 1 + sovCmd0X346(uint64(m.RetCode))
	}
	l = len(m.RetMsg)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.TotalSpace != 0 {
		n += 2 + sovCmd0X346(uint64(m.TotalSpace))
	}
	if m.UsedSpace != 0 {
		n += 2 + sovCmd0X346(uint64(m.UsedSpace))
	}
	if m.UploadedSize != 0 {
		n += 2 + sovCmd0X346(uint64(m.UploadedSize))
	}
	l = len(m.UploadIp)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.UploadDomain)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.UploadPort != 0 {
		n += 2 + sovCmd0X346(uint64(m.UploadPort))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.UploadKey)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.BoolFileExist {
		n += 3
	}
	if m.PackSize != 0 {
		n += 2 + sovCmd0X346(uint64(m.PackSize))
	}
	if len(m.UploadipList) > 0 {
		for _, s := range m.UploadipList {
			l = len(s)
			n += 2 + l + sovCmd0X346(uint64(l))
		}
	}
	if m.HttpsvrApiVer != 0 {
		n += 2 + sovCmd0X346(uint64(m.HttpsvrApiVer))
	}
	l = len(m.Sha)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	return n
}

func (m *ApplyUploadRspV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RetCode != 0 {
		n += 1 + sovCmd0X346(uint64(m.RetCode))
	}
	l = len(m.RetMsg)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.TotalSpace != 0 {
		n += 2 + sovCmd0X346(uint64(m.TotalSpace))
	}
	if m.UsedSpace != 0 {
		n += 2 + sovCmd0X346(uint64(m.UsedSpace))
	}
	if m.UploadedSize != 0 {
		n += 2 + sovCmd0X346(uint64(m.UploadedSize))
	}
	l = len(m.UploadIp)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.UploadDomain)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.UploadPort != 0 {
		n += 2 + sovCmd0X346(uint64(m.UploadPort))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.UploadKey)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.BoolFileExist {
		n += 3
	}
	if m.PackSize != 0 {
		n += 2 + sovCmd0X346(uint64(m.PackSize))
	}
	if len(m.UploadipList) > 0 {
		for _, s := range m.UploadipList {
			l = len(s)
			n += 2 + l + sovCmd0X346(uint64(l))
		}
	}
	return n
}

func (m *DelMessageReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UinSender != 0 {
		n += 1 + sovCmd0X346(uint64(m.UinSender))
	}
	if m.UinReceiver != 0 {
		n += 1 + sovCmd0X346(uint64(m.UinReceiver))
	}
	if m.Time != 0 {
		n += 1 + sovCmd0X346(uint64(m.Time))
	}
	if m.Random != 0 {
		n += 2 + sovCmd0X346(uint64(m.Random))
	}
	if m.SeqNo != 0 {
		n += 2 + sovCmd0X346(uint64(m.SeqNo))
	}
	return n
}

func (m *DeleteFileReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uin != 0 {
		n += 1 + sovCmd0X346(uint64(m.Uin))
	}
	if m.PeerUin != 0 {
		n += 2 + sovCmd0X346(uint64(m.PeerUin))
	}
	if m.DeleteType != 0 {
		n += 2 + sovCmd0X346(uint64(m.DeleteType))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	return n
}

func (m *DeleteFileRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RetCode != 0 {
		n += 1 + sovCmd0X346(uint64(m.RetCode))
	}
	l = len(m.RetMsg)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	return n
}

func (m *DownloadInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DownloadKey)
	if l > 0 {
		n += 1 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.DownloadIp)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.DownloadDomain)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.Port != 0 {
		n += 2 + sovCmd0X346(uint64(m.Port))
	}
	l = len(m.DownloadUrl)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if len(m.DownloadipList) > 0 {
		for _, s := range m.DownloadipList {
			l = len(s)
			n += 2 + l + sovCmd0X346(uint64(l))
		}
	}
	l = len(m.Cookie)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	return n
}

func (m *DownloadSuccReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uin != 0 {
		n += 1 + sovCmd0X346(uint64(m.Uin))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	return n
}

func (m *DownloadSuccRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RetCode != 0 {
		n += 1 + sovCmd0X346(uint64(m.RetCode))
	}
	l = len(m.RetMsg)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.DownStat != 0 {
		n += 2 + sovCmd0X346(uint64(m.DownStat))
	}
	return n
}

func (m *ExtensionReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCmd0X346(uint64(m.Id))
	}
	if m.Type != 0 {
		n += 1 + sovCmd0X346(uint64(m.Type))
	}
	l = len(m.DstPhonenum)
	if l > 0 {
		n += 1 + l + sovCmd0X346(uint64(l))
	}
	if m.PhoneConvertType != 0 {
		n += 1 + sovCmd0X346(uint64(m.PhoneConvertType))
	}
	l = len(m.Sig)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.RouteId != 0 {
		n += 2 + sovCmd0X346(uint64(m.RouteId))
	}
	if m.DelMessageReq != nil {
		l = m.DelMessageReq.Size()
		n += 3 + l + sovCmd0X346(uint64(l))
	}
	if m.DownloadUrlType != 0 {
		n += 3 + sovCmd0X346(uint64(m.DownloadUrlType))
	}
	if m.PttFormat != 0 {
		n += 3 + sovCmd0X346(uint64(m.PttFormat))
	}
	if m.IsNeedInnerIp != 0 {
		n += 3 + sovCmd0X346(uint64(m.IsNeedInnerIp))
	}
	if m.NetType != 0 {
		n += 3 + sovCmd0X346(uint64(m.NetType))
	}
	if m.VoiceType != 0 {
		n += 3 + sovCmd0X346(uint64(m.VoiceType))
	}
	if m.FileType != 0 {
		n += 3 + sovCmd0X346(uint64(m.FileType))
	}
	if m.PttTime != 0 {
		n += 3 + sovCmd0X346(uint64(m.PttTime))
	}
	return n
}

func (m *ExtensionRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *FileInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uin != 0 {
		n += 1 + sovCmd0X346(uint64(m.Uin))
	}
	if m.DangerEvel != 0 {
		n += 1 + sovCmd0X346(uint64(m.DangerEvel))
	}
	if m.FileSize != 0 {
		n += 1 + sovCmd0X346(uint64(m.FileSize))
	}
	if m.LifeTime != 0 {
		n += 1 + sovCmd0X346(uint64(m.LifeTime))
	}
	if m.UploadTime != 0 {
		n += 1 + sovCmd0X346(uint64(m.UploadTime))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.FileName)
	if l > 0 {
		n += 1 + l + sovCmd0X346(uint64(l))
	}
	if m.AbsFileType != 0 {
		n += 2 + sovCmd0X346(uint64(m.AbsFileType))
	}
	l = len(m.Bytes_10MMd5)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	l = len(m.Sha)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.ClientType != 0 {
		n += 2 + sovCmd0X346(uint64(m.ClientType))
	}
	if m.OwnerUin != 0 {
		n += 2 + sovCmd0X346(uint64(m.OwnerUin))
	}
	if m.PeerUin != 0 {
		n += 2 + sovCmd0X346(uint64(m.PeerUin))
	}
	if m.ExpireTime != 0 {
		n += 2 + sovCmd0X346(uint64(m.ExpireTime))
	}
	return n
}

func (m *FileQueryReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uin != 0 {
		n += 1 + sovCmd0X346(uint64(m.Uin))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	return n
}

func (m *FileQueryRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RetCode != 0 {
		n += 1 + sovCmd0X346(uint64(m.RetCode))
	}
	l = len(m.RetMsg)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.FileInfo != nil {
		l = m.FileInfo.Size()
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	return n
}

func (m *RecallFileReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uin != 0 {
		n += 1 + sovCmd0X346(uint64(m.Uin))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovCmd0X346(uint64(l))
	}
	return n
}

func (m *RecallFileRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RetCode != 0 {
		n += 1 + sovCmd0X346(uint64(m.RetCode))
	}
	l = len(m.RetMsg)
	if l > 0 {
		n += 1 + l + sovCmd0X346(uint64(l))
	}
	return n
}

func (m *RecvListQueryReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uin != 0 {
		n += 1 + sovCmd0X346(uint64(m.Uin))
	}
	if m.BeginIndex != 0 {
		n += 1 + sovCmd0X346(uint64(m.BeginIndex))
	}
	if m.ReqCount != 0 {
		n += 1 + sovCmd0X346(uint64(m.ReqCount))
	}
	return n
}

func (m *RecvListQueryRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RetCode != 0 {
		n += 1 + sovCmd0X346(uint64(m.RetCode))
	}
	l = len(m.RetMsg)
	if l > 0 {
		n += 1 + l + sovCmd0X346(uint64(l))
	}
	if m.FileTotCount != 0 {
		n += 1 + sovCmd0X346(uint64(m.FileTotCount))
	}
	if m.BeginIndex != 0 {
		n += 1 + sovCmd0X346(uint64(m.BeginIndex))
	}
	if m.RspFileCount != 0 {
		n += 1 + sovCmd0X346(uint64(m.RspFileCount))
	}
	if m.IsEnd != 0 {
		n += 1 + sovCmd0X346(uint64(m.IsEnd))
	}
	if len(m.FileList) > 0 {
		for _, e := range m.FileList {
			l = e.Size()
			n += 1 + l + sovCmd0X346(uint64(l))
		}
	}
	return n
}

func (m *RenewFileReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uin != 0 {
		n += 1 + sovCmd0X346(uint64(m.Uin))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovCmd0X346(uint64(l))
	}
	if m.AddTtl != 0 {
		n += 1 + sovCmd0X346(uint64(m.AddTtl))
	}
	return n
}

func (m *RenewFileRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RetCode != 0 {
		n += 1 + sovCmd0X346(uint64(m.RetCode))
	}
	l = len(m.RetMsg)
	if l > 0 {
		n += 1 + l + sovCmd0X346(uint64(l))
	}
	return n
}

func (m *C346ReqBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cmd != 0 {
		n += 1 + sovCmd0X346(uint64(m.Cmd))
	}
	if m.Seq != 0 {
		n += 1 + sovCmd0X346(uint64(m.Seq))
	}
	if m.RecvListQueryReq != nil {
		l = m.RecvListQueryReq.Size()
		n += 1 + l + sovCmd0X346(uint64(l))
	}
	if m.SendListQueryReq != nil {
		l = m.SendListQueryReq.Size()
		n += 1 + l + sovCmd0X346(uint64(l))
	}
	if m.RenewFileReq != nil {
		l = m.RenewFileReq.Size()
		n += 1 + l + sovCmd0X346(uint64(l))
	}
	if m.RecallFileReq != nil {
		l = m.RecallFileReq.Size()
		n += 1 + l + sovCmd0X346(uint64(l))
	}
	if m.ApplyUploadReq != nil {
		l = m.ApplyUploadReq.Size()
		n += 1 + l + sovCmd0X346(uint64(l))
	}
	if m.ApplyUploadHitReq != nil {
		l = m.ApplyUploadHitReq.Size()
		n += 1 + l + sovCmd0X346(uint64(l))
	}
	if m.ApplyForwardFileReq != nil {
		l = m.ApplyForwardFileReq.Size()
		n += 1 + l + sovCmd0X346(uint64(l))
	}
	if m.UploadSuccReq != nil {
		l = m.UploadSuccReq.Size()
		n += 1 + l + sovCmd0X346(uint64(l))
	}
	if m.DeleteFileReq != nil {
		l = m.DeleteFileReq.Size()
		n += 1 + l + sovCmd0X346(uint64(l))
	}
	if m.DownloadSuccReq != nil {
		l = m.DownloadSuccReq.Size()
		n += 1 + l + sovCmd0X346(uint64(l))
	}
	if m.ApplyDownloadAbsReq != nil {
		l = m.ApplyDownloadAbsReq.Size()
		n += 1 + l + sovCmd0X346(uint64(l))
	}
	if m.ApplyDownloadReq != nil {
		l = m.ApplyDownloadReq.Size()
		n += 1 + l + sovCmd0X346(uint64(l))
	}
	if m.ApplyListDownloadReq != nil {
		l = m.ApplyListDownloadReq.Size()
		n += 1 + l + sovCmd0X346(uint64(l))
	}
	if m.FileQueryReq != nil {
		l = m.FileQueryReq.Size()
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.ApplyCopyFromReq != nil {
		l = m.ApplyCopyFromReq.Size()
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.ApplyUploadReqV2 != nil {
		l = m.ApplyUploadReqV2.Size()
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.ApplyUploadReqV3 != nil {
		l = m.ApplyUploadReqV3.Size()
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.ApplyUploadHitReqV2 != nil {
		l = m.ApplyUploadHitReqV2.Size()
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.ApplyUploadHitReqV3 != nil {
		l = m.ApplyUploadHitReqV3.Size()
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.BusinessId != 0 {
		n += 2 + sovCmd0X346(uint64(m.BusinessId))
	}
	if m.ClientType != 0 {
		n += 2 + sovCmd0X346(uint64(m.ClientType))
	}
	if m.ApplyCopyToReq != nil {
		l = m.ApplyCopyToReq.Size()
		n += 3 + l + sovCmd0X346(uint64(l))
	}
	if m.ApplyGetTrafficReq != nil {
		l = m.ApplyGetTrafficReq.Size()
		n += 3 + l + sovCmd0X346(uint64(l))
	}
	if m.ExtensionReq != nil {
		l = m.ExtensionReq.Size()
		n += 3 + l + sovCmd0X346(uint64(l))
	}
	return n
}

func (m *C346RspBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cmd != 0 {
		n += 1 + sovCmd0X346(uint64(m.Cmd))
	}
	if m.Seq != 0 {
		n += 1 + sovCmd0X346(uint64(m.Seq))
	}
	if m.RecvListQueryRsp != nil {
		l = m.RecvListQueryRsp.Size()
		n += 1 + l + sovCmd0X346(uint64(l))
	}
	if m.SendListQueryRsp != nil {
		l = m.SendListQueryRsp.Size()
		n += 1 + l + sovCmd0X346(uint64(l))
	}
	if m.RenewFileRsp != nil {
		l = m.RenewFileRsp.Size()
		n += 1 + l + sovCmd0X346(uint64(l))
	}
	if m.RecallFileRsp != nil {
		l = m.RecallFileRsp.Size()
		n += 1 + l + sovCmd0X346(uint64(l))
	}
	if m.ApplyUploadRsp != nil {
		l = m.ApplyUploadRsp.Size()
		n += 1 + l + sovCmd0X346(uint64(l))
	}
	if m.ApplyUploadHitRsp != nil {
		l = m.ApplyUploadHitRsp.Size()
		n += 1 + l + sovCmd0X346(uint64(l))
	}
	if m.ApplyForwardFileRsp != nil {
		l = m.ApplyForwardFileRsp.Size()
		n += 1 + l + sovCmd0X346(uint64(l))
	}
	if m.UploadSuccRsp != nil {
		l = m.UploadSuccRsp.Size()
		n += 1 + l + sovCmd0X346(uint64(l))
	}
	if m.DeleteFileRsp != nil {
		l = m.DeleteFileRsp.Size()
		n += 1 + l + sovCmd0X346(uint64(l))
	}
	if m.DownloadSuccRsp != nil {
		l = m.DownloadSuccRsp.Size()
		n += 1 + l + sovCmd0X346(uint64(l))
	}
	if m.ApplyDownloadAbsRsp != nil {
		l = m.ApplyDownloadAbsRsp.Size()
		n += 1 + l + sovCmd0X346(uint64(l))
	}
	if m.ApplyDownloadRsp != nil {
		l = m.ApplyDownloadRsp.Size()
		n += 1 + l + sovCmd0X346(uint64(l))
	}
	if m.ApplyListDownloadRsp != nil {
		l = m.ApplyListDownloadRsp.Size()
		n += 1 + l + sovCmd0X346(uint64(l))
	}
	if m.FileQueryRsp != nil {
		l = m.FileQueryRsp.Size()
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.ApplyCopyFromRsp != nil {
		l = m.ApplyCopyFromRsp.Size()
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.ApplyUploadRspV2 != nil {
		l = m.ApplyUploadRspV2.Size()
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.ApplyUploadRspV3 != nil {
		l = m.ApplyUploadRspV3.Size()
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.ApplyUploadHitRspV2 != nil {
		l = m.ApplyUploadHitRspV2.Size()
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.ApplyUploadHitRspV3 != nil {
		l = m.ApplyUploadHitRspV3.Size()
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.BusinessId != 0 {
		n += 2 + sovCmd0X346(uint64(m.BusinessId))
	}
	if m.ClientType != 0 {
		n += 2 + sovCmd0X346(uint64(m.ClientType))
	}
	if m.ApplyCopyToRsp != nil {
		l = m.ApplyCopyToRsp.Size()
		n += 3 + l + sovCmd0X346(uint64(l))
	}
	if m.ApplyCleanTrafficRsp != nil {
		l = m.ApplyCleanTrafficRsp.Size()
		n += 3 + l + sovCmd0X346(uint64(l))
	}
	if m.ApplyGetTrafficRsp != nil {
		l = m.ApplyGetTrafficRsp.Size()
		n += 3 + l + sovCmd0X346(uint64(l))
	}
	if m.ExtensionRsp != nil {
		l = m.ExtensionRsp.Size()
		n += 3 + l + sovCmd0X346(uint64(l))
	}
	return n
}

func (m *SendListQueryReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uin != 0 {
		n += 1 + sovCmd0X346(uint64(m.Uin))
	}
	if m.BeginIndex != 0 {
		n += 1 + sovCmd0X346(uint64(m.BeginIndex))
	}
	if m.ReqCount != 0 {
		n += 1 + sovCmd0X346(uint64(m.ReqCount))
	}
	return n
}

func (m *SendListQueryRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RetCode != 0 {
		n += 1 + sovCmd0X346(uint64(m.RetCode))
	}
	l = len(m.RetMsg)
	if l > 0 {
		n += 1 + l + sovCmd0X346(uint64(l))
	}
	if m.FileTotCount != 0 {
		n += 1 + sovCmd0X346(uint64(m.FileTotCount))
	}
	if m.BeginIndex != 0 {
		n += 1 + sovCmd0X346(uint64(m.BeginIndex))
	}
	if m.RspFileCount != 0 {
		n += 1 + sovCmd0X346(uint64(m.RspFileCount))
	}
	if m.IsEnd != 0 {
		n += 1 + sovCmd0X346(uint64(m.IsEnd))
	}
	if m.TotLimit != 0 {
		n += 1 + sovCmd0X346(uint64(m.TotLimit))
	}
	if m.UsedLimit != 0 {
		n += 1 + sovCmd0X346(uint64(m.UsedLimit))
	}
	if len(m.FileList) > 0 {
		for _, e := range m.FileList {
			l = e.Size()
			n += 1 + l + sovCmd0X346(uint64(l))
		}
	}
	return n
}

func (m *UploadSuccReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SenderUin != 0 {
		n += 1 + sovCmd0X346(uint64(m.SenderUin))
	}
	if m.RecverUin != 0 {
		n += 2 + sovCmd0X346(uint64(m.RecverUin))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	return n
}

func (m *UploadSuccRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RetCode != 0 {
		n += 1 + sovCmd0X346(uint64(m.RetCode))
	}
	l = len(m.RetMsg)
	if l > 0 {
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	if m.FileInfo != nil {
		l = m.FileInfo.Size()
		n += 2 + l + sovCmd0X346(uint64(l))
	}
	return n
}

func sovCmd0X346(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCmd0X346(x uint64) (n int) {
	return sovCmd0X346(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ApplyCleanTrafficRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyCleanTrafficRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyCleanTrafficRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetCode", wireType)
			}
			m.RetCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyCopyFromReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyCopyFromReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyCopyFromReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcUin", wireType)
			}
			m.SrcUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcGroup", wireType)
			}
			m.SrcGroup = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcGroup |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcSvcid", wireType)
			}
			m.SrcSvcid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcSvcid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcParentfolder", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcParentfolder = append(m.SrcParentfolder[:0], dAtA[iNdEx:postIndex]...)
			if m.SrcParentfolder == nil {
				m.SrcParentfolder = []byte{}
			}
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcUuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcUuid = append(m.SrcUuid[:0], dAtA[iNdEx:postIndex]...)
			if m.SrcUuid == nil {
				m.SrcUuid = []byte{}
			}
			iNdEx = postIndex
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileMd5", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileMd5 = append(m.FileMd5[:0], dAtA[iNdEx:postIndex]...)
			if m.FileMd5 == nil {
				m.FileMd5 = []byte{}
			}
			iNdEx = postIndex
		case 70:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstUin", wireType)
			}
			m.DstUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 80:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 90:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DangerLevel", wireType)
			}
			m.DangerLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DangerLevel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 110:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSpace", wireType)
			}
			m.TotalSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSpace |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyCopyFromRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyCopyFromRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyCopyFromRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetCode", wireType)
			}
			m.RetCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = append(m.Uuid[:0], dAtA[iNdEx:postIndex]...)
			if m.Uuid == nil {
				m.Uuid = []byte{}
			}
			iNdEx = postIndex
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSpace", wireType)
			}
			m.TotalSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSpace |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyCopyToReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyCopyToReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyCopyToReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstId", wireType)
			}
			m.DstId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstUin", wireType)
			}
			m.DstUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstSvcid", wireType)
			}
			m.DstSvcid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstSvcid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcUin", wireType)
			}
			m.SrcUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 70:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalFilepath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalFilepath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 80:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = append(m.Uuid[:0], dAtA[iNdEx:postIndex]...)
			if m.Uuid == nil {
				m.Uuid = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyCopyToRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyCopyToRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyCopyToRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetCode", wireType)
			}
			m.RetCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyDownloadAbsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyDownloadAbsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyDownloadAbsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uin", wireType)
			}
			m.Uin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = append(m.Uuid[:0], dAtA[iNdEx:postIndex]...)
			if m.Uuid == nil {
				m.Uuid = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyDownloadAbsRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyDownloadAbsRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyDownloadAbsRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetCode", wireType)
			}
			m.RetCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DownloadInfo == nil {
				m.DownloadInfo = &DownloadInfo{}
			}
			if err := m.DownloadInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyDownloadReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyDownloadReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyDownloadReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uin", wireType)
			}
			m.Uin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = append(m.Uuid[:0], dAtA[iNdEx:postIndex]...)
			if m.Uuid == nil {
				m.Uuid = []byte{}
			}
			iNdEx = postIndex
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerType", wireType)
			}
			m.OwnerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 500:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtIntype", wireType)
			}
			m.ExtIntype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExtIntype |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyDownloadRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyDownloadRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyDownloadRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetCode", wireType)
			}
			m.RetCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DownloadInfo == nil {
				m.DownloadInfo = &DownloadInfo{}
			}
			if err := m.DownloadInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileInfo == nil {
				m.FileInfo = &FileInfo{}
			}
			if err := m.FileInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyForwardFileReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyForwardFileReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyForwardFileReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderUin", wireType)
			}
			m.SenderUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SenderUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecverUin", wireType)
			}
			m.RecverUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecverUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = append(m.Uuid[:0], dAtA[iNdEx:postIndex]...)
			if m.Uuid == nil {
				m.Uuid = []byte{}
			}
			iNdEx = postIndex
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DangerLevel", wireType)
			}
			m.DangerLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DangerLevel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSpace", wireType)
			}
			m.TotalSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSpace |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyForwardFileRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyForwardFileRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyForwardFileRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetCode", wireType)
			}
			m.RetCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSpace", wireType)
			}
			m.TotalSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSpace |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedSpace", wireType)
			}
			m.UsedSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsedSpace |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = append(m.Uuid[:0], dAtA[iNdEx:postIndex]...)
			if m.Uuid == nil {
				m.Uuid = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyGetTrafficReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyGetTrafficReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyGetTrafficReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyGetTrafficRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyGetTrafficRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyGetTrafficRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetCode", wireType)
			}
			m.RetCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseFileSize", wireType)
			}
			m.UseFileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UseFileSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseFileNum", wireType)
			}
			m.UseFileNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UseFileNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllFileSize", wireType)
			}
			m.AllFileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllFileSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 60:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllFileNum", wireType)
			}
			m.AllFileNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllFileNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyListDownloadReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyListDownloadReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyListDownloadReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uin", wireType)
			}
			m.Uin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeginIndex", wireType)
			}
			m.BeginIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeginIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqCount", wireType)
			}
			m.ReqCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyListDownloadRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyListDownloadRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyListDownloadRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetCode", wireType)
			}
			m.RetCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCount", wireType)
			}
			m.TotalCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeginIndex", wireType)
			}
			m.BeginIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeginIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RspCount", wireType)
			}
			m.RspCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RspCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 60:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEnd", wireType)
			}
			m.IsEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsEnd |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 70:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileList = append(m.FileList, &FileInfo{})
			if err := m.FileList[len(m.FileList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyUploadHitReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyUploadHitReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyUploadHitReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderUin", wireType)
			}
			m.SenderUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SenderUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecverUin", wireType)
			}
			m.RecverUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecverUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes_10MMd5", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bytes_10MMd5 = append(m.Bytes_10MMd5[:0], dAtA[iNdEx:postIndex]...)
			if m.Bytes_10MMd5 == nil {
				m.Bytes_10MMd5 = []byte{}
			}
			iNdEx = postIndex
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalFilepath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalFilepath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 70:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DangerLevel", wireType)
			}
			m.DangerLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DangerLevel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 80:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSpace", wireType)
			}
			m.TotalSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSpace |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyUploadHitReqV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyUploadHitReqV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyUploadHitReqV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderUin", wireType)
			}
			m.SenderUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SenderUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecverUin", wireType)
			}
			m.RecverUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecverUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes_10MMd5", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bytes_10MMd5 = append(m.Bytes_10MMd5[:0], dAtA[iNdEx:postIndex]...)
			if m.Bytes_10MMd5 == nil {
				m.Bytes_10MMd5 = []byte{}
			}
			iNdEx = postIndex
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes_3Sha", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bytes_3Sha = append(m.Bytes_3Sha[:0], dAtA[iNdEx:postIndex]...)
			if m.Bytes_3Sha == nil {
				m.Bytes_3Sha = []byte{}
			}
			iNdEx = postIndex
		case 70:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sha", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sha = append(m.Sha[:0], dAtA[iNdEx:postIndex]...)
			if m.Sha == nil {
				m.Sha = []byte{}
			}
			iNdEx = postIndex
		case 80:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalFilepath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalFilepath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 90:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DangerLevel", wireType)
			}
			m.DangerLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DangerLevel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSpace", wireType)
			}
			m.TotalSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSpace |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyUploadHitReqV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyUploadHitReqV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyUploadHitReqV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderUin", wireType)
			}
			m.SenderUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SenderUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecverUin", wireType)
			}
			m.RecverUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecverUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes_10MMd5", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bytes_10MMd5 = append(m.Bytes_10MMd5[:0], dAtA[iNdEx:postIndex]...)
			if m.Bytes_10MMd5 == nil {
				m.Bytes_10MMd5 = []byte{}
			}
			iNdEx = postIndex
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sha", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sha = append(m.Sha[:0], dAtA[iNdEx:postIndex]...)
			if m.Sha == nil {
				m.Sha = []byte{}
			}
			iNdEx = postIndex
		case 70:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalFilepath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalFilepath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 80:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DangerLevel", wireType)
			}
			m.DangerLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DangerLevel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 90:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSpace", wireType)
			}
			m.TotalSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSpace |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyUploadHitRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyUploadHitRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyUploadHitRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetCode", wireType)
			}
			m.RetCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UploadIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadPort", wireType)
			}
			m.UploadPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UploadPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadDomain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UploadDomain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = append(m.Uuid[:0], dAtA[iNdEx:postIndex]...)
			if m.Uuid == nil {
				m.Uuid = []byte{}
			}
			iNdEx = postIndex
		case 70:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UploadKey = append(m.UploadKey[:0], dAtA[iNdEx:postIndex]...)
			if m.UploadKey == nil {
				m.UploadKey = []byte{}
			}
			iNdEx = postIndex
		case 80:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSpace", wireType)
			}
			m.TotalSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSpace |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 90:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedSpace", wireType)
			}
			m.UsedSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsedSpace |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyUploadHitRspV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyUploadHitRspV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyUploadHitRspV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetCode", wireType)
			}
			m.RetCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UploadIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadPort", wireType)
			}
			m.UploadPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UploadPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadDomain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UploadDomain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = append(m.Uuid[:0], dAtA[iNdEx:postIndex]...)
			if m.Uuid == nil {
				m.Uuid = []byte{}
			}
			iNdEx = postIndex
		case 70:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UploadKey = append(m.UploadKey[:0], dAtA[iNdEx:postIndex]...)
			if m.UploadKey == nil {
				m.UploadKey = []byte{}
			}
			iNdEx = postIndex
		case 80:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSpace", wireType)
			}
			m.TotalSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSpace |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 90:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedSpace", wireType)
			}
			m.UsedSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsedSpace |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyUploadHitRspV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyUploadHitRspV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyUploadHitRspV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetCode", wireType)
			}
			m.RetCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UploadIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadPort", wireType)
			}
			m.UploadPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UploadPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadDomain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UploadDomain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = append(m.Uuid[:0], dAtA[iNdEx:postIndex]...)
			if m.Uuid == nil {
				m.Uuid = []byte{}
			}
			iNdEx = postIndex
		case 70:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UploadKey = append(m.UploadKey[:0], dAtA[iNdEx:postIndex]...)
			if m.UploadKey == nil {
				m.UploadKey = []byte{}
			}
			iNdEx = postIndex
		case 80:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSpace", wireType)
			}
			m.TotalSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSpace |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 90:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedSpace", wireType)
			}
			m.UsedSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsedSpace |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyUploadReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyUploadReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyUploadReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderUin", wireType)
			}
			m.SenderUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SenderUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecverUin", wireType)
			}
			m.RecverUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecverUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileType", wireType)
			}
			m.FileType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes_10MMd5", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bytes_10MMd5 = append(m.Bytes_10MMd5[:0], dAtA[iNdEx:postIndex]...)
			if m.Bytes_10MMd5 == nil {
				m.Bytes_10MMd5 = []byte{}
			}
			iNdEx = postIndex
		case 70:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalFilepath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalFilepath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 80:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DangerLevel", wireType)
			}
			m.DangerLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DangerLevel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 90:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSpace", wireType)
			}
			m.TotalSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSpace |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyUploadReqV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyUploadReqV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyUploadReqV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderUin", wireType)
			}
			m.SenderUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SenderUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecverUin", wireType)
			}
			m.RecverUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecverUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes_10MMd5", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bytes_10MMd5 = append(m.Bytes_10MMd5[:0], dAtA[iNdEx:postIndex]...)
			if m.Bytes_10MMd5 == nil {
				m.Bytes_10MMd5 = []byte{}
			}
			iNdEx = postIndex
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes_3Sha", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bytes_3Sha = append(m.Bytes_3Sha[:0], dAtA[iNdEx:postIndex]...)
			if m.Bytes_3Sha == nil {
				m.Bytes_3Sha = []byte{}
			}
			iNdEx = postIndex
		case 70:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalFilepath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalFilepath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 80:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DangerLevel", wireType)
			}
			m.DangerLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DangerLevel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 90:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSpace", wireType)
			}
			m.TotalSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSpace |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyUploadReqV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyUploadReqV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyUploadReqV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderUin", wireType)
			}
			m.SenderUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SenderUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecverUin", wireType)
			}
			m.RecverUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecverUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes_10MMd5", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bytes_10MMd5 = append(m.Bytes_10MMd5[:0], dAtA[iNdEx:postIndex]...)
			if m.Bytes_10MMd5 == nil {
				m.Bytes_10MMd5 = []byte{}
			}
			iNdEx = postIndex
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sha", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sha = append(m.Sha[:0], dAtA[iNdEx:postIndex]...)
			if m.Sha == nil {
				m.Sha = []byte{}
			}
			iNdEx = postIndex
		case 70:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalFilepath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalFilepath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 80:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DangerLevel", wireType)
			}
			m.DangerLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DangerLevel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 90:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSpace", wireType)
			}
			m.TotalSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSpace |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyUploadRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyUploadRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyUploadRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetCode", wireType)
			}
			m.RetCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSpace", wireType)
			}
			m.TotalSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSpace |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedSpace", wireType)
			}
			m.UsedSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsedSpace |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadedSize", wireType)
			}
			m.UploadedSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UploadedSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UploadIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 70:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadDomain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UploadDomain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 80:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadPort", wireType)
			}
			m.UploadPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UploadPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 90:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = append(m.Uuid[:0], dAtA[iNdEx:postIndex]...)
			if m.Uuid == nil {
				m.Uuid = []byte{}
			}
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UploadKey = append(m.UploadKey[:0], dAtA[iNdEx:postIndex]...)
			if m.UploadKey == nil {
				m.UploadKey = []byte{}
			}
			iNdEx = postIndex
		case 110:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoolFileExist", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BoolFileExist = bool(v != 0)
		case 120:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackSize", wireType)
			}
			m.PackSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PackSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 130:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadipList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UploadipList = append(m.UploadipList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyUploadRspV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyUploadRspV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyUploadRspV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetCode", wireType)
			}
			m.RetCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSpace", wireType)
			}
			m.TotalSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSpace |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedSpace", wireType)
			}
			m.UsedSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsedSpace |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadedSize", wireType)
			}
			m.UploadedSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UploadedSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UploadIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 70:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadDomain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UploadDomain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 80:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadPort", wireType)
			}
			m.UploadPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UploadPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 90:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = append(m.Uuid[:0], dAtA[iNdEx:postIndex]...)
			if m.Uuid == nil {
				m.Uuid = []byte{}
			}
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UploadKey = append(m.UploadKey[:0], dAtA[iNdEx:postIndex]...)
			if m.UploadKey == nil {
				m.UploadKey = []byte{}
			}
			iNdEx = postIndex
		case 110:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoolFileExist", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BoolFileExist = bool(v != 0)
		case 120:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackSize", wireType)
			}
			m.PackSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PackSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 130:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadipList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UploadipList = append(m.UploadipList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 140:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpsvrApiVer", wireType)
			}
			m.HttpsvrApiVer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HttpsvrApiVer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 141:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sha", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sha = append(m.Sha[:0], dAtA[iNdEx:postIndex]...)
			if m.Sha == nil {
				m.Sha = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyUploadRspV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyUploadRspV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyUploadRspV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetCode", wireType)
			}
			m.RetCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSpace", wireType)
			}
			m.TotalSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSpace |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedSpace", wireType)
			}
			m.UsedSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsedSpace |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadedSize", wireType)
			}
			m.UploadedSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UploadedSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UploadIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 70:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadDomain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UploadDomain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 80:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadPort", wireType)
			}
			m.UploadPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UploadPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 90:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = append(m.Uuid[:0], dAtA[iNdEx:postIndex]...)
			if m.Uuid == nil {
				m.Uuid = []byte{}
			}
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UploadKey = append(m.UploadKey[:0], dAtA[iNdEx:postIndex]...)
			if m.UploadKey == nil {
				m.UploadKey = []byte{}
			}
			iNdEx = postIndex
		case 110:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoolFileExist", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BoolFileExist = bool(v != 0)
		case 120:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackSize", wireType)
			}
			m.PackSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PackSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 130:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadipList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UploadipList = append(m.UploadipList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelMessageReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelMessageReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelMessageReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UinSender", wireType)
			}
			m.UinSender = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UinSender |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UinReceiver", wireType)
			}
			m.UinReceiver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UinReceiver |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Random", wireType)
			}
			m.Random = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Random |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNo", wireType)
			}
			m.SeqNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNo |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteFileReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteFileReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteFileReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uin", wireType)
			}
			m.Uin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerUin", wireType)
			}
			m.PeerUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteType", wireType)
			}
			m.DeleteType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeleteType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = append(m.Uuid[:0], dAtA[iNdEx:postIndex]...)
			if m.Uuid == nil {
				m.Uuid = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteFileRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteFileRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteFileRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetCode", wireType)
			}
			m.RetCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownloadInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownloadInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownloadInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DownloadKey = append(m.DownloadKey[:0], dAtA[iNdEx:postIndex]...)
			if m.DownloadKey == nil {
				m.DownloadKey = []byte{}
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DownloadIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadDomain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DownloadDomain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DownloadUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadipList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DownloadipList = append(m.DownloadipList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 70:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownloadSuccReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownloadSuccReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownloadSuccReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uin", wireType)
			}
			m.Uin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = append(m.Uuid[:0], dAtA[iNdEx:postIndex]...)
			if m.Uuid == nil {
				m.Uuid = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownloadSuccRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownloadSuccRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownloadSuccRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetCode", wireType)
			}
			m.RetCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownStat", wireType)
			}
			m.DownStat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DownStat |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtensionReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtensionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtensionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPhonenum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstPhonenum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneConvertType", wireType)
			}
			m.PhoneConvertType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PhoneConvertType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sig = append(m.Sig[:0], dAtA[iNdEx:postIndex]...)
			if m.Sig == nil {
				m.Sig = []byte{}
			}
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteId", wireType)
			}
			m.RouteId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 90100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelMessageReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DelMessageReq == nil {
				m.DelMessageReq = &DelMessageReq{}
			}
			if err := m.DelMessageReq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 90200:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadUrlType", wireType)
			}
			m.DownloadUrlType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DownloadUrlType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 90300:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PttFormat", wireType)
			}
			m.PttFormat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PttFormat |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 90400:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNeedInnerIp", wireType)
			}
			m.IsNeedInnerIp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsNeedInnerIp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 90500:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetType", wireType)
			}
			m.NetType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 90600:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoiceType", wireType)
			}
			m.VoiceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VoiceType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 90700:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileType", wireType)
			}
			m.FileType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 90800:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PttTime", wireType)
			}
			m.PttTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PttTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtensionRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtensionRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtensionRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uin", wireType)
			}
			m.Uin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DangerEvel", wireType)
			}
			m.DangerEvel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DangerEvel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LifeTime", wireType)
			}
			m.LifeTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LifeTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadTime", wireType)
			}
			m.UploadTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UploadTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = append(m.Uuid[:0], dAtA[iNdEx:postIndex]...)
			if m.Uuid == nil {
				m.Uuid = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 90:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbsFileType", wireType)
			}
			m.AbsFileType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AbsFileType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes_10MMd5", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bytes_10MMd5 = append(m.Bytes_10MMd5[:0], dAtA[iNdEx:postIndex]...)
			if m.Bytes_10MMd5 == nil {
				m.Bytes_10MMd5 = []byte{}
			}
			iNdEx = postIndex
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sha", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sha = append(m.Sha[:0], dAtA[iNdEx:postIndex]...)
			if m.Sha == nil {
				m.Sha = []byte{}
			}
			iNdEx = postIndex
		case 110:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientType", wireType)
			}
			m.ClientType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 120:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerUin", wireType)
			}
			m.OwnerUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 121:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerUin", wireType)
			}
			m.PeerUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 130:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpireTime", wireType)
			}
			m.ExpireTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpireTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileQueryReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileQueryReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileQueryReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uin", wireType)
			}
			m.Uin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = append(m.Uuid[:0], dAtA[iNdEx:postIndex]...)
			if m.Uuid == nil {
				m.Uuid = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileQueryRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileQueryRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileQueryRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetCode", wireType)
			}
			m.RetCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileInfo == nil {
				m.FileInfo = &FileInfo{}
			}
			if err := m.FileInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecallFileReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecallFileReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecallFileReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uin", wireType)
			}
			m.Uin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = append(m.Uuid[:0], dAtA[iNdEx:postIndex]...)
			if m.Uuid == nil {
				m.Uuid = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecallFileRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecallFileRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecallFileRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetCode", wireType)
			}
			m.RetCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecvListQueryReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecvListQueryReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecvListQueryReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uin", wireType)
			}
			m.Uin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeginIndex", wireType)
			}
			m.BeginIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeginIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqCount", wireType)
			}
			m.ReqCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecvListQueryRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecvListQueryRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecvListQueryRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetCode", wireType)
			}
			m.RetCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileTotCount", wireType)
			}
			m.FileTotCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileTotCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeginIndex", wireType)
			}
			m.BeginIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeginIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RspFileCount", wireType)
			}
			m.RspFileCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RspFileCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEnd", wireType)
			}
			m.IsEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsEnd |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileList = append(m.FileList, &FileInfo{})
			if err := m.FileList[len(m.FileList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RenewFileReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RenewFileReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RenewFileReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uin", wireType)
			}
			m.Uin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = append(m.Uuid[:0], dAtA[iNdEx:postIndex]...)
			if m.Uuid == nil {
				m.Uuid = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddTtl", wireType)
			}
			m.AddTtl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddTtl |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RenewFileRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RenewFileRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RenewFileRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetCode", wireType)
			}
			m.RetCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C346ReqBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C346ReqBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C346ReqBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			m.Cmd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cmd |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecvListQueryReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecvListQueryReq == nil {
				m.RecvListQueryReq = &RecvListQueryReq{}
			}
			if err := m.RecvListQueryReq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendListQueryReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SendListQueryReq == nil {
				m.SendListQueryReq = &SendListQueryReq{}
			}
			if err := m.SendListQueryReq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenewFileReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RenewFileReq == nil {
				m.RenewFileReq = &RenewFileReq{}
			}
			if err := m.RenewFileReq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecallFileReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecallFileReq == nil {
				m.RecallFileReq = &RecallFileReq{}
			}
			if err := m.RecallFileReq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyUploadReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApplyUploadReq == nil {
				m.ApplyUploadReq = &ApplyUploadReq{}
			}
			if err := m.ApplyUploadReq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyUploadHitReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApplyUploadHitReq == nil {
				m.ApplyUploadHitReq = &ApplyUploadHitReq{}
			}
			if err := m.ApplyUploadHitReq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyForwardFileReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApplyForwardFileReq == nil {
				m.ApplyForwardFileReq = &ApplyForwardFileReq{}
			}
			if err := m.ApplyForwardFileReq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadSuccReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UploadSuccReq == nil {
				m.UploadSuccReq = &UploadSuccReq{}
			}
			if err := m.UploadSuccReq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteFileReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeleteFileReq == nil {
				m.DeleteFileReq = &DeleteFileReq{}
			}
			if err := m.DeleteFileReq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadSuccReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DownloadSuccReq == nil {
				m.DownloadSuccReq = &DownloadSuccReq{}
			}
			if err := m.DownloadSuccReq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyDownloadAbsReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApplyDownloadAbsReq == nil {
				m.ApplyDownloadAbsReq = &ApplyDownloadAbsReq{}
			}
			if err := m.ApplyDownloadAbsReq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyDownloadReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApplyDownloadReq == nil {
				m.ApplyDownloadReq = &ApplyDownloadReq{}
			}
			if err := m.ApplyDownloadReq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyListDownloadReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApplyListDownloadReq == nil {
				m.ApplyListDownloadReq = &ApplyListDownloadReq{}
			}
			if err := m.ApplyListDownloadReq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileQueryReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileQueryReq == nil {
				m.FileQueryReq = &FileQueryReq{}
			}
			if err := m.FileQueryReq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyCopyFromReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApplyCopyFromReq == nil {
				m.ApplyCopyFromReq = &ApplyCopyFromReq{}
			}
			if err := m.ApplyCopyFromReq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyUploadReqV2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApplyUploadReqV2 == nil {
				m.ApplyUploadReqV2 = &ApplyUploadReqV2{}
			}
			if err := m.ApplyUploadReqV2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyUploadReqV3", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApplyUploadReqV3 == nil {
				m.ApplyUploadReqV3 = &ApplyUploadReqV3{}
			}
			if err := m.ApplyUploadReqV3.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyUploadHitReqV2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApplyUploadHitReqV2 == nil {
				m.ApplyUploadHitReqV2 = &ApplyUploadHitReqV2{}
			}
			if err := m.ApplyUploadHitReqV2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyUploadHitReqV3", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApplyUploadHitReqV3 == nil {
				m.ApplyUploadHitReqV3 = &ApplyUploadHitReqV3{}
			}
			if err := m.ApplyUploadHitReqV3.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BusinessId", wireType)
			}
			m.BusinessId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BusinessId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 102:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientType", wireType)
			}
			m.ClientType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 90000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyCopyToReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApplyCopyToReq == nil {
				m.ApplyCopyToReq = &ApplyCopyToReq{}
			}
			if err := m.ApplyCopyToReq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 90002:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyGetTrafficReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApplyGetTrafficReq == nil {
				m.ApplyGetTrafficReq = &ApplyGetTrafficReq{}
			}
			if err := m.ApplyGetTrafficReq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 99999:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtensionReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExtensionReq == nil {
				m.ExtensionReq = &ExtensionReq{}
			}
			if err := m.ExtensionReq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C346RspBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C346RspBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C346RspBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			m.Cmd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cmd |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecvListQueryRsp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecvListQueryRsp == nil {
				m.RecvListQueryRsp = &RecvListQueryRsp{}
			}
			if err := m.RecvListQueryRsp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendListQueryRsp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SendListQueryRsp == nil {
				m.SendListQueryRsp = &SendListQueryRsp{}
			}
			if err := m.SendListQueryRsp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenewFileRsp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RenewFileRsp == nil {
				m.RenewFileRsp = &RenewFileRsp{}
			}
			if err := m.RenewFileRsp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecallFileRsp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecallFileRsp == nil {
				m.RecallFileRsp = &RecallFileRsp{}
			}
			if err := m.RecallFileRsp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyUploadRsp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApplyUploadRsp == nil {
				m.ApplyUploadRsp = &ApplyUploadRsp{}
			}
			if err := m.ApplyUploadRsp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyUploadHitRsp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApplyUploadHitRsp == nil {
				m.ApplyUploadHitRsp = &ApplyUploadHitRsp{}
			}
			if err := m.ApplyUploadHitRsp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyForwardFileRsp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApplyForwardFileRsp == nil {
				m.ApplyForwardFileRsp = &ApplyForwardFileRsp{}
			}
			if err := m.ApplyForwardFileRsp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadSuccRsp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UploadSuccRsp == nil {
				m.UploadSuccRsp = &UploadSuccRsp{}
			}
			if err := m.UploadSuccRsp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteFileRsp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeleteFileRsp == nil {
				m.DeleteFileRsp = &DeleteFileRsp{}
			}
			if err := m.DeleteFileRsp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadSuccRsp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DownloadSuccRsp == nil {
				m.DownloadSuccRsp = &DownloadSuccRsp{}
			}
			if err := m.DownloadSuccRsp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyDownloadAbsRsp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApplyDownloadAbsRsp == nil {
				m.ApplyDownloadAbsRsp = &ApplyDownloadAbsRsp{}
			}
			if err := m.ApplyDownloadAbsRsp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyDownloadRsp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApplyDownloadRsp == nil {
				m.ApplyDownloadRsp = &ApplyDownloadRsp{}
			}
			if err := m.ApplyDownloadRsp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyListDownloadRsp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApplyListDownloadRsp == nil {
				m.ApplyListDownloadRsp = &ApplyListDownloadRsp{}
			}
			if err := m.ApplyListDownloadRsp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileQueryRsp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileQueryRsp == nil {
				m.FileQueryRsp = &FileQueryRsp{}
			}
			if err := m.FileQueryRsp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyCopyFromRsp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApplyCopyFromRsp == nil {
				m.ApplyCopyFromRsp = &ApplyCopyFromRsp{}
			}
			if err := m.ApplyCopyFromRsp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyUploadRspV2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApplyUploadRspV2 == nil {
				m.ApplyUploadRspV2 = &ApplyUploadRspV2{}
			}
			if err := m.ApplyUploadRspV2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyUploadRspV3", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApplyUploadRspV3 == nil {
				m.ApplyUploadRspV3 = &ApplyUploadRspV3{}
			}
			if err := m.ApplyUploadRspV3.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyUploadHitRspV2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApplyUploadHitRspV2 == nil {
				m.ApplyUploadHitRspV2 = &ApplyUploadHitRspV2{}
			}
			if err := m.ApplyUploadHitRspV2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyUploadHitRspV3", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApplyUploadHitRspV3 == nil {
				m.ApplyUploadHitRspV3 = &ApplyUploadHitRspV3{}
			}
			if err := m.ApplyUploadHitRspV3.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BusinessId", wireType)
			}
			m.BusinessId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BusinessId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 102:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientType", wireType)
			}
			m.ClientType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 90000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyCopyToRsp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApplyCopyToRsp == nil {
				m.ApplyCopyToRsp = &ApplyCopyToRsp{}
			}
			if err := m.ApplyCopyToRsp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 90001:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyCleanTrafficRsp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApplyCleanTrafficRsp == nil {
				m.ApplyCleanTrafficRsp = &ApplyCleanTrafficRsp{}
			}
			if err := m.ApplyCleanTrafficRsp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 90002:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyGetTrafficRsp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApplyGetTrafficRsp == nil {
				m.ApplyGetTrafficRsp = &ApplyGetTrafficRsp{}
			}
			if err := m.ApplyGetTrafficRsp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 99999:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtensionRsp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExtensionRsp == nil {
				m.ExtensionRsp = &ExtensionRsp{}
			}
			if err := m.ExtensionRsp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendListQueryReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendListQueryReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendListQueryReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uin", wireType)
			}
			m.Uin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeginIndex", wireType)
			}
			m.BeginIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeginIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqCount", wireType)
			}
			m.ReqCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendListQueryRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendListQueryRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendListQueryRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetCode", wireType)
			}
			m.RetCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileTotCount", wireType)
			}
			m.FileTotCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileTotCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeginIndex", wireType)
			}
			m.BeginIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeginIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RspFileCount", wireType)
			}
			m.RspFileCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RspFileCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEnd", wireType)
			}
			m.IsEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsEnd |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotLimit", wireType)
			}
			m.TotLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotLimit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedLimit", wireType)
			}
			m.UsedLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsedLimit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileList = append(m.FileList, &FileInfo{})
			if err := m.FileList[len(m.FileList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadSuccReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadSuccReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadSuccReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderUin", wireType)
			}
			m.SenderUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SenderUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecverUin", wireType)
			}
			m.RecverUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecverUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = append(m.Uuid[:0], dAtA[iNdEx:postIndex]...)
			if m.Uuid == nil {
				m.Uuid = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadSuccRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadSuccRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadSuccRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetCode", wireType)
			}
			m.RetCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X346
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileInfo == nil {
				m.FileInfo = &FileInfo{}
			}
			if err := m.FileInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X346(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X346
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCmd0X346(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCmd0X346
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCmd0X346
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCmd0X346
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCmd0X346
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCmd0X346
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCmd0X346        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCmd0X346          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCmd0X346 = fmt.Errorf("proto: unexpected end of group")
)
