// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: multimsg.proto

package multimsg

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ExternMsg struct {
	ChannelType int32 `protobuf:"varint,1,opt,name=channelType,proto3" json:"channelType,omitempty"`
}

func (m *ExternMsg) Reset()         { *m = ExternMsg{} }
func (m *ExternMsg) String() string { return proto.CompactTextString(m) }
func (*ExternMsg) ProtoMessage()    {}
func (*ExternMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_05dd78c3d781efd4, []int{0}
}
func (m *ExternMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExternMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExternMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExternMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExternMsg.Merge(m, src)
}
func (m *ExternMsg) XXX_Size() int {
	return m.Size()
}
func (m *ExternMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_ExternMsg.DiscardUnknown(m)
}

var xxx_messageInfo_ExternMsg proto.InternalMessageInfo

func (m *ExternMsg) GetChannelType() int32 {
	if m != nil {
		return m.ChannelType
	}
	return 0
}

type MultiMsgApplyDownReq struct {
	MsgResid []byte `protobuf:"bytes,1,opt,name=msgResid,proto3" json:"msgResid,omitempty"`
	MsgType  int32  `protobuf:"varint,2,opt,name=msgType,proto3" json:"msgType,omitempty"`
	SrcUin   int64  `protobuf:"varint,3,opt,name=srcUin,proto3" json:"srcUin,omitempty"`
}

func (m *MultiMsgApplyDownReq) Reset()         { *m = MultiMsgApplyDownReq{} }
func (m *MultiMsgApplyDownReq) String() string { return proto.CompactTextString(m) }
func (*MultiMsgApplyDownReq) ProtoMessage()    {}
func (*MultiMsgApplyDownReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_05dd78c3d781efd4, []int{1}
}
func (m *MultiMsgApplyDownReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiMsgApplyDownReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiMsgApplyDownReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiMsgApplyDownReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiMsgApplyDownReq.Merge(m, src)
}
func (m *MultiMsgApplyDownReq) XXX_Size() int {
	return m.Size()
}
func (m *MultiMsgApplyDownReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiMsgApplyDownReq.DiscardUnknown(m)
}

var xxx_messageInfo_MultiMsgApplyDownReq proto.InternalMessageInfo

func (m *MultiMsgApplyDownReq) GetMsgResid() []byte {
	if m != nil {
		return m.MsgResid
	}
	return nil
}

func (m *MultiMsgApplyDownReq) GetMsgType() int32 {
	if m != nil {
		return m.MsgType
	}
	return 0
}

func (m *MultiMsgApplyDownReq) GetSrcUin() int64 {
	if m != nil {
		return m.SrcUin
	}
	return 0
}

type MultiMsgApplyDownRsp struct {
	Result           int32      `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	ThumbDownPara    []byte     `protobuf:"bytes,2,opt,name=thumbDownPara,proto3" json:"thumbDownPara,omitempty"`
	MsgKey           []byte     `protobuf:"bytes,3,opt,name=msgKey,proto3" json:"msgKey,omitempty"`
	Uint32DownIp     []int32    `protobuf:"varint,4,rep,packed,name=uint32DownIp,proto3" json:"uint32DownIp,omitempty"`
	Uint32DownPort   []int32    `protobuf:"varint,5,rep,packed,name=uint32DownPort,proto3" json:"uint32DownPort,omitempty"`
	MsgResid         []byte     `protobuf:"bytes,6,opt,name=msgResid,proto3" json:"msgResid,omitempty"`
	MsgExternInfo    *ExternMsg `protobuf:"bytes,7,opt,name=msgExternInfo,proto3" json:"msgExternInfo,omitempty"`
	BytesDownIpV6    [][]byte   `protobuf:"bytes,8,rep,name=bytesDownIpV6,proto3" json:"bytesDownIpV6,omitempty"`
	Uint32DownV6Port []int32    `protobuf:"varint,9,rep,packed,name=uint32DownV6Port,proto3" json:"uint32DownV6Port,omitempty"`
}

func (m *MultiMsgApplyDownRsp) Reset()         { *m = MultiMsgApplyDownRsp{} }
func (m *MultiMsgApplyDownRsp) String() string { return proto.CompactTextString(m) }
func (*MultiMsgApplyDownRsp) ProtoMessage()    {}
func (*MultiMsgApplyDownRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_05dd78c3d781efd4, []int{2}
}
func (m *MultiMsgApplyDownRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiMsgApplyDownRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiMsgApplyDownRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiMsgApplyDownRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiMsgApplyDownRsp.Merge(m, src)
}
func (m *MultiMsgApplyDownRsp) XXX_Size() int {
	return m.Size()
}
func (m *MultiMsgApplyDownRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiMsgApplyDownRsp.DiscardUnknown(m)
}

var xxx_messageInfo_MultiMsgApplyDownRsp proto.InternalMessageInfo

func (m *MultiMsgApplyDownRsp) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

func (m *MultiMsgApplyDownRsp) GetThumbDownPara() []byte {
	if m != nil {
		return m.ThumbDownPara
	}
	return nil
}

func (m *MultiMsgApplyDownRsp) GetMsgKey() []byte {
	if m != nil {
		return m.MsgKey
	}
	return nil
}

func (m *MultiMsgApplyDownRsp) GetUint32DownIp() []int32 {
	if m != nil {
		return m.Uint32DownIp
	}
	return nil
}

func (m *MultiMsgApplyDownRsp) GetUint32DownPort() []int32 {
	if m != nil {
		return m.Uint32DownPort
	}
	return nil
}

func (m *MultiMsgApplyDownRsp) GetMsgResid() []byte {
	if m != nil {
		return m.MsgResid
	}
	return nil
}

func (m *MultiMsgApplyDownRsp) GetMsgExternInfo() *ExternMsg {
	if m != nil {
		return m.MsgExternInfo
	}
	return nil
}

func (m *MultiMsgApplyDownRsp) GetBytesDownIpV6() [][]byte {
	if m != nil {
		return m.BytesDownIpV6
	}
	return nil
}

func (m *MultiMsgApplyDownRsp) GetUint32DownV6Port() []int32 {
	if m != nil {
		return m.Uint32DownV6Port
	}
	return nil
}

type MultiMsgApplyUpReq struct {
	DstUin  int64  `protobuf:"varint,1,opt,name=dstUin,proto3" json:"dstUin,omitempty"`
	MsgSize int64  `protobuf:"varint,2,opt,name=msgSize,proto3" json:"msgSize,omitempty"`
	MsgMd5  []byte `protobuf:"bytes,3,opt,name=msgMd5,proto3" json:"msgMd5,omitempty"`
	MsgType int32  `protobuf:"varint,4,opt,name=msgType,proto3" json:"msgType,omitempty"`
	ApplyId int32  `protobuf:"varint,5,opt,name=applyId,proto3" json:"applyId,omitempty"`
}

func (m *MultiMsgApplyUpReq) Reset()         { *m = MultiMsgApplyUpReq{} }
func (m *MultiMsgApplyUpReq) String() string { return proto.CompactTextString(m) }
func (*MultiMsgApplyUpReq) ProtoMessage()    {}
func (*MultiMsgApplyUpReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_05dd78c3d781efd4, []int{3}
}
func (m *MultiMsgApplyUpReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiMsgApplyUpReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiMsgApplyUpReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiMsgApplyUpReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiMsgApplyUpReq.Merge(m, src)
}
func (m *MultiMsgApplyUpReq) XXX_Size() int {
	return m.Size()
}
func (m *MultiMsgApplyUpReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiMsgApplyUpReq.DiscardUnknown(m)
}

var xxx_messageInfo_MultiMsgApplyUpReq proto.InternalMessageInfo

func (m *MultiMsgApplyUpReq) GetDstUin() int64 {
	if m != nil {
		return m.DstUin
	}
	return 0
}

func (m *MultiMsgApplyUpReq) GetMsgSize() int64 {
	if m != nil {
		return m.MsgSize
	}
	return 0
}

func (m *MultiMsgApplyUpReq) GetMsgMd5() []byte {
	if m != nil {
		return m.MsgMd5
	}
	return nil
}

func (m *MultiMsgApplyUpReq) GetMsgType() int32 {
	if m != nil {
		return m.MsgType
	}
	return 0
}

func (m *MultiMsgApplyUpReq) GetApplyId() int32 {
	if m != nil {
		return m.ApplyId
	}
	return 0
}

type MultiMsgApplyUpRsp struct {
	Result         int32      `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	MsgResid       string     `protobuf:"bytes,2,opt,name=msgResid,proto3" json:"msgResid,omitempty"`
	MsgUkey        []byte     `protobuf:"bytes,3,opt,name=msgUkey,proto3" json:"msgUkey,omitempty"`
	Uint32UpIp     []int32    `protobuf:"varint,4,rep,packed,name=uint32UpIp,proto3" json:"uint32UpIp,omitempty"`
	Uint32UpPort   []int32    `protobuf:"varint,5,rep,packed,name=uint32UpPort,proto3" json:"uint32UpPort,omitempty"`
	BlockSize      int64      `protobuf:"varint,6,opt,name=blockSize,proto3" json:"blockSize,omitempty"`
	UpOffset       int64      `protobuf:"varint,7,opt,name=upOffset,proto3" json:"upOffset,omitempty"`
	ApplyId        int32      `protobuf:"varint,8,opt,name=applyId,proto3" json:"applyId,omitempty"`
	MsgKey         []byte     `protobuf:"bytes,9,opt,name=msgKey,proto3" json:"msgKey,omitempty"`
	MsgSig         []byte     `protobuf:"bytes,10,opt,name=msgSig,proto3" json:"msgSig,omitempty"`
	MsgExternInfo  *ExternMsg `protobuf:"bytes,11,opt,name=msgExternInfo,proto3" json:"msgExternInfo,omitempty"`
	BytesUpIpV6    [][]byte   `protobuf:"bytes,12,rep,name=bytesUpIpV6,proto3" json:"bytesUpIpV6,omitempty"`
	Uint32UpV6Port []int32    `protobuf:"varint,13,rep,packed,name=uint32UpV6Port,proto3" json:"uint32UpV6Port,omitempty"`
}

func (m *MultiMsgApplyUpRsp) Reset()         { *m = MultiMsgApplyUpRsp{} }
func (m *MultiMsgApplyUpRsp) String() string { return proto.CompactTextString(m) }
func (*MultiMsgApplyUpRsp) ProtoMessage()    {}
func (*MultiMsgApplyUpRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_05dd78c3d781efd4, []int{4}
}
func (m *MultiMsgApplyUpRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiMsgApplyUpRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiMsgApplyUpRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiMsgApplyUpRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiMsgApplyUpRsp.Merge(m, src)
}
func (m *MultiMsgApplyUpRsp) XXX_Size() int {
	return m.Size()
}
func (m *MultiMsgApplyUpRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiMsgApplyUpRsp.DiscardUnknown(m)
}

var xxx_messageInfo_MultiMsgApplyUpRsp proto.InternalMessageInfo

func (m *MultiMsgApplyUpRsp) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

func (m *MultiMsgApplyUpRsp) GetMsgResid() string {
	if m != nil {
		return m.MsgResid
	}
	return ""
}

func (m *MultiMsgApplyUpRsp) GetMsgUkey() []byte {
	if m != nil {
		return m.MsgUkey
	}
	return nil
}

func (m *MultiMsgApplyUpRsp) GetUint32UpIp() []int32 {
	if m != nil {
		return m.Uint32UpIp
	}
	return nil
}

func (m *MultiMsgApplyUpRsp) GetUint32UpPort() []int32 {
	if m != nil {
		return m.Uint32UpPort
	}
	return nil
}

func (m *MultiMsgApplyUpRsp) GetBlockSize() int64 {
	if m != nil {
		return m.BlockSize
	}
	return 0
}

func (m *MultiMsgApplyUpRsp) GetUpOffset() int64 {
	if m != nil {
		return m.UpOffset
	}
	return 0
}

func (m *MultiMsgApplyUpRsp) GetApplyId() int32 {
	if m != nil {
		return m.ApplyId
	}
	return 0
}

func (m *MultiMsgApplyUpRsp) GetMsgKey() []byte {
	if m != nil {
		return m.MsgKey
	}
	return nil
}

func (m *MultiMsgApplyUpRsp) GetMsgSig() []byte {
	if m != nil {
		return m.MsgSig
	}
	return nil
}

func (m *MultiMsgApplyUpRsp) GetMsgExternInfo() *ExternMsg {
	if m != nil {
		return m.MsgExternInfo
	}
	return nil
}

func (m *MultiMsgApplyUpRsp) GetBytesUpIpV6() [][]byte {
	if m != nil {
		return m.BytesUpIpV6
	}
	return nil
}

func (m *MultiMsgApplyUpRsp) GetUint32UpV6Port() []int32 {
	if m != nil {
		return m.Uint32UpV6Port
	}
	return nil
}

type MultiReqBody struct {
	Subcmd               int32                   `protobuf:"varint,1,opt,name=subcmd,proto3" json:"subcmd,omitempty"`
	TermType             int32                   `protobuf:"varint,2,opt,name=termType,proto3" json:"termType,omitempty"`
	PlatformType         int32                   `protobuf:"varint,3,opt,name=platformType,proto3" json:"platformType,omitempty"`
	NetType              int32                   `protobuf:"varint,4,opt,name=netType,proto3" json:"netType,omitempty"`
	BuildVer             string                  `protobuf:"bytes,5,opt,name=buildVer,proto3" json:"buildVer,omitempty"`
	MultimsgApplyupReq   []*MultiMsgApplyUpReq   `protobuf:"bytes,6,rep,name=multimsgApplyupReq,proto3" json:"multimsgApplyupReq,omitempty"`
	MultimsgApplydownReq []*MultiMsgApplyDownReq `protobuf:"bytes,7,rep,name=multimsgApplydownReq,proto3" json:"multimsgApplydownReq,omitempty"`
	BuType               int32                   `protobuf:"varint,8,opt,name=buType,proto3" json:"buType,omitempty"`
	ReqChannelType       int32                   `protobuf:"varint,9,opt,name=reqChannelType,proto3" json:"reqChannelType,omitempty"`
}

func (m *MultiReqBody) Reset()         { *m = MultiReqBody{} }
func (m *MultiReqBody) String() string { return proto.CompactTextString(m) }
func (*MultiReqBody) ProtoMessage()    {}
func (*MultiReqBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_05dd78c3d781efd4, []int{5}
}
func (m *MultiReqBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiReqBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiReqBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiReqBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiReqBody.Merge(m, src)
}
func (m *MultiReqBody) XXX_Size() int {
	return m.Size()
}
func (m *MultiReqBody) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiReqBody.DiscardUnknown(m)
}

var xxx_messageInfo_MultiReqBody proto.InternalMessageInfo

func (m *MultiReqBody) GetSubcmd() int32 {
	if m != nil {
		return m.Subcmd
	}
	return 0
}

func (m *MultiReqBody) GetTermType() int32 {
	if m != nil {
		return m.TermType
	}
	return 0
}

func (m *MultiReqBody) GetPlatformType() int32 {
	if m != nil {
		return m.PlatformType
	}
	return 0
}

func (m *MultiReqBody) GetNetType() int32 {
	if m != nil {
		return m.NetType
	}
	return 0
}

func (m *MultiReqBody) GetBuildVer() string {
	if m != nil {
		return m.BuildVer
	}
	return ""
}

func (m *MultiReqBody) GetMultimsgApplyupReq() []*MultiMsgApplyUpReq {
	if m != nil {
		return m.MultimsgApplyupReq
	}
	return nil
}

func (m *MultiReqBody) GetMultimsgApplydownReq() []*MultiMsgApplyDownReq {
	if m != nil {
		return m.MultimsgApplydownReq
	}
	return nil
}

func (m *MultiReqBody) GetBuType() int32 {
	if m != nil {
		return m.BuType
	}
	return 0
}

func (m *MultiReqBody) GetReqChannelType() int32 {
	if m != nil {
		return m.ReqChannelType
	}
	return 0
}

type MultiRspBody struct {
	Subcmd               int32                   `protobuf:"varint,1,opt,name=subcmd,proto3" json:"subcmd,omitempty"`
	MultimsgApplyupRsp   []*MultiMsgApplyUpRsp   `protobuf:"bytes,2,rep,name=multimsgApplyupRsp,proto3" json:"multimsgApplyupRsp,omitempty"`
	MultimsgApplydownRsp []*MultiMsgApplyDownRsp `protobuf:"bytes,3,rep,name=multimsgApplydownRsp,proto3" json:"multimsgApplydownRsp,omitempty"`
}

func (m *MultiRspBody) Reset()         { *m = MultiRspBody{} }
func (m *MultiRspBody) String() string { return proto.CompactTextString(m) }
func (*MultiRspBody) ProtoMessage()    {}
func (*MultiRspBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_05dd78c3d781efd4, []int{6}
}
func (m *MultiRspBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiRspBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiRspBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiRspBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiRspBody.Merge(m, src)
}
func (m *MultiRspBody) XXX_Size() int {
	return m.Size()
}
func (m *MultiRspBody) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiRspBody.DiscardUnknown(m)
}

var xxx_messageInfo_MultiRspBody proto.InternalMessageInfo

func (m *MultiRspBody) GetSubcmd() int32 {
	if m != nil {
		return m.Subcmd
	}
	return 0
}

func (m *MultiRspBody) GetMultimsgApplyupRsp() []*MultiMsgApplyUpRsp {
	if m != nil {
		return m.MultimsgApplyupRsp
	}
	return nil
}

func (m *MultiRspBody) GetMultimsgApplydownRsp() []*MultiMsgApplyDownRsp {
	if m != nil {
		return m.MultimsgApplydownRsp
	}
	return nil
}

func init() {
	proto.RegisterType((*ExternMsg)(nil), "ExternMsg")
	proto.RegisterType((*MultiMsgApplyDownReq)(nil), "MultiMsgApplyDownReq")
	proto.RegisterType((*MultiMsgApplyDownRsp)(nil), "MultiMsgApplyDownRsp")
	proto.RegisterType((*MultiMsgApplyUpReq)(nil), "MultiMsgApplyUpReq")
	proto.RegisterType((*MultiMsgApplyUpRsp)(nil), "MultiMsgApplyUpRsp")
	proto.RegisterType((*MultiReqBody)(nil), "MultiReqBody")
	proto.RegisterType((*MultiRspBody)(nil), "MultiRspBody")
}

func init() { proto.RegisterFile("multimsg.proto", fileDescriptor_05dd78c3d781efd4) }

var fileDescriptor_05dd78c3d781efd4 = []byte{
	// 688 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x55, 0xcd, 0x6e, 0xd3, 0x4c,
	0x14, 0xad, 0xe3, 0x26, 0xa9, 0x6f, 0xd2, 0xea, 0xd3, 0x7c, 0xa5, 0x1a, 0x21, 0x64, 0x59, 0x56,
	0x85, 0x22, 0x24, 0x22, 0xd4, 0xaa, 0xdd, 0xb0, 0xa2, 0x85, 0x45, 0x84, 0x22, 0xaa, 0x29, 0xc9,
	0x82, 0x5d, 0x1c, 0x4f, 0x5c, 0xab, 0xfe, 0x99, 0x7a, 0x6c, 0x41, 0x78, 0x0a, 0xc4, 0x43, 0xf0,
	0x08, 0x3c, 0x03, 0xcb, 0x2e, 0xbb, 0x44, 0xed, 0x96, 0x87, 0x40, 0x33, 0xfe, 0xc9, 0xb8, 0x71,
	0xcb, 0xf2, 0x1c, 0xdf, 0x3b, 0x73, 0xef, 0x39, 0x27, 0x13, 0xd8, 0x09, 0xb3, 0x20, 0xf5, 0x43,
	0xee, 0x0d, 0x59, 0x12, 0xa7, 0xb1, 0xfd, 0x12, 0x8c, 0x77, 0x5f, 0x52, 0x9a, 0x44, 0x63, 0xee,
	0x21, 0x0b, 0x7a, 0xf3, 0x8b, 0x59, 0x14, 0xd1, 0xe0, 0xe3, 0x92, 0x51, 0xac, 0x59, 0xda, 0xa0,
	0x4d, 0x54, 0xca, 0x76, 0x61, 0x77, 0x2c, 0x0e, 0x18, 0x73, 0xef, 0x0d, 0x63, 0xc1, 0xf2, 0x6d,
	0xfc, 0x39, 0x22, 0xf4, 0x0a, 0x3d, 0x85, 0xad, 0x90, 0x7b, 0x84, 0x72, 0xdf, 0x95, 0x6d, 0x7d,
	0x52, 0x61, 0x84, 0xa1, 0x1b, 0x72, 0x4f, 0x9e, 0xd8, 0x92, 0x27, 0x96, 0x10, 0xed, 0x41, 0x87,
	0x27, 0xf3, 0x89, 0x1f, 0x61, 0xdd, 0xd2, 0x06, 0x3a, 0x29, 0x90, 0x7d, 0xd3, 0x6a, 0xba, 0x86,
	0x33, 0xd1, 0x90, 0x50, 0x9e, 0x05, 0x69, 0x31, 0x5b, 0x81, 0xd0, 0x3e, 0x6c, 0xa7, 0x17, 0x59,
	0xe8, 0x88, 0xba, 0xb3, 0x59, 0x32, 0x93, 0x17, 0xf5, 0x49, 0x9d, 0x14, 0xdd, 0x21, 0xf7, 0xde,
	0xd3, 0xa5, 0xbc, 0xae, 0x4f, 0x0a, 0x84, 0x6c, 0xe8, 0x67, 0x7e, 0x94, 0x1e, 0x1e, 0x88, 0xca,
	0x11, 0xc3, 0x9b, 0x96, 0x3e, 0x68, 0x93, 0x1a, 0x87, 0x9e, 0xc3, 0xce, 0x0a, 0x9f, 0xc5, 0x49,
	0x8a, 0xdb, 0xb2, 0xea, 0x1e, 0x5b, 0x13, 0xa2, 0x73, 0x4f, 0x88, 0x57, 0xb0, 0x1d, 0x72, 0x2f,
	0x97, 0x7b, 0x14, 0x2d, 0x62, 0xdc, 0xb5, 0xb4, 0x41, 0xef, 0x00, 0x86, 0x95, 0x03, 0xa4, 0x5e,
	0x20, 0xf6, 0x72, 0x96, 0x29, 0xe5, 0xf9, 0x10, 0xd3, 0x63, 0xbc, 0x65, 0xe9, 0x62, 0xaf, 0x1a,
	0x89, 0x5e, 0xc0, 0x7f, 0xab, 0x29, 0xa6, 0xc7, 0x72, 0x3a, 0x43, 0x4e, 0xb7, 0xc6, 0xdb, 0xdf,
	0x35, 0x40, 0x35, 0x69, 0x27, 0x4c, 0xf8, 0xb7, 0x07, 0x1d, 0x97, 0xa7, 0xc2, 0x09, 0x2d, 0x77,
	0x22, 0x47, 0x85, 0x77, 0xe7, 0xfe, 0xd7, 0xdc, 0x3b, 0x9d, 0x94, 0xb0, 0x10, 0x73, 0xec, 0x1e,
	0x29, 0x62, 0x8e, 0xdd, 0x23, 0xd5, 0xed, 0xcd, 0xba, 0xdb, 0x18, 0xba, 0x33, 0x71, 0xe3, 0xc8,
	0xc5, 0xed, 0xfc, 0x4b, 0x01, 0xed, 0x1f, 0xfa, 0xfa, 0x50, 0x8f, 0xb8, 0xad, 0x6a, 0x2c, 0xa6,
	0x32, 0xd6, 0xc2, 0x36, 0xb9, 0xac, 0x4c, 0x2e, 0x21, 0x32, 0x01, 0x72, 0x35, 0x26, 0xac, 0xf2,
	0x58, 0x61, 0x56, 0x29, 0x98, 0x30, 0xc5, 0xdf, 0x1a, 0x87, 0x9e, 0x81, 0xe1, 0x04, 0xf1, 0xfc,
	0x52, 0x0a, 0xd2, 0x91, 0x82, 0xac, 0x08, 0x31, 0x57, 0xc6, 0x3e, 0x2c, 0x16, 0x9c, 0xa6, 0xd2,
	0x5a, 0x9d, 0x54, 0x58, 0x5d, 0x7e, 0xab, 0xb6, 0xbc, 0x92, 0x4a, 0xa3, 0x96, 0xca, 0x9c, 0x3f,
	0xf7, 0x3d, 0x0c, 0x15, 0x7f, 0xee, 0x7b, 0xeb, 0x29, 0xea, 0xfd, 0x2b, 0x45, 0x16, 0xf4, 0x64,
	0x60, 0xc4, 0x9a, 0xd3, 0x63, 0xdc, 0x97, 0x19, 0x52, 0xa9, 0x55, 0xba, 0x27, 0xac, 0xc8, 0xcf,
	0xb6, 0x9a, 0xee, 0x92, 0xb5, 0xff, 0xb4, 0xa0, 0x2f, 0x8d, 0x22, 0xf4, 0xea, 0x24, 0x76, 0xe5,
	0x90, 0x3c, 0x73, 0xe6, 0xa1, 0x5b, 0x5a, 0x94, 0x23, 0x21, 0x45, 0x4a, 0x93, 0x50, 0xf9, 0xd1,
	0x57, 0x58, 0x08, 0xcd, 0x82, 0x59, 0xba, 0x88, 0x8b, 0xef, 0xba, 0xfc, 0x5e, 0xe3, 0x84, 0x5c,
	0x11, 0x4d, 0xd5, 0x14, 0x15, 0x50, 0x9c, 0xec, 0x64, 0x7e, 0xe0, 0x4e, 0x69, 0x22, 0x63, 0x64,
	0x90, 0x0a, 0xa3, 0x53, 0x40, 0xe5, 0xf3, 0x26, 0x63, 0x94, 0x89, 0x6c, 0xe3, 0x8e, 0xa5, 0x0f,
	0x7a, 0x07, 0xff, 0x0f, 0xd7, 0x63, 0x4f, 0x1a, 0xca, 0xd1, 0x08, 0x76, 0x6b, 0xac, 0x9b, 0x3f,
	0x71, 0xb8, 0x2b, 0x8f, 0x79, 0x32, 0x6c, 0x7a, 0xff, 0x48, 0x63, 0x8b, 0x50, 0xc7, 0xc9, 0xe4,
	0x12, 0xb9, 0xe7, 0x05, 0x12, 0x72, 0x27, 0xf4, 0xea, 0x54, 0x79, 0x6a, 0x0d, 0xf9, 0xfd, 0x1e,
	0x6b, 0xff, 0xd4, 0x4a, 0xb9, 0x39, 0x7b, 0x54, 0xee, 0x86, 0xc5, 0x39, 0xc3, 0xad, 0x07, 0x16,
	0xe7, 0x8c, 0x34, 0x94, 0x37, 0x2f, 0xce, 0x19, 0xd6, 0x1f, 0x5c, 0x9c, 0x33, 0xd2, 0xd8, 0x72,
	0xb2, 0xff, 0xeb, 0xd6, 0xd4, 0xae, 0x6f, 0x4d, 0xed, 0xf7, 0xad, 0xa9, 0x7d, 0xbb, 0x33, 0x37,
	0xae, 0xef, 0xcc, 0x8d, 0x9b, 0x3b, 0x73, 0xe3, 0x13, 0x0c, 0x5f, 0x97, 0x1d, 0x4e, 0x47, 0xfe,
	0x05, 0x1d, 0xfe, 0x0d, 0x00, 0x00, 0xff, 0xff, 0x22, 0x45, 0xa5, 0xbf, 0x94, 0x06, 0x00, 0x00,
}

func (m *ExternMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExternMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExternMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ChannelType != 0 {
		i = encodeVarintMultimsg(dAtA, i, uint64(m.ChannelType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MultiMsgApplyDownReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiMsgApplyDownReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiMsgApplyDownReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SrcUin != 0 {
		i = encodeVarintMultimsg(dAtA, i, uint64(m.SrcUin))
		i--
		dAtA[i] = 0x18
	}
	if m.MsgType != 0 {
		i = encodeVarintMultimsg(dAtA, i, uint64(m.MsgType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.MsgResid) > 0 {
		i -= len(m.MsgResid)
		copy(dAtA[i:], m.MsgResid)
		i = encodeVarintMultimsg(dAtA, i, uint64(len(m.MsgResid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MultiMsgApplyDownRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiMsgApplyDownRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiMsgApplyDownRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Uint32DownV6Port) > 0 {
		dAtA2 := make([]byte, len(m.Uint32DownV6Port)*10)
		var j1 int
		for _, num1 := range m.Uint32DownV6Port {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintMultimsg(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.BytesDownIpV6) > 0 {
		for iNdEx := len(m.BytesDownIpV6) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.BytesDownIpV6[iNdEx])
			copy(dAtA[i:], m.BytesDownIpV6[iNdEx])
			i = encodeVarintMultimsg(dAtA, i, uint64(len(m.BytesDownIpV6[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.MsgExternInfo != nil {
		{
			size, err := m.MsgExternInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMultimsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.MsgResid) > 0 {
		i -= len(m.MsgResid)
		copy(dAtA[i:], m.MsgResid)
		i = encodeVarintMultimsg(dAtA, i, uint64(len(m.MsgResid)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Uint32DownPort) > 0 {
		dAtA5 := make([]byte, len(m.Uint32DownPort)*10)
		var j4 int
		for _, num1 := range m.Uint32DownPort {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintMultimsg(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Uint32DownIp) > 0 {
		dAtA7 := make([]byte, len(m.Uint32DownIp)*10)
		var j6 int
		for _, num1 := range m.Uint32DownIp {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		i -= j6
		copy(dAtA[i:], dAtA7[:j6])
		i = encodeVarintMultimsg(dAtA, i, uint64(j6))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MsgKey) > 0 {
		i -= len(m.MsgKey)
		copy(dAtA[i:], m.MsgKey)
		i = encodeVarintMultimsg(dAtA, i, uint64(len(m.MsgKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ThumbDownPara) > 0 {
		i -= len(m.ThumbDownPara)
		copy(dAtA[i:], m.ThumbDownPara)
		i = encodeVarintMultimsg(dAtA, i, uint64(len(m.ThumbDownPara)))
		i--
		dAtA[i] = 0x12
	}
	if m.Result != 0 {
		i = encodeVarintMultimsg(dAtA, i, uint64(m.Result))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MultiMsgApplyUpReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiMsgApplyUpReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiMsgApplyUpReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ApplyId != 0 {
		i = encodeVarintMultimsg(dAtA, i, uint64(m.ApplyId))
		i--
		dAtA[i] = 0x28
	}
	if m.MsgType != 0 {
		i = encodeVarintMultimsg(dAtA, i, uint64(m.MsgType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.MsgMd5) > 0 {
		i -= len(m.MsgMd5)
		copy(dAtA[i:], m.MsgMd5)
		i = encodeVarintMultimsg(dAtA, i, uint64(len(m.MsgMd5)))
		i--
		dAtA[i] = 0x1a
	}
	if m.MsgSize != 0 {
		i = encodeVarintMultimsg(dAtA, i, uint64(m.MsgSize))
		i--
		dAtA[i] = 0x10
	}
	if m.DstUin != 0 {
		i = encodeVarintMultimsg(dAtA, i, uint64(m.DstUin))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MultiMsgApplyUpRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiMsgApplyUpRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiMsgApplyUpRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Uint32UpV6Port) > 0 {
		dAtA9 := make([]byte, len(m.Uint32UpV6Port)*10)
		var j8 int
		for _, num1 := range m.Uint32UpV6Port {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		i -= j8
		copy(dAtA[i:], dAtA9[:j8])
		i = encodeVarintMultimsg(dAtA, i, uint64(j8))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.BytesUpIpV6) > 0 {
		for iNdEx := len(m.BytesUpIpV6) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.BytesUpIpV6[iNdEx])
			copy(dAtA[i:], m.BytesUpIpV6[iNdEx])
			i = encodeVarintMultimsg(dAtA, i, uint64(len(m.BytesUpIpV6[iNdEx])))
			i--
			dAtA[i] = 0x62
		}
	}
	if m.MsgExternInfo != nil {
		{
			size, err := m.MsgExternInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMultimsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.MsgSig) > 0 {
		i -= len(m.MsgSig)
		copy(dAtA[i:], m.MsgSig)
		i = encodeVarintMultimsg(dAtA, i, uint64(len(m.MsgSig)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.MsgKey) > 0 {
		i -= len(m.MsgKey)
		copy(dAtA[i:], m.MsgKey)
		i = encodeVarintMultimsg(dAtA, i, uint64(len(m.MsgKey)))
		i--
		dAtA[i] = 0x4a
	}
	if m.ApplyId != 0 {
		i = encodeVarintMultimsg(dAtA, i, uint64(m.ApplyId))
		i--
		dAtA[i] = 0x40
	}
	if m.UpOffset != 0 {
		i = encodeVarintMultimsg(dAtA, i, uint64(m.UpOffset))
		i--
		dAtA[i] = 0x38
	}
	if m.BlockSize != 0 {
		i = encodeVarintMultimsg(dAtA, i, uint64(m.BlockSize))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Uint32UpPort) > 0 {
		dAtA12 := make([]byte, len(m.Uint32UpPort)*10)
		var j11 int
		for _, num1 := range m.Uint32UpPort {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		i -= j11
		copy(dAtA[i:], dAtA12[:j11])
		i = encodeVarintMultimsg(dAtA, i, uint64(j11))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Uint32UpIp) > 0 {
		dAtA14 := make([]byte, len(m.Uint32UpIp)*10)
		var j13 int
		for _, num1 := range m.Uint32UpIp {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		i -= j13
		copy(dAtA[i:], dAtA14[:j13])
		i = encodeVarintMultimsg(dAtA, i, uint64(j13))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MsgUkey) > 0 {
		i -= len(m.MsgUkey)
		copy(dAtA[i:], m.MsgUkey)
		i = encodeVarintMultimsg(dAtA, i, uint64(len(m.MsgUkey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MsgResid) > 0 {
		i -= len(m.MsgResid)
		copy(dAtA[i:], m.MsgResid)
		i = encodeVarintMultimsg(dAtA, i, uint64(len(m.MsgResid)))
		i--
		dAtA[i] = 0x12
	}
	if m.Result != 0 {
		i = encodeVarintMultimsg(dAtA, i, uint64(m.Result))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MultiReqBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiReqBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiReqBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReqChannelType != 0 {
		i = encodeVarintMultimsg(dAtA, i, uint64(m.ReqChannelType))
		i--
		dAtA[i] = 0x48
	}
	if m.BuType != 0 {
		i = encodeVarintMultimsg(dAtA, i, uint64(m.BuType))
		i--
		dAtA[i] = 0x40
	}
	if len(m.MultimsgApplydownReq) > 0 {
		for iNdEx := len(m.MultimsgApplydownReq) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MultimsgApplydownReq[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMultimsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.MultimsgApplyupReq) > 0 {
		for iNdEx := len(m.MultimsgApplyupReq) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MultimsgApplyupReq[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMultimsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.BuildVer) > 0 {
		i -= len(m.BuildVer)
		copy(dAtA[i:], m.BuildVer)
		i = encodeVarintMultimsg(dAtA, i, uint64(len(m.BuildVer)))
		i--
		dAtA[i] = 0x2a
	}
	if m.NetType != 0 {
		i = encodeVarintMultimsg(dAtA, i, uint64(m.NetType))
		i--
		dAtA[i] = 0x20
	}
	if m.PlatformType != 0 {
		i = encodeVarintMultimsg(dAtA, i, uint64(m.PlatformType))
		i--
		dAtA[i] = 0x18
	}
	if m.TermType != 0 {
		i = encodeVarintMultimsg(dAtA, i, uint64(m.TermType))
		i--
		dAtA[i] = 0x10
	}
	if m.Subcmd != 0 {
		i = encodeVarintMultimsg(dAtA, i, uint64(m.Subcmd))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MultiRspBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiRspBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiRspBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MultimsgApplydownRsp) > 0 {
		for iNdEx := len(m.MultimsgApplydownRsp) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MultimsgApplydownRsp[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMultimsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.MultimsgApplyupRsp) > 0 {
		for iNdEx := len(m.MultimsgApplyupRsp) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MultimsgApplyupRsp[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMultimsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Subcmd != 0 {
		i = encodeVarintMultimsg(dAtA, i, uint64(m.Subcmd))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintMultimsg(dAtA []byte, offset int, v uint64) int {
	offset -= sovMultimsg(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ExternMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChannelType != 0 {
		n += 1 + sovMultimsg(uint64(m.ChannelType))
	}
	return n
}

func (m *MultiMsgApplyDownReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MsgResid)
	if l > 0 {
		n += 1 + l + sovMultimsg(uint64(l))
	}
	if m.MsgType != 0 {
		n += 1 + sovMultimsg(uint64(m.MsgType))
	}
	if m.SrcUin != 0 {
		n += 1 + sovMultimsg(uint64(m.SrcUin))
	}
	return n
}

func (m *MultiMsgApplyDownRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sovMultimsg(uint64(m.Result))
	}
	l = len(m.ThumbDownPara)
	if l > 0 {
		n += 1 + l + sovMultimsg(uint64(l))
	}
	l = len(m.MsgKey)
	if l > 0 {
		n += 1 + l + sovMultimsg(uint64(l))
	}
	if len(m.Uint32DownIp) > 0 {
		l = 0
		for _, e := range m.Uint32DownIp {
			l += sovMultimsg(uint64(e))
		}
		n += 1 + sovMultimsg(uint64(l)) + l
	}
	if len(m.Uint32DownPort) > 0 {
		l = 0
		for _, e := range m.Uint32DownPort {
			l += sovMultimsg(uint64(e))
		}
		n += 1 + sovMultimsg(uint64(l)) + l
	}
	l = len(m.MsgResid)
	if l > 0 {
		n += 1 + l + sovMultimsg(uint64(l))
	}
	if m.MsgExternInfo != nil {
		l = m.MsgExternInfo.Size()
		n += 1 + l + sovMultimsg(uint64(l))
	}
	if len(m.BytesDownIpV6) > 0 {
		for _, b := range m.BytesDownIpV6 {
			l = len(b)
			n += 1 + l + sovMultimsg(uint64(l))
		}
	}
	if len(m.Uint32DownV6Port) > 0 {
		l = 0
		for _, e := range m.Uint32DownV6Port {
			l += sovMultimsg(uint64(e))
		}
		n += 1 + sovMultimsg(uint64(l)) + l
	}
	return n
}

func (m *MultiMsgApplyUpReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DstUin != 0 {
		n += 1 + sovMultimsg(uint64(m.DstUin))
	}
	if m.MsgSize != 0 {
		n += 1 + sovMultimsg(uint64(m.MsgSize))
	}
	l = len(m.MsgMd5)
	if l > 0 {
		n += 1 + l + sovMultimsg(uint64(l))
	}
	if m.MsgType != 0 {
		n += 1 + sovMultimsg(uint64(m.MsgType))
	}
	if m.ApplyId != 0 {
		n += 1 + sovMultimsg(uint64(m.ApplyId))
	}
	return n
}

func (m *MultiMsgApplyUpRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sovMultimsg(uint64(m.Result))
	}
	l = len(m.MsgResid)
	if l > 0 {
		n += 1 + l + sovMultimsg(uint64(l))
	}
	l = len(m.MsgUkey)
	if l > 0 {
		n += 1 + l + sovMultimsg(uint64(l))
	}
	if len(m.Uint32UpIp) > 0 {
		l = 0
		for _, e := range m.Uint32UpIp {
			l += sovMultimsg(uint64(e))
		}
		n += 1 + sovMultimsg(uint64(l)) + l
	}
	if len(m.Uint32UpPort) > 0 {
		l = 0
		for _, e := range m.Uint32UpPort {
			l += sovMultimsg(uint64(e))
		}
		n += 1 + sovMultimsg(uint64(l)) + l
	}
	if m.BlockSize != 0 {
		n += 1 + sovMultimsg(uint64(m.BlockSize))
	}
	if m.UpOffset != 0 {
		n += 1 + sovMultimsg(uint64(m.UpOffset))
	}
	if m.ApplyId != 0 {
		n += 1 + sovMultimsg(uint64(m.ApplyId))
	}
	l = len(m.MsgKey)
	if l > 0 {
		n += 1 + l + sovMultimsg(uint64(l))
	}
	l = len(m.MsgSig)
	if l > 0 {
		n += 1 + l + sovMultimsg(uint64(l))
	}
	if m.MsgExternInfo != nil {
		l = m.MsgExternInfo.Size()
		n += 1 + l + sovMultimsg(uint64(l))
	}
	if len(m.BytesUpIpV6) > 0 {
		for _, b := range m.BytesUpIpV6 {
			l = len(b)
			n += 1 + l + sovMultimsg(uint64(l))
		}
	}
	if len(m.Uint32UpV6Port) > 0 {
		l = 0
		for _, e := range m.Uint32UpV6Port {
			l += sovMultimsg(uint64(e))
		}
		n += 1 + sovMultimsg(uint64(l)) + l
	}
	return n
}

func (m *MultiReqBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Subcmd != 0 {
		n += 1 + sovMultimsg(uint64(m.Subcmd))
	}
	if m.TermType != 0 {
		n += 1 + sovMultimsg(uint64(m.TermType))
	}
	if m.PlatformType != 0 {
		n += 1 + sovMultimsg(uint64(m.PlatformType))
	}
	if m.NetType != 0 {
		n += 1 + sovMultimsg(uint64(m.NetType))
	}
	l = len(m.BuildVer)
	if l > 0 {
		n += 1 + l + sovMultimsg(uint64(l))
	}
	if len(m.MultimsgApplyupReq) > 0 {
		for _, e := range m.MultimsgApplyupReq {
			l = e.Size()
			n += 1 + l + sovMultimsg(uint64(l))
		}
	}
	if len(m.MultimsgApplydownReq) > 0 {
		for _, e := range m.MultimsgApplydownReq {
			l = e.Size()
			n += 1 + l + sovMultimsg(uint64(l))
		}
	}
	if m.BuType != 0 {
		n += 1 + sovMultimsg(uint64(m.BuType))
	}
	if m.ReqChannelType != 0 {
		n += 1 + sovMultimsg(uint64(m.ReqChannelType))
	}
	return n
}

func (m *MultiRspBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Subcmd != 0 {
		n += 1 + sovMultimsg(uint64(m.Subcmd))
	}
	if len(m.MultimsgApplyupRsp) > 0 {
		for _, e := range m.MultimsgApplyupRsp {
			l = e.Size()
			n += 1 + l + sovMultimsg(uint64(l))
		}
	}
	if len(m.MultimsgApplydownRsp) > 0 {
		for _, e := range m.MultimsgApplydownRsp {
			l = e.Size()
			n += 1 + l + sovMultimsg(uint64(l))
		}
	}
	return n
}

func sovMultimsg(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMultimsg(x uint64) (n int) {
	return sovMultimsg(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ExternMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMultimsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExternMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExternMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelType", wireType)
			}
			m.ChannelType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultimsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMultimsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMultimsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMultimsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiMsgApplyDownReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMultimsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiMsgApplyDownReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiMsgApplyDownReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgResid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultimsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMultimsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMultimsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgResid = append(m.MsgResid[:0], dAtA[iNdEx:postIndex]...)
			if m.MsgResid == nil {
				m.MsgResid = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgType", wireType)
			}
			m.MsgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultimsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcUin", wireType)
			}
			m.SrcUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultimsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMultimsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMultimsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMultimsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiMsgApplyDownRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMultimsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiMsgApplyDownRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiMsgApplyDownRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultimsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThumbDownPara", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultimsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMultimsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMultimsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ThumbDownPara = append(m.ThumbDownPara[:0], dAtA[iNdEx:postIndex]...)
			if m.ThumbDownPara == nil {
				m.ThumbDownPara = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultimsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMultimsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMultimsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgKey = append(m.MsgKey[:0], dAtA[iNdEx:postIndex]...)
			if m.MsgKey == nil {
				m.MsgKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMultimsg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Uint32DownIp = append(m.Uint32DownIp, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMultimsg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMultimsg
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMultimsg
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Uint32DownIp) == 0 {
					m.Uint32DownIp = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMultimsg
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Uint32DownIp = append(m.Uint32DownIp, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint32DownIp", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMultimsg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Uint32DownPort = append(m.Uint32DownPort, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMultimsg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMultimsg
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMultimsg
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Uint32DownPort) == 0 {
					m.Uint32DownPort = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMultimsg
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Uint32DownPort = append(m.Uint32DownPort, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint32DownPort", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgResid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultimsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMultimsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMultimsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgResid = append(m.MsgResid[:0], dAtA[iNdEx:postIndex]...)
			if m.MsgResid == nil {
				m.MsgResid = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgExternInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultimsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMultimsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMultimsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MsgExternInfo == nil {
				m.MsgExternInfo = &ExternMsg{}
			}
			if err := m.MsgExternInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesDownIpV6", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultimsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMultimsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMultimsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BytesDownIpV6 = append(m.BytesDownIpV6, make([]byte, postIndex-iNdEx))
			copy(m.BytesDownIpV6[len(m.BytesDownIpV6)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMultimsg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Uint32DownV6Port = append(m.Uint32DownV6Port, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMultimsg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMultimsg
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMultimsg
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Uint32DownV6Port) == 0 {
					m.Uint32DownV6Port = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMultimsg
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Uint32DownV6Port = append(m.Uint32DownV6Port, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint32DownV6Port", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMultimsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMultimsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMultimsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiMsgApplyUpReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMultimsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiMsgApplyUpReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiMsgApplyUpReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstUin", wireType)
			}
			m.DstUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultimsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgSize", wireType)
			}
			m.MsgSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultimsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgMd5", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultimsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMultimsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMultimsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgMd5 = append(m.MsgMd5[:0], dAtA[iNdEx:postIndex]...)
			if m.MsgMd5 == nil {
				m.MsgMd5 = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgType", wireType)
			}
			m.MsgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultimsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyId", wireType)
			}
			m.ApplyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultimsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApplyId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMultimsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMultimsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMultimsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiMsgApplyUpRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMultimsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiMsgApplyUpRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiMsgApplyUpRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultimsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgResid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultimsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMultimsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMultimsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgResid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgUkey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultimsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMultimsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMultimsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgUkey = append(m.MsgUkey[:0], dAtA[iNdEx:postIndex]...)
			if m.MsgUkey == nil {
				m.MsgUkey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMultimsg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Uint32UpIp = append(m.Uint32UpIp, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMultimsg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMultimsg
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMultimsg
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Uint32UpIp) == 0 {
					m.Uint32UpIp = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMultimsg
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Uint32UpIp = append(m.Uint32UpIp, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint32UpIp", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMultimsg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Uint32UpPort = append(m.Uint32UpPort, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMultimsg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMultimsg
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMultimsg
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Uint32UpPort) == 0 {
					m.Uint32UpPort = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMultimsg
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Uint32UpPort = append(m.Uint32UpPort, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint32UpPort", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockSize", wireType)
			}
			m.BlockSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultimsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpOffset", wireType)
			}
			m.UpOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultimsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpOffset |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyId", wireType)
			}
			m.ApplyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultimsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApplyId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultimsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMultimsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMultimsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgKey = append(m.MsgKey[:0], dAtA[iNdEx:postIndex]...)
			if m.MsgKey == nil {
				m.MsgKey = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgSig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultimsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMultimsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMultimsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgSig = append(m.MsgSig[:0], dAtA[iNdEx:postIndex]...)
			if m.MsgSig == nil {
				m.MsgSig = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgExternInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultimsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMultimsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMultimsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MsgExternInfo == nil {
				m.MsgExternInfo = &ExternMsg{}
			}
			if err := m.MsgExternInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesUpIpV6", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultimsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMultimsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMultimsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BytesUpIpV6 = append(m.BytesUpIpV6, make([]byte, postIndex-iNdEx))
			copy(m.BytesUpIpV6[len(m.BytesUpIpV6)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMultimsg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Uint32UpV6Port = append(m.Uint32UpV6Port, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMultimsg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMultimsg
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMultimsg
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Uint32UpV6Port) == 0 {
					m.Uint32UpV6Port = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMultimsg
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Uint32UpV6Port = append(m.Uint32UpV6Port, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint32UpV6Port", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMultimsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMultimsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMultimsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiReqBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMultimsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiReqBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiReqBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subcmd", wireType)
			}
			m.Subcmd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultimsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Subcmd |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TermType", wireType)
			}
			m.TermType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultimsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TermType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformType", wireType)
			}
			m.PlatformType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultimsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlatformType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetType", wireType)
			}
			m.NetType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultimsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildVer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultimsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMultimsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMultimsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildVer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultimsgApplyupReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultimsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMultimsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMultimsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MultimsgApplyupReq = append(m.MultimsgApplyupReq, &MultiMsgApplyUpReq{})
			if err := m.MultimsgApplyupReq[len(m.MultimsgApplyupReq)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultimsgApplydownReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultimsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMultimsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMultimsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MultimsgApplydownReq = append(m.MultimsgApplydownReq, &MultiMsgApplyDownReq{})
			if err := m.MultimsgApplydownReq[len(m.MultimsgApplydownReq)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuType", wireType)
			}
			m.BuType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultimsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqChannelType", wireType)
			}
			m.ReqChannelType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultimsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqChannelType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMultimsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMultimsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMultimsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiRspBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMultimsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiRspBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiRspBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subcmd", wireType)
			}
			m.Subcmd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultimsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Subcmd |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultimsgApplyupRsp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultimsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMultimsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMultimsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MultimsgApplyupRsp = append(m.MultimsgApplyupRsp, &MultiMsgApplyUpRsp{})
			if err := m.MultimsgApplyupRsp[len(m.MultimsgApplyupRsp)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultimsgApplydownRsp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultimsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMultimsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMultimsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MultimsgApplydownRsp = append(m.MultimsgApplydownRsp, &MultiMsgApplyDownRsp{})
			if err := m.MultimsgApplydownRsp[len(m.MultimsgApplydownRsp)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMultimsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMultimsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMultimsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMultimsg(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMultimsg
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMultimsg
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMultimsg
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMultimsg
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMultimsg
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMultimsg
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMultimsg        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMultimsg          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMultimsg = fmt.Errorf("proto: unexpected end of group")
)
