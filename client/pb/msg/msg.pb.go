// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: msg.proto

package msg

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type SyncFlag int32

const (
	SyncFlag_START     SyncFlag = 0
	SyncFlag_CONTINUME SyncFlag = 1
	SyncFlag_STOP      SyncFlag = 2
)

var SyncFlag_name = map[int32]string{
	0: "START",
	1: "CONTINUME",
	2: "STOP",
}

var SyncFlag_value = map[string]int32{
	"START":     0,
	"CONTINUME": 1,
	"STOP":      2,
}

func (x SyncFlag) Enum() *SyncFlag {
	p := new(SyncFlag)
	*p = x
	return p
}

func (x SyncFlag) String() string {
	return proto.EnumName(SyncFlag_name, int32(x))
}

func (x *SyncFlag) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SyncFlag_value, data, "SyncFlag")
	if err != nil {
		return err
	}
	*x = SyncFlag(value)
	return nil
}

func (SyncFlag) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{0}
}

type GetMessageRequest struct {
	SyncFlag           SyncFlag `protobuf:"varint,1,opt,name=syncFlag,enum=SyncFlag" json:"syncFlag"`
	SyncCookie         []byte   `protobuf:"bytes,2,opt,name=syncCookie" json:"syncCookie"`
	RambleFlag         int32    `protobuf:"varint,3,opt,name=rambleFlag" json:"rambleFlag"`
	LatestRambleNumber int32    `protobuf:"varint,4,opt,name=latestRambleNumber" json:"latestRambleNumber"`
	OtherRambleNumber  int32    `protobuf:"varint,5,opt,name=otherRambleNumber" json:"otherRambleNumber"`
	OnlineSyncFlag     int32    `protobuf:"varint,6,opt,name=onlineSyncFlag" json:"onlineSyncFlag"`
	ContextFlag        int32    `protobuf:"varint,7,opt,name=contextFlag" json:"contextFlag"`
	WhisperSessionId   int32    `protobuf:"varint,8,opt,name=whisperSessionId" json:"whisperSessionId"`
	MsgReqType         int32    `protobuf:"varint,9,opt,name=msgReqType" json:"msgReqType"`
	PubaccountCookie   []byte   `protobuf:"bytes,10,opt,name=pubaccountCookie" json:"pubaccountCookie"`
	MsgCtrlBuf         []byte   `protobuf:"bytes,11,opt,name=msgCtrlBuf" json:"msgCtrlBuf"`
	ServerBuf          []byte   `protobuf:"bytes,12,opt,name=serverBuf" json:"serverBuf"`
}

func (m *GetMessageRequest) Reset()         { *m = GetMessageRequest{} }
func (m *GetMessageRequest) String() string { return proto.CompactTextString(m) }
func (*GetMessageRequest) ProtoMessage()    {}
func (*GetMessageRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{0}
}
func (m *GetMessageRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMessageRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMessageRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetMessageRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMessageRequest.Merge(m, src)
}
func (m *GetMessageRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetMessageRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMessageRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetMessageRequest proto.InternalMessageInfo

func (m *GetMessageRequest) GetSyncFlag() SyncFlag {
	if m != nil {
		return m.SyncFlag
	}
	return SyncFlag_START
}

func (m *GetMessageRequest) GetSyncCookie() []byte {
	if m != nil {
		return m.SyncCookie
	}
	return nil
}

func (m *GetMessageRequest) GetRambleFlag() int32 {
	if m != nil {
		return m.RambleFlag
	}
	return 0
}

func (m *GetMessageRequest) GetLatestRambleNumber() int32 {
	if m != nil {
		return m.LatestRambleNumber
	}
	return 0
}

func (m *GetMessageRequest) GetOtherRambleNumber() int32 {
	if m != nil {
		return m.OtherRambleNumber
	}
	return 0
}

func (m *GetMessageRequest) GetOnlineSyncFlag() int32 {
	if m != nil {
		return m.OnlineSyncFlag
	}
	return 0
}

func (m *GetMessageRequest) GetContextFlag() int32 {
	if m != nil {
		return m.ContextFlag
	}
	return 0
}

func (m *GetMessageRequest) GetWhisperSessionId() int32 {
	if m != nil {
		return m.WhisperSessionId
	}
	return 0
}

func (m *GetMessageRequest) GetMsgReqType() int32 {
	if m != nil {
		return m.MsgReqType
	}
	return 0
}

func (m *GetMessageRequest) GetPubaccountCookie() []byte {
	if m != nil {
		return m.PubaccountCookie
	}
	return nil
}

func (m *GetMessageRequest) GetMsgCtrlBuf() []byte {
	if m != nil {
		return m.MsgCtrlBuf
	}
	return nil
}

func (m *GetMessageRequest) GetServerBuf() []byte {
	if m != nil {
		return m.ServerBuf
	}
	return nil
}

type SendMessageRequest struct {
	RoutingHead *RoutingHead `protobuf:"bytes,1,opt,name=routingHead" json:"routingHead,omitempty"`
	ContentHead *ContentHead `protobuf:"bytes,2,opt,name=contentHead" json:"contentHead,omitempty"`
	MsgBody     *MessageBody `protobuf:"bytes,3,opt,name=msgBody" json:"msgBody,omitempty"`
	MsgSeq      int32        `protobuf:"varint,4,opt,name=msgSeq" json:"msgSeq"`
	MsgRand     int32        `protobuf:"varint,5,opt,name=msgRand" json:"msgRand"`
	SyncCookie  []byte       `protobuf:"bytes,6,opt,name=syncCookie" json:"syncCookie"`
	//MsgComm.AppShareInfo? appShare = 7;
	MsgVia      int32 `protobuf:"varint,8,opt,name=msgVia" json:"msgVia"`
	DataStatist int32 `protobuf:"varint,9,opt,name=dataStatist" json:"dataStatist"`
	//MultiMsgAssist? multiMsgAssist = 10;
	//PbInputNotifyInfo? inputNotifyInfo = 11;
	MsgCtrl *MsgCtrl `protobuf:"bytes,12,opt,name=msgCtrl" json:"msgCtrl,omitempty"`
	//ImReceipt.ReceiptReq? receiptReq = 13;
	MultiSendSeq int32 `protobuf:"varint,14,opt,name=multiSendSeq" json:"multiSendSeq"`
}

func (m *SendMessageRequest) Reset()         { *m = SendMessageRequest{} }
func (m *SendMessageRequest) String() string { return proto.CompactTextString(m) }
func (*SendMessageRequest) ProtoMessage()    {}
func (*SendMessageRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{1}
}
func (m *SendMessageRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendMessageRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendMessageRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendMessageRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendMessageRequest.Merge(m, src)
}
func (m *SendMessageRequest) XXX_Size() int {
	return m.Size()
}
func (m *SendMessageRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SendMessageRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SendMessageRequest proto.InternalMessageInfo

func (m *SendMessageRequest) GetRoutingHead() *RoutingHead {
	if m != nil {
		return m.RoutingHead
	}
	return nil
}

func (m *SendMessageRequest) GetContentHead() *ContentHead {
	if m != nil {
		return m.ContentHead
	}
	return nil
}

func (m *SendMessageRequest) GetMsgBody() *MessageBody {
	if m != nil {
		return m.MsgBody
	}
	return nil
}

func (m *SendMessageRequest) GetMsgSeq() int32 {
	if m != nil {
		return m.MsgSeq
	}
	return 0
}

func (m *SendMessageRequest) GetMsgRand() int32 {
	if m != nil {
		return m.MsgRand
	}
	return 0
}

func (m *SendMessageRequest) GetSyncCookie() []byte {
	if m != nil {
		return m.SyncCookie
	}
	return nil
}

func (m *SendMessageRequest) GetMsgVia() int32 {
	if m != nil {
		return m.MsgVia
	}
	return 0
}

func (m *SendMessageRequest) GetDataStatist() int32 {
	if m != nil {
		return m.DataStatist
	}
	return 0
}

func (m *SendMessageRequest) GetMsgCtrl() *MsgCtrl {
	if m != nil {
		return m.MsgCtrl
	}
	return nil
}

func (m *SendMessageRequest) GetMultiSendSeq() int32 {
	if m != nil {
		return m.MultiSendSeq
	}
	return 0
}

type SendMessageResponse struct {
	Result int32  `protobuf:"varint,1,opt,name=result" json:"result"`
	ErrMsg string `protobuf:"bytes,2,opt,name=errMsg" json:"errMsg"`
}

func (m *SendMessageResponse) Reset()         { *m = SendMessageResponse{} }
func (m *SendMessageResponse) String() string { return proto.CompactTextString(m) }
func (*SendMessageResponse) ProtoMessage()    {}
func (*SendMessageResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{2}
}
func (m *SendMessageResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendMessageResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendMessageResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendMessageResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendMessageResponse.Merge(m, src)
}
func (m *SendMessageResponse) XXX_Size() int {
	return m.Size()
}
func (m *SendMessageResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SendMessageResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SendMessageResponse proto.InternalMessageInfo

func (m *SendMessageResponse) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

func (m *SendMessageResponse) GetErrMsg() string {
	if m != nil {
		return m.ErrMsg
	}
	return ""
}

type MsgWithDrawReq struct {
	C2CWithDraw   []*C2CMsgWithDrawReq   `protobuf:"bytes,1,rep,name=c2cWithDraw" json:"c2cWithDraw,omitempty"`
	GroupWithDraw []*GroupMsgWithDrawReq `protobuf:"bytes,2,rep,name=groupWithDraw" json:"groupWithDraw,omitempty"`
}

func (m *MsgWithDrawReq) Reset()         { *m = MsgWithDrawReq{} }
func (m *MsgWithDrawReq) String() string { return proto.CompactTextString(m) }
func (*MsgWithDrawReq) ProtoMessage()    {}
func (*MsgWithDrawReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{3}
}
func (m *MsgWithDrawReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgWithDrawReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgWithDrawReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgWithDrawReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgWithDrawReq.Merge(m, src)
}
func (m *MsgWithDrawReq) XXX_Size() int {
	return m.Size()
}
func (m *MsgWithDrawReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgWithDrawReq.DiscardUnknown(m)
}

var xxx_messageInfo_MsgWithDrawReq proto.InternalMessageInfo

func (m *MsgWithDrawReq) GetC2CWithDraw() []*C2CMsgWithDrawReq {
	if m != nil {
		return m.C2CWithDraw
	}
	return nil
}

func (m *MsgWithDrawReq) GetGroupWithDraw() []*GroupMsgWithDrawReq {
	if m != nil {
		return m.GroupWithDraw
	}
	return nil
}

type C2CMsgWithDrawReq struct {
	MsgInfo         []*C2CMsgInfo `protobuf:"bytes,1,rep,name=msgInfo" json:"msgInfo,omitempty"`
	LongMessageFlag int32         `protobuf:"varint,2,opt,name=longMessageFlag" json:"longMessageFlag"`
	Reserved        []byte        `protobuf:"bytes,3,opt,name=reserved" json:"reserved"`
	SubCmd          int32         `protobuf:"varint,4,opt,name=subCmd" json:"subCmd"`
}

func (m *C2CMsgWithDrawReq) Reset()         { *m = C2CMsgWithDrawReq{} }
func (m *C2CMsgWithDrawReq) String() string { return proto.CompactTextString(m) }
func (*C2CMsgWithDrawReq) ProtoMessage()    {}
func (*C2CMsgWithDrawReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{4}
}
func (m *C2CMsgWithDrawReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2CMsgWithDrawReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2CMsgWithDrawReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2CMsgWithDrawReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2CMsgWithDrawReq.Merge(m, src)
}
func (m *C2CMsgWithDrawReq) XXX_Size() int {
	return m.Size()
}
func (m *C2CMsgWithDrawReq) XXX_DiscardUnknown() {
	xxx_messageInfo_C2CMsgWithDrawReq.DiscardUnknown(m)
}

var xxx_messageInfo_C2CMsgWithDrawReq proto.InternalMessageInfo

func (m *C2CMsgWithDrawReq) GetMsgInfo() []*C2CMsgInfo {
	if m != nil {
		return m.MsgInfo
	}
	return nil
}

func (m *C2CMsgWithDrawReq) GetLongMessageFlag() int32 {
	if m != nil {
		return m.LongMessageFlag
	}
	return 0
}

func (m *C2CMsgWithDrawReq) GetReserved() []byte {
	if m != nil {
		return m.Reserved
	}
	return nil
}

func (m *C2CMsgWithDrawReq) GetSubCmd() int32 {
	if m != nil {
		return m.SubCmd
	}
	return 0
}

type GroupMsgWithDrawReq struct {
	SubCmd    int32           `protobuf:"varint,1,opt,name=subCmd" json:"subCmd"`
	GroupType int32           `protobuf:"varint,2,opt,name=groupType" json:"groupType"`
	GroupCode int64           `protobuf:"varint,3,opt,name=groupCode" json:"groupCode"`
	MsgList   []*GroupMsgInfo `protobuf:"bytes,4,rep,name=msgList" json:"msgList,omitempty"`
	UserDef   []byte          `protobuf:"bytes,5,opt,name=userDef" json:"userDef"`
}

func (m *GroupMsgWithDrawReq) Reset()         { *m = GroupMsgWithDrawReq{} }
func (m *GroupMsgWithDrawReq) String() string { return proto.CompactTextString(m) }
func (*GroupMsgWithDrawReq) ProtoMessage()    {}
func (*GroupMsgWithDrawReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{5}
}
func (m *GroupMsgWithDrawReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupMsgWithDrawReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupMsgWithDrawReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupMsgWithDrawReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupMsgWithDrawReq.Merge(m, src)
}
func (m *GroupMsgWithDrawReq) XXX_Size() int {
	return m.Size()
}
func (m *GroupMsgWithDrawReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupMsgWithDrawReq.DiscardUnknown(m)
}

var xxx_messageInfo_GroupMsgWithDrawReq proto.InternalMessageInfo

func (m *GroupMsgWithDrawReq) GetSubCmd() int32 {
	if m != nil {
		return m.SubCmd
	}
	return 0
}

func (m *GroupMsgWithDrawReq) GetGroupType() int32 {
	if m != nil {
		return m.GroupType
	}
	return 0
}

func (m *GroupMsgWithDrawReq) GetGroupCode() int64 {
	if m != nil {
		return m.GroupCode
	}
	return 0
}

func (m *GroupMsgWithDrawReq) GetMsgList() []*GroupMsgInfo {
	if m != nil {
		return m.MsgList
	}
	return nil
}

func (m *GroupMsgWithDrawReq) GetUserDef() []byte {
	if m != nil {
		return m.UserDef
	}
	return nil
}

type MsgWithDrawResp struct {
	C2CWithDraw   []*C2CMsgWithDrawResp   `protobuf:"bytes,1,rep,name=c2cWithDraw" json:"c2cWithDraw,omitempty"`
	GroupWithDraw []*GroupMsgWithDrawResp `protobuf:"bytes,2,rep,name=groupWithDraw" json:"groupWithDraw,omitempty"`
}

func (m *MsgWithDrawResp) Reset()         { *m = MsgWithDrawResp{} }
func (m *MsgWithDrawResp) String() string { return proto.CompactTextString(m) }
func (*MsgWithDrawResp) ProtoMessage()    {}
func (*MsgWithDrawResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{6}
}
func (m *MsgWithDrawResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgWithDrawResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgWithDrawResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgWithDrawResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgWithDrawResp.Merge(m, src)
}
func (m *MsgWithDrawResp) XXX_Size() int {
	return m.Size()
}
func (m *MsgWithDrawResp) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgWithDrawResp.DiscardUnknown(m)
}

var xxx_messageInfo_MsgWithDrawResp proto.InternalMessageInfo

func (m *MsgWithDrawResp) GetC2CWithDraw() []*C2CMsgWithDrawResp {
	if m != nil {
		return m.C2CWithDraw
	}
	return nil
}

func (m *MsgWithDrawResp) GetGroupWithDraw() []*GroupMsgWithDrawResp {
	if m != nil {
		return m.GroupWithDraw
	}
	return nil
}

type C2CMsgWithDrawResp struct {
	Result int32  `protobuf:"varint,1,opt,name=result" json:"result"`
	ErrMsg string `protobuf:"bytes,2,opt,name=errMsg" json:"errMsg"`
}

func (m *C2CMsgWithDrawResp) Reset()         { *m = C2CMsgWithDrawResp{} }
func (m *C2CMsgWithDrawResp) String() string { return proto.CompactTextString(m) }
func (*C2CMsgWithDrawResp) ProtoMessage()    {}
func (*C2CMsgWithDrawResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{7}
}
func (m *C2CMsgWithDrawResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2CMsgWithDrawResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2CMsgWithDrawResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2CMsgWithDrawResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2CMsgWithDrawResp.Merge(m, src)
}
func (m *C2CMsgWithDrawResp) XXX_Size() int {
	return m.Size()
}
func (m *C2CMsgWithDrawResp) XXX_DiscardUnknown() {
	xxx_messageInfo_C2CMsgWithDrawResp.DiscardUnknown(m)
}

var xxx_messageInfo_C2CMsgWithDrawResp proto.InternalMessageInfo

func (m *C2CMsgWithDrawResp) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

func (m *C2CMsgWithDrawResp) GetErrMsg() string {
	if m != nil {
		return m.ErrMsg
	}
	return ""
}

type GroupMsgWithDrawResp struct {
	Result int32  `protobuf:"varint,1,opt,name=result" json:"result"`
	ErrMsg string `protobuf:"bytes,2,opt,name=errMsg" json:"errMsg"`
}

func (m *GroupMsgWithDrawResp) Reset()         { *m = GroupMsgWithDrawResp{} }
func (m *GroupMsgWithDrawResp) String() string { return proto.CompactTextString(m) }
func (*GroupMsgWithDrawResp) ProtoMessage()    {}
func (*GroupMsgWithDrawResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{8}
}
func (m *GroupMsgWithDrawResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupMsgWithDrawResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupMsgWithDrawResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupMsgWithDrawResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupMsgWithDrawResp.Merge(m, src)
}
func (m *GroupMsgWithDrawResp) XXX_Size() int {
	return m.Size()
}
func (m *GroupMsgWithDrawResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupMsgWithDrawResp.DiscardUnknown(m)
}

var xxx_messageInfo_GroupMsgWithDrawResp proto.InternalMessageInfo

func (m *GroupMsgWithDrawResp) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

func (m *GroupMsgWithDrawResp) GetErrMsg() string {
	if m != nil {
		return m.ErrMsg
	}
	return ""
}

type GroupMsgInfo struct {
	MsgSeq    int32 `protobuf:"varint,1,opt,name=msgSeq" json:"msgSeq"`
	MsgRandom int32 `protobuf:"varint,2,opt,name=msgRandom" json:"msgRandom"`
	MsgType   int32 `protobuf:"varint,3,opt,name=msgType" json:"msgType"`
}

func (m *GroupMsgInfo) Reset()         { *m = GroupMsgInfo{} }
func (m *GroupMsgInfo) String() string { return proto.CompactTextString(m) }
func (*GroupMsgInfo) ProtoMessage()    {}
func (*GroupMsgInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{9}
}
func (m *GroupMsgInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupMsgInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupMsgInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupMsgInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupMsgInfo.Merge(m, src)
}
func (m *GroupMsgInfo) XXX_Size() int {
	return m.Size()
}
func (m *GroupMsgInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupMsgInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GroupMsgInfo proto.InternalMessageInfo

func (m *GroupMsgInfo) GetMsgSeq() int32 {
	if m != nil {
		return m.MsgSeq
	}
	return 0
}

func (m *GroupMsgInfo) GetMsgRandom() int32 {
	if m != nil {
		return m.MsgRandom
	}
	return 0
}

func (m *GroupMsgInfo) GetMsgType() int32 {
	if m != nil {
		return m.MsgType
	}
	return 0
}

type C2CMsgInfo struct {
	FromUin     int64        `protobuf:"varint,1,opt,name=fromUin" json:"fromUin"`
	ToUin       int64        `protobuf:"varint,2,opt,name=toUin" json:"toUin"`
	MsgSeq      int32        `protobuf:"varint,3,opt,name=msgSeq" json:"msgSeq"`
	MsgUid      int64        `protobuf:"varint,4,opt,name=msgUid" json:"msgUid"`
	MsgTime     int64        `protobuf:"varint,5,opt,name=msgTime" json:"msgTime"`
	MsgRandom   int32        `protobuf:"varint,6,opt,name=msgRandom" json:"msgRandom"`
	PkgNum      int32        `protobuf:"varint,7,opt,name=pkgNum" json:"pkgNum"`
	PkgIndex    int32        `protobuf:"varint,8,opt,name=pkgIndex" json:"pkgIndex"`
	DivSeq      int32        `protobuf:"varint,9,opt,name=divSeq" json:"divSeq"`
	MsgType     int32        `protobuf:"varint,10,opt,name=msgType" json:"msgType"`
	RoutingHead *RoutingHead `protobuf:"bytes,20,opt,name=routingHead" json:"routingHead,omitempty"`
}

func (m *C2CMsgInfo) Reset()         { *m = C2CMsgInfo{} }
func (m *C2CMsgInfo) String() string { return proto.CompactTextString(m) }
func (*C2CMsgInfo) ProtoMessage()    {}
func (*C2CMsgInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{10}
}
func (m *C2CMsgInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2CMsgInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2CMsgInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2CMsgInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2CMsgInfo.Merge(m, src)
}
func (m *C2CMsgInfo) XXX_Size() int {
	return m.Size()
}
func (m *C2CMsgInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_C2CMsgInfo.DiscardUnknown(m)
}

var xxx_messageInfo_C2CMsgInfo proto.InternalMessageInfo

func (m *C2CMsgInfo) GetFromUin() int64 {
	if m != nil {
		return m.FromUin
	}
	return 0
}

func (m *C2CMsgInfo) GetToUin() int64 {
	if m != nil {
		return m.ToUin
	}
	return 0
}

func (m *C2CMsgInfo) GetMsgSeq() int32 {
	if m != nil {
		return m.MsgSeq
	}
	return 0
}

func (m *C2CMsgInfo) GetMsgUid() int64 {
	if m != nil {
		return m.MsgUid
	}
	return 0
}

func (m *C2CMsgInfo) GetMsgTime() int64 {
	if m != nil {
		return m.MsgTime
	}
	return 0
}

func (m *C2CMsgInfo) GetMsgRandom() int32 {
	if m != nil {
		return m.MsgRandom
	}
	return 0
}

func (m *C2CMsgInfo) GetPkgNum() int32 {
	if m != nil {
		return m.PkgNum
	}
	return 0
}

func (m *C2CMsgInfo) GetPkgIndex() int32 {
	if m != nil {
		return m.PkgIndex
	}
	return 0
}

func (m *C2CMsgInfo) GetDivSeq() int32 {
	if m != nil {
		return m.DivSeq
	}
	return 0
}

func (m *C2CMsgInfo) GetMsgType() int32 {
	if m != nil {
		return m.MsgType
	}
	return 0
}

func (m *C2CMsgInfo) GetRoutingHead() *RoutingHead {
	if m != nil {
		return m.RoutingHead
	}
	return nil
}

type RoutingHead struct {
	C2C    *C2C    `protobuf:"bytes,1,opt,name=c2c" json:"c2c,omitempty"`
	Grp    *Grp    `protobuf:"bytes,2,opt,name=grp" json:"grp,omitempty"`
	GrpTmp *GrpTmp `protobuf:"bytes,3,opt,name=grpTmp" json:"grpTmp,omitempty"`
}

func (m *RoutingHead) Reset()         { *m = RoutingHead{} }
func (m *RoutingHead) String() string { return proto.CompactTextString(m) }
func (*RoutingHead) ProtoMessage()    {}
func (*RoutingHead) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{11}
}
func (m *RoutingHead) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoutingHead) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoutingHead.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoutingHead) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoutingHead.Merge(m, src)
}
func (m *RoutingHead) XXX_Size() int {
	return m.Size()
}
func (m *RoutingHead) XXX_DiscardUnknown() {
	xxx_messageInfo_RoutingHead.DiscardUnknown(m)
}

var xxx_messageInfo_RoutingHead proto.InternalMessageInfo

func (m *RoutingHead) GetC2C() *C2C {
	if m != nil {
		return m.C2C
	}
	return nil
}

func (m *RoutingHead) GetGrp() *Grp {
	if m != nil {
		return m.Grp
	}
	return nil
}

func (m *RoutingHead) GetGrpTmp() *GrpTmp {
	if m != nil {
		return m.GrpTmp
	}
	return nil
}

type C2C struct {
	ToUin int64 `protobuf:"varint,1,opt,name=toUin" json:"toUin"`
}

func (m *C2C) Reset()         { *m = C2C{} }
func (m *C2C) String() string { return proto.CompactTextString(m) }
func (*C2C) ProtoMessage()    {}
func (*C2C) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{12}
}
func (m *C2C) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2C) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2C.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2C) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2C.Merge(m, src)
}
func (m *C2C) XXX_Size() int {
	return m.Size()
}
func (m *C2C) XXX_DiscardUnknown() {
	xxx_messageInfo_C2C.DiscardUnknown(m)
}

var xxx_messageInfo_C2C proto.InternalMessageInfo

func (m *C2C) GetToUin() int64 {
	if m != nil {
		return m.ToUin
	}
	return 0
}

type Grp struct {
	GroupCode int64 `protobuf:"varint,1,opt,name=groupCode" json:"groupCode"`
}

func (m *Grp) Reset()         { *m = Grp{} }
func (m *Grp) String() string { return proto.CompactTextString(m) }
func (*Grp) ProtoMessage()    {}
func (*Grp) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{13}
}
func (m *Grp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Grp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Grp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Grp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Grp.Merge(m, src)
}
func (m *Grp) XXX_Size() int {
	return m.Size()
}
func (m *Grp) XXX_DiscardUnknown() {
	xxx_messageInfo_Grp.DiscardUnknown(m)
}

var xxx_messageInfo_Grp proto.InternalMessageInfo

func (m *Grp) GetGroupCode() int64 {
	if m != nil {
		return m.GroupCode
	}
	return 0
}

type GrpTmp struct {
	GroupUin int64 `protobuf:"varint,1,opt,name=groupUin" json:"groupUin"`
	ToUin    int64 `protobuf:"varint,2,opt,name=toUin" json:"toUin"`
}

func (m *GrpTmp) Reset()         { *m = GrpTmp{} }
func (m *GrpTmp) String() string { return proto.CompactTextString(m) }
func (*GrpTmp) ProtoMessage()    {}
func (*GrpTmp) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{14}
}
func (m *GrpTmp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GrpTmp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GrpTmp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GrpTmp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GrpTmp.Merge(m, src)
}
func (m *GrpTmp) XXX_Size() int {
	return m.Size()
}
func (m *GrpTmp) XXX_DiscardUnknown() {
	xxx_messageInfo_GrpTmp.DiscardUnknown(m)
}

var xxx_messageInfo_GrpTmp proto.InternalMessageInfo

func (m *GrpTmp) GetGroupUin() int64 {
	if m != nil {
		return m.GroupUin
	}
	return 0
}

func (m *GrpTmp) GetToUin() int64 {
	if m != nil {
		return m.ToUin
	}
	return 0
}

type MsgCtrl struct {
	MsgFlag int32 `protobuf:"varint,1,opt,name=msgFlag" json:"msgFlag"`
}

func (m *MsgCtrl) Reset()         { *m = MsgCtrl{} }
func (m *MsgCtrl) String() string { return proto.CompactTextString(m) }
func (*MsgCtrl) ProtoMessage()    {}
func (*MsgCtrl) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{15}
}
func (m *MsgCtrl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCtrl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCtrl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCtrl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCtrl.Merge(m, src)
}
func (m *MsgCtrl) XXX_Size() int {
	return m.Size()
}
func (m *MsgCtrl) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCtrl.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCtrl proto.InternalMessageInfo

func (m *MsgCtrl) GetMsgFlag() int32 {
	if m != nil {
		return m.MsgFlag
	}
	return 0
}

type GetMessageResponse struct {
	Result           int32             `protobuf:"varint,1,opt,name=result" json:"result"`
	ErrorMessage     string            `protobuf:"bytes,2,opt,name=errorMessage" json:"errorMessage"`
	SyncCookie       []byte            `protobuf:"bytes,3,opt,name=syncCookie" json:"syncCookie"`
	SyncFlag         SyncFlag          `protobuf:"varint,4,opt,name=syncFlag,enum=SyncFlag" json:"syncFlag"`
	UinPairMsgs      []*UinPairMessage `protobuf:"bytes,5,rep,name=uinPairMsgs" json:"uinPairMsgs,omitempty"`
	BindUin          int64             `protobuf:"varint,6,opt,name=bindUin" json:"bindUin"`
	MsgRspType       int32             `protobuf:"varint,7,opt,name=msgRspType" json:"msgRspType"`
	PubAccountCookie []byte            `protobuf:"bytes,8,opt,name=pubAccountCookie" json:"pubAccountCookie"`
	IsPartialSync    bool              `protobuf:"varint,9,opt,name=isPartialSync" json:"isPartialSync"`
	MsgCtrlBuf       []byte            `protobuf:"bytes,10,opt,name=msgCtrlBuf" json:"msgCtrlBuf"`
}

func (m *GetMessageResponse) Reset()         { *m = GetMessageResponse{} }
func (m *GetMessageResponse) String() string { return proto.CompactTextString(m) }
func (*GetMessageResponse) ProtoMessage()    {}
func (*GetMessageResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{16}
}
func (m *GetMessageResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMessageResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMessageResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetMessageResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMessageResponse.Merge(m, src)
}
func (m *GetMessageResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetMessageResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMessageResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetMessageResponse proto.InternalMessageInfo

func (m *GetMessageResponse) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

func (m *GetMessageResponse) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func (m *GetMessageResponse) GetSyncCookie() []byte {
	if m != nil {
		return m.SyncCookie
	}
	return nil
}

func (m *GetMessageResponse) GetSyncFlag() SyncFlag {
	if m != nil {
		return m.SyncFlag
	}
	return SyncFlag_START
}

func (m *GetMessageResponse) GetUinPairMsgs() []*UinPairMessage {
	if m != nil {
		return m.UinPairMsgs
	}
	return nil
}

func (m *GetMessageResponse) GetBindUin() int64 {
	if m != nil {
		return m.BindUin
	}
	return 0
}

func (m *GetMessageResponse) GetMsgRspType() int32 {
	if m != nil {
		return m.MsgRspType
	}
	return 0
}

func (m *GetMessageResponse) GetPubAccountCookie() []byte {
	if m != nil {
		return m.PubAccountCookie
	}
	return nil
}

func (m *GetMessageResponse) GetIsPartialSync() bool {
	if m != nil {
		return m.IsPartialSync
	}
	return false
}

func (m *GetMessageResponse) GetMsgCtrlBuf() []byte {
	if m != nil {
		return m.MsgCtrlBuf
	}
	return nil
}

type PushMessagePacket struct {
	Message     *Message `protobuf:"bytes,1,opt,name=message" json:"message,omitempty"`
	Svrip       int32    `protobuf:"varint,2,opt,name=svrip" json:"svrip"`
	PushToken   []byte   `protobuf:"bytes,3,opt,name=pushToken" json:"pushToken"`
	PingFLag    int32    `protobuf:"varint,4,opt,name=pingFLag" json:"pingFLag"`
	GeneralFlag int32    `protobuf:"varint,9,opt,name=generalFlag" json:"generalFlag"`
}

func (m *PushMessagePacket) Reset()         { *m = PushMessagePacket{} }
func (m *PushMessagePacket) String() string { return proto.CompactTextString(m) }
func (*PushMessagePacket) ProtoMessage()    {}
func (*PushMessagePacket) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{17}
}
func (m *PushMessagePacket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PushMessagePacket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PushMessagePacket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PushMessagePacket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PushMessagePacket.Merge(m, src)
}
func (m *PushMessagePacket) XXX_Size() int {
	return m.Size()
}
func (m *PushMessagePacket) XXX_DiscardUnknown() {
	xxx_messageInfo_PushMessagePacket.DiscardUnknown(m)
}

var xxx_messageInfo_PushMessagePacket proto.InternalMessageInfo

func (m *PushMessagePacket) GetMessage() *Message {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *PushMessagePacket) GetSvrip() int32 {
	if m != nil {
		return m.Svrip
	}
	return 0
}

func (m *PushMessagePacket) GetPushToken() []byte {
	if m != nil {
		return m.PushToken
	}
	return nil
}

func (m *PushMessagePacket) GetPingFLag() int32 {
	if m != nil {
		return m.PingFLag
	}
	return 0
}

func (m *PushMessagePacket) GetGeneralFlag() int32 {
	if m != nil {
		return m.GeneralFlag
	}
	return 0
}

type UinPairMessage struct {
	LastReadTime int32      `protobuf:"varint,1,opt,name=lastReadTime" json:"lastReadTime"`
	PeerUin      int64      `protobuf:"varint,2,opt,name=peerUin" json:"peerUin"`
	MsgCompleted int32      `protobuf:"varint,3,opt,name=msgCompleted" json:"msgCompleted"`
	Messages     []*Message `protobuf:"bytes,4,rep,name=messages" json:"messages,omitempty"`
}

func (m *UinPairMessage) Reset()         { *m = UinPairMessage{} }
func (m *UinPairMessage) String() string { return proto.CompactTextString(m) }
func (*UinPairMessage) ProtoMessage()    {}
func (*UinPairMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{18}
}
func (m *UinPairMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UinPairMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UinPairMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UinPairMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UinPairMessage.Merge(m, src)
}
func (m *UinPairMessage) XXX_Size() int {
	return m.Size()
}
func (m *UinPairMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_UinPairMessage.DiscardUnknown(m)
}

var xxx_messageInfo_UinPairMessage proto.InternalMessageInfo

func (m *UinPairMessage) GetLastReadTime() int32 {
	if m != nil {
		return m.LastReadTime
	}
	return 0
}

func (m *UinPairMessage) GetPeerUin() int64 {
	if m != nil {
		return m.PeerUin
	}
	return 0
}

func (m *UinPairMessage) GetMsgCompleted() int32 {
	if m != nil {
		return m.MsgCompleted
	}
	return 0
}

func (m *UinPairMessage) GetMessages() []*Message {
	if m != nil {
		return m.Messages
	}
	return nil
}

type Message struct {
	Head    *MessageHead `protobuf:"bytes,1,opt,name=head" json:"head,omitempty"`
	Content *ContentHead `protobuf:"bytes,2,opt,name=content" json:"content,omitempty"`
	Body    *MessageBody `protobuf:"bytes,3,opt,name=body" json:"body,omitempty"`
}

func (m *Message) Reset()         { *m = Message{} }
func (m *Message) String() string { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()    {}
func (*Message) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{19}
}
func (m *Message) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Message) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Message.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Message) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message.Merge(m, src)
}
func (m *Message) XXX_Size() int {
	return m.Size()
}
func (m *Message) XXX_DiscardUnknown() {
	xxx_messageInfo_Message.DiscardUnknown(m)
}

var xxx_messageInfo_Message proto.InternalMessageInfo

func (m *Message) GetHead() *MessageHead {
	if m != nil {
		return m.Head
	}
	return nil
}

func (m *Message) GetContent() *ContentHead {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *Message) GetBody() *MessageBody {
	if m != nil {
		return m.Body
	}
	return nil
}

type MessageBody struct {
	RichText          *RichText `protobuf:"bytes,1,opt,name=richText" json:"richText,omitempty"`
	MsgContent        []byte    `protobuf:"bytes,2,opt,name=msgContent" json:"msgContent"`
	MsgEncryptContent []byte    `protobuf:"bytes,3,opt,name=msgEncryptContent" json:"msgEncryptContent"`
}

func (m *MessageBody) Reset()         { *m = MessageBody{} }
func (m *MessageBody) String() string { return proto.CompactTextString(m) }
func (*MessageBody) ProtoMessage()    {}
func (*MessageBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{20}
}
func (m *MessageBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageBody.Merge(m, src)
}
func (m *MessageBody) XXX_Size() int {
	return m.Size()
}
func (m *MessageBody) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageBody.DiscardUnknown(m)
}

var xxx_messageInfo_MessageBody proto.InternalMessageInfo

func (m *MessageBody) GetRichText() *RichText {
	if m != nil {
		return m.RichText
	}
	return nil
}

func (m *MessageBody) GetMsgContent() []byte {
	if m != nil {
		return m.MsgContent
	}
	return nil
}

func (m *MessageBody) GetMsgEncryptContent() []byte {
	if m != nil {
		return m.MsgEncryptContent
	}
	return nil
}

type RichText struct {
	Attr          *Attr          `protobuf:"bytes,1,opt,name=attr" json:"attr,omitempty"`
	Elems         []*Elem        `protobuf:"bytes,2,rep,name=elems" json:"elems,omitempty"`
	NotOnlineFile *NotOnlineFile `protobuf:"bytes,3,opt,name=notOnlineFile" json:"notOnlineFile,omitempty"`
	Ptt           *Ptt           `protobuf:"bytes,4,opt,name=ptt" json:"ptt,omitempty"`
}

func (m *RichText) Reset()         { *m = RichText{} }
func (m *RichText) String() string { return proto.CompactTextString(m) }
func (*RichText) ProtoMessage()    {}
func (*RichText) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{21}
}
func (m *RichText) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RichText) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RichText.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RichText) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RichText.Merge(m, src)
}
func (m *RichText) XXX_Size() int {
	return m.Size()
}
func (m *RichText) XXX_DiscardUnknown() {
	xxx_messageInfo_RichText.DiscardUnknown(m)
}

var xxx_messageInfo_RichText proto.InternalMessageInfo

func (m *RichText) GetAttr() *Attr {
	if m != nil {
		return m.Attr
	}
	return nil
}

func (m *RichText) GetElems() []*Elem {
	if m != nil {
		return m.Elems
	}
	return nil
}

func (m *RichText) GetNotOnlineFile() *NotOnlineFile {
	if m != nil {
		return m.NotOnlineFile
	}
	return nil
}

func (m *RichText) GetPtt() *Ptt {
	if m != nil {
		return m.Ptt
	}
	return nil
}

type Elem struct {
	Text           *Text           `protobuf:"bytes,1,opt,name=text" json:"text,omitempty"`
	Face           *Face           `protobuf:"bytes,2,opt,name=face" json:"face,omitempty"`
	OnlineImage    *OnlineImage    `protobuf:"bytes,3,opt,name=onlineImage" json:"onlineImage,omitempty"`
	NotOnlineImage *NotOnlineImage `protobuf:"bytes,4,opt,name=notOnlineImage" json:"notOnlineImage,omitempty"`
	TransElemInfo  *TransElem      `protobuf:"bytes,5,opt,name=transElemInfo" json:"transElemInfo,omitempty"`
	//MarketFace marketFace = 6;
	//ElemFlags elemFlags = 7;
	CustomFace *CustomFace `protobuf:"bytes,8,opt,name=customFace" json:"customFace,omitempty"`
	//ElemFlags2 elemFlags2 = 9;
	//FunFace funFace = 10;
	//SecretFileMsg secretFile = 11;
	RichMsg   *RichMsg   `protobuf:"bytes,12,opt,name=richMsg" json:"richMsg,omitempty"`
	GroupFile *GroupFile `protobuf:"bytes,13,opt,name=groupFile" json:"groupFile,omitempty"`
	//PubGroup pubGroup = 14;
	//MarketTrans marketTrans = 15;
	ExtraInfo *ExtraInfo `protobuf:"bytes,16,opt,name=extraInfo" json:"extraInfo,omitempty"`
	//ShakeWindow? shakeWindow = 17;
	//PubAccount? pubAccount = 18;
	VideoFile *VideoFile `protobuf:"bytes,19,opt,name=videoFile" json:"videoFile,omitempty"`
	//TipsInfo? tipsInfo = 20;
	AnonGroupMsg *AnonymousGroupMessage `protobuf:"bytes,21,opt,name=anonGroupMsg" json:"anonGroupMsg,omitempty"`
	//QQLiveOld? qqLiveOld = 22;
	//LifeOnlineAccount? lifeOnline = 23;
	QQWalletMsg *QQWalletMsg `protobuf:"bytes,24,opt,name=QQWalletMsg" json:"QQWalletMsg,omitempty"`
	//CrmElem? crmElem = 25;
	//ConferenceTipsInfo? conferenceTipsInfo = 26;
	//RedBagInfo? redbagInfo = 27;
	//LowVersionTips? lowVersionTips = 28;
	//bytes bankcodeCtrlInfo = 29;
	//NearByMessageType? nearByMsg = 30;
	CustomElem *CustomElem `protobuf:"bytes,31,opt,name=customElem" json:"customElem,omitempty"`
	//LocationInfo? locationInfo = 32;
	//PubAccInfo? pubAccInfo = 33;
	//SmallEmoji? smallEmoji = 34;
	//FSJMessageElem? fsjMsgElem = 35;
	//ArkAppElem? arkApp = 36;
	GeneralFlags *GeneralFlags `protobuf:"bytes,37,opt,name=generalFlags" json:"generalFlags,omitempty"`
	//CustomFace? hcFlashPic = 38;
	//DeliverGiftMsg? deliverGiftMsg = 39;
	//BitAppMsg? bitappMsg = 40;
	//OpenQQData? openQqData = 41;
	//ApolloActMsg? apolloMsg = 42;
	//GroupPubAccountInfo? groupPubAccInfo = 43;
	//BlessingMessage? blessMsg = 44;
	SrcMsg *SourceMsg `protobuf:"bytes,45,opt,name=srcMsg" json:"srcMsg,omitempty"`
	//LolaMsg? lolaMsg = 46;
	//GroupBusinessMsg? groupBusinessMsg = 47;
	//WorkflowNotifyMsg? msgWorkflowNotify = 48;
	//PatsElem? patElem = 49;
	//GroupPostElem? groupPostElem = 50;
	LightApp *LightAppElem `protobuf:"bytes,51,opt,name=lightApp" json:"lightApp,omitempty"`
	//EIMInfo? eimInfo = 52;
	CommonElem *CommonElem `protobuf:"bytes,53,opt,name=commonElem" json:"commonElem,omitempty"`
}

func (m *Elem) Reset()         { *m = Elem{} }
func (m *Elem) String() string { return proto.CompactTextString(m) }
func (*Elem) ProtoMessage()    {}
func (*Elem) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{22}
}
func (m *Elem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Elem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Elem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Elem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Elem.Merge(m, src)
}
func (m *Elem) XXX_Size() int {
	return m.Size()
}
func (m *Elem) XXX_DiscardUnknown() {
	xxx_messageInfo_Elem.DiscardUnknown(m)
}

var xxx_messageInfo_Elem proto.InternalMessageInfo

func (m *Elem) GetText() *Text {
	if m != nil {
		return m.Text
	}
	return nil
}

func (m *Elem) GetFace() *Face {
	if m != nil {
		return m.Face
	}
	return nil
}

func (m *Elem) GetOnlineImage() *OnlineImage {
	if m != nil {
		return m.OnlineImage
	}
	return nil
}

func (m *Elem) GetNotOnlineImage() *NotOnlineImage {
	if m != nil {
		return m.NotOnlineImage
	}
	return nil
}

func (m *Elem) GetTransElemInfo() *TransElem {
	if m != nil {
		return m.TransElemInfo
	}
	return nil
}

func (m *Elem) GetCustomFace() *CustomFace {
	if m != nil {
		return m.CustomFace
	}
	return nil
}

func (m *Elem) GetRichMsg() *RichMsg {
	if m != nil {
		return m.RichMsg
	}
	return nil
}

func (m *Elem) GetGroupFile() *GroupFile {
	if m != nil {
		return m.GroupFile
	}
	return nil
}

func (m *Elem) GetExtraInfo() *ExtraInfo {
	if m != nil {
		return m.ExtraInfo
	}
	return nil
}

func (m *Elem) GetVideoFile() *VideoFile {
	if m != nil {
		return m.VideoFile
	}
	return nil
}

func (m *Elem) GetAnonGroupMsg() *AnonymousGroupMessage {
	if m != nil {
		return m.AnonGroupMsg
	}
	return nil
}

func (m *Elem) GetQQWalletMsg() *QQWalletMsg {
	if m != nil {
		return m.QQWalletMsg
	}
	return nil
}

func (m *Elem) GetCustomElem() *CustomElem {
	if m != nil {
		return m.CustomElem
	}
	return nil
}

func (m *Elem) GetGeneralFlags() *GeneralFlags {
	if m != nil {
		return m.GeneralFlags
	}
	return nil
}

func (m *Elem) GetSrcMsg() *SourceMsg {
	if m != nil {
		return m.SrcMsg
	}
	return nil
}

func (m *Elem) GetLightApp() *LightAppElem {
	if m != nil {
		return m.LightApp
	}
	return nil
}

func (m *Elem) GetCommonElem() *CommonElem {
	if m != nil {
		return m.CommonElem
	}
	return nil
}

type CommonElem struct {
	ServiceType  int32  `protobuf:"varint,1,opt,name=serviceType" json:"serviceType"`
	PbElem       []byte `protobuf:"bytes,2,opt,name=pbElem" json:"pbElem"`
	BusinessType int32  `protobuf:"varint,3,opt,name=businessType" json:"businessType"`
}

func (m *CommonElem) Reset()         { *m = CommonElem{} }
func (m *CommonElem) String() string { return proto.CompactTextString(m) }
func (*CommonElem) ProtoMessage()    {}
func (*CommonElem) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{23}
}
func (m *CommonElem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommonElem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommonElem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommonElem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommonElem.Merge(m, src)
}
func (m *CommonElem) XXX_Size() int {
	return m.Size()
}
func (m *CommonElem) XXX_DiscardUnknown() {
	xxx_messageInfo_CommonElem.DiscardUnknown(m)
}

var xxx_messageInfo_CommonElem proto.InternalMessageInfo

func (m *CommonElem) GetServiceType() int32 {
	if m != nil {
		return m.ServiceType
	}
	return 0
}

func (m *CommonElem) GetPbElem() []byte {
	if m != nil {
		return m.PbElem
	}
	return nil
}

func (m *CommonElem) GetBusinessType() int32 {
	if m != nil {
		return m.BusinessType
	}
	return 0
}

type QQWalletMsg struct {
	AioBody *QQWalletAioBody `protobuf:"bytes,1,opt,name=aioBody" json:"aioBody,omitempty"`
}

func (m *QQWalletMsg) Reset()         { *m = QQWalletMsg{} }
func (m *QQWalletMsg) String() string { return proto.CompactTextString(m) }
func (*QQWalletMsg) ProtoMessage()    {}
func (*QQWalletMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{24}
}
func (m *QQWalletMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QQWalletMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QQWalletMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QQWalletMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QQWalletMsg.Merge(m, src)
}
func (m *QQWalletMsg) XXX_Size() int {
	return m.Size()
}
func (m *QQWalletMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_QQWalletMsg.DiscardUnknown(m)
}

var xxx_messageInfo_QQWalletMsg proto.InternalMessageInfo

func (m *QQWalletMsg) GetAioBody() *QQWalletAioBody {
	if m != nil {
		return m.AioBody
	}
	return nil
}

type QQWalletAioBody struct {
	SendUin     uint64           `protobuf:"varint,1,opt,name=sendUin" json:"sendUin"`
	Sender      *QQWalletAioElem `protobuf:"bytes,2,opt,name=sender" json:"sender,omitempty"`
	Receiver    *QQWalletAioElem `protobuf:"bytes,3,opt,name=receiver" json:"receiver,omitempty"`
	ChannelId   int32            `protobuf:"zigzag32,4,opt,name=ChannelId" json:"ChannelId"`
	TemplateId  int32            `protobuf:"zigzag32,5,opt,name=templateId" json:"templateId"`
	Resend      uint32           `protobuf:"varint,6,opt,name=resend" json:"resend"`
	MsgPriority uint32           `protobuf:"varint,7,opt,name=msgPriority" json:"msgPriority"`
	RedType     int32            `protobuf:"zigzag32,8,opt,name=redType" json:"redType"`
	BillNo      []byte           `protobuf:"bytes,9,opt,name=billNo" json:"billNo"`
	AuthKey     []byte           `protobuf:"bytes,10,opt,name=authKey" json:"authKey"`
	SessionType int32            `protobuf:"zigzag32,11,opt,name=sessionType" json:"sessionType"`
	MsgType     int32            `protobuf:"zigzag32,12,opt,name=msgType" json:"msgType"`
	EnvelOpeId  int32            `protobuf:"zigzag32,13,opt,name=envelOpeId" json:"envelOpeId"`
	Name        []byte           `protobuf:"bytes,14,opt,name=name" json:"name"`
	ConfType    int32            `protobuf:"zigzag32,15,opt,name=confType" json:"confType"`
	MsgFrom     int32            `protobuf:"zigzag32,16,opt,name=msgFrom" json:"msgFrom"`
	PcBody      []byte           `protobuf:"bytes,17,opt,name=pcBody" json:"pcBody"`
	Index       []byte           `protobuf:"bytes,18,opt,name=index" json:"index"`
	RedChannel  uint32           `protobuf:"varint,19,opt,name=redChannel" json:"redChannel"`
	GrapUin     []uint64         `protobuf:"varint,20,rep,name=grapUin" json:"grapUin,omitempty"`
	PbReserve   []byte           `protobuf:"bytes,21,opt,name=pbReserve" json:"pbReserve"`
}

func (m *QQWalletAioBody) Reset()         { *m = QQWalletAioBody{} }
func (m *QQWalletAioBody) String() string { return proto.CompactTextString(m) }
func (*QQWalletAioBody) ProtoMessage()    {}
func (*QQWalletAioBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{25}
}
func (m *QQWalletAioBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QQWalletAioBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QQWalletAioBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QQWalletAioBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QQWalletAioBody.Merge(m, src)
}
func (m *QQWalletAioBody) XXX_Size() int {
	return m.Size()
}
func (m *QQWalletAioBody) XXX_DiscardUnknown() {
	xxx_messageInfo_QQWalletAioBody.DiscardUnknown(m)
}

var xxx_messageInfo_QQWalletAioBody proto.InternalMessageInfo

func (m *QQWalletAioBody) GetSendUin() uint64 {
	if m != nil {
		return m.SendUin
	}
	return 0
}

func (m *QQWalletAioBody) GetSender() *QQWalletAioElem {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *QQWalletAioBody) GetReceiver() *QQWalletAioElem {
	if m != nil {
		return m.Receiver
	}
	return nil
}

func (m *QQWalletAioBody) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *QQWalletAioBody) GetTemplateId() int32 {
	if m != nil {
		return m.TemplateId
	}
	return 0
}

func (m *QQWalletAioBody) GetResend() uint32 {
	if m != nil {
		return m.Resend
	}
	return 0
}

func (m *QQWalletAioBody) GetMsgPriority() uint32 {
	if m != nil {
		return m.MsgPriority
	}
	return 0
}

func (m *QQWalletAioBody) GetRedType() int32 {
	if m != nil {
		return m.RedType
	}
	return 0
}

func (m *QQWalletAioBody) GetBillNo() []byte {
	if m != nil {
		return m.BillNo
	}
	return nil
}

func (m *QQWalletAioBody) GetAuthKey() []byte {
	if m != nil {
		return m.AuthKey
	}
	return nil
}

func (m *QQWalletAioBody) GetSessionType() int32 {
	if m != nil {
		return m.SessionType
	}
	return 0
}

func (m *QQWalletAioBody) GetMsgType() int32 {
	if m != nil {
		return m.MsgType
	}
	return 0
}

func (m *QQWalletAioBody) GetEnvelOpeId() int32 {
	if m != nil {
		return m.EnvelOpeId
	}
	return 0
}

func (m *QQWalletAioBody) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *QQWalletAioBody) GetConfType() int32 {
	if m != nil {
		return m.ConfType
	}
	return 0
}

func (m *QQWalletAioBody) GetMsgFrom() int32 {
	if m != nil {
		return m.MsgFrom
	}
	return 0
}

func (m *QQWalletAioBody) GetPcBody() []byte {
	if m != nil {
		return m.PcBody
	}
	return nil
}

func (m *QQWalletAioBody) GetIndex() []byte {
	if m != nil {
		return m.Index
	}
	return nil
}

func (m *QQWalletAioBody) GetRedChannel() uint32 {
	if m != nil {
		return m.RedChannel
	}
	return 0
}

func (m *QQWalletAioBody) GetGrapUin() []uint64 {
	if m != nil {
		return m.GrapUin
	}
	return nil
}

func (m *QQWalletAioBody) GetPbReserve() []byte {
	if m != nil {
		return m.PbReserve
	}
	return nil
}

type QQWalletAioElem struct {
	Background      uint32 `protobuf:"varint,1,opt,name=background" json:"background"`
	Icon            uint32 `protobuf:"varint,2,opt,name=icon" json:"icon"`
	Title           string `protobuf:"bytes,3,opt,name=title" json:"title"`
	Subtitle        string `protobuf:"bytes,4,opt,name=subtitle" json:"subtitle"`
	Content         string `protobuf:"bytes,5,opt,name=content" json:"content"`
	LinkUrl         []byte `protobuf:"bytes,6,opt,name=linkUrl" json:"linkUrl"`
	BlackStripe     []byte `protobuf:"bytes,7,opt,name=blackStripe" json:"blackStripe"`
	Notice          []byte `protobuf:"bytes,8,opt,name=notice" json:"notice"`
	TitleColor      uint32 `protobuf:"varint,9,opt,name=titleColor" json:"titleColor"`
	SubtitleColor   uint32 `protobuf:"varint,10,opt,name=subtitleColor" json:"subtitleColor"`
	ActionsPriority []byte `protobuf:"bytes,11,opt,name=actionsPriority" json:"actionsPriority"`
	JumpUrl         []byte `protobuf:"bytes,12,opt,name=jumpUrl" json:"jumpUrl"`
	NativeIos       []byte `protobuf:"bytes,13,opt,name=nativeIos" json:"nativeIos"`
	NativeAndroid   []byte `protobuf:"bytes,14,opt,name=nativeAndroid" json:"nativeAndroid"`
	IconUrl         []byte `protobuf:"bytes,15,opt,name=iconUrl" json:"iconUrl"`
	ContentColor    uint32 `protobuf:"varint,16,opt,name=contentColor" json:"contentColor"`
	ContentBgColor  uint32 `protobuf:"varint,17,opt,name=contentBgColor" json:"contentBgColor"`
	AioImageLeft    []byte `protobuf:"bytes,18,opt,name=aioImageLeft" json:"aioImageLeft"`
	AioImageRight   []byte `protobuf:"bytes,19,opt,name=aioImageRight" json:"aioImageRight"`
	CftImage        []byte `protobuf:"bytes,20,opt,name=cftImage" json:"cftImage"`
	PbReserve       []byte `protobuf:"bytes,21,opt,name=pbReserve" json:"pbReserve"`
}

func (m *QQWalletAioElem) Reset()         { *m = QQWalletAioElem{} }
func (m *QQWalletAioElem) String() string { return proto.CompactTextString(m) }
func (*QQWalletAioElem) ProtoMessage()    {}
func (*QQWalletAioElem) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{26}
}
func (m *QQWalletAioElem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QQWalletAioElem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QQWalletAioElem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QQWalletAioElem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QQWalletAioElem.Merge(m, src)
}
func (m *QQWalletAioElem) XXX_Size() int {
	return m.Size()
}
func (m *QQWalletAioElem) XXX_DiscardUnknown() {
	xxx_messageInfo_QQWalletAioElem.DiscardUnknown(m)
}

var xxx_messageInfo_QQWalletAioElem proto.InternalMessageInfo

func (m *QQWalletAioElem) GetBackground() uint32 {
	if m != nil {
		return m.Background
	}
	return 0
}

func (m *QQWalletAioElem) GetIcon() uint32 {
	if m != nil {
		return m.Icon
	}
	return 0
}

func (m *QQWalletAioElem) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *QQWalletAioElem) GetSubtitle() string {
	if m != nil {
		return m.Subtitle
	}
	return ""
}

func (m *QQWalletAioElem) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *QQWalletAioElem) GetLinkUrl() []byte {
	if m != nil {
		return m.LinkUrl
	}
	return nil
}

func (m *QQWalletAioElem) GetBlackStripe() []byte {
	if m != nil {
		return m.BlackStripe
	}
	return nil
}

func (m *QQWalletAioElem) GetNotice() []byte {
	if m != nil {
		return m.Notice
	}
	return nil
}

func (m *QQWalletAioElem) GetTitleColor() uint32 {
	if m != nil {
		return m.TitleColor
	}
	return 0
}

func (m *QQWalletAioElem) GetSubtitleColor() uint32 {
	if m != nil {
		return m.SubtitleColor
	}
	return 0
}

func (m *QQWalletAioElem) GetActionsPriority() []byte {
	if m != nil {
		return m.ActionsPriority
	}
	return nil
}

func (m *QQWalletAioElem) GetJumpUrl() []byte {
	if m != nil {
		return m.JumpUrl
	}
	return nil
}

func (m *QQWalletAioElem) GetNativeIos() []byte {
	if m != nil {
		return m.NativeIos
	}
	return nil
}

func (m *QQWalletAioElem) GetNativeAndroid() []byte {
	if m != nil {
		return m.NativeAndroid
	}
	return nil
}

func (m *QQWalletAioElem) GetIconUrl() []byte {
	if m != nil {
		return m.IconUrl
	}
	return nil
}

func (m *QQWalletAioElem) GetContentColor() uint32 {
	if m != nil {
		return m.ContentColor
	}
	return 0
}

func (m *QQWalletAioElem) GetContentBgColor() uint32 {
	if m != nil {
		return m.ContentBgColor
	}
	return 0
}

func (m *QQWalletAioElem) GetAioImageLeft() []byte {
	if m != nil {
		return m.AioImageLeft
	}
	return nil
}

func (m *QQWalletAioElem) GetAioImageRight() []byte {
	if m != nil {
		return m.AioImageRight
	}
	return nil
}

func (m *QQWalletAioElem) GetCftImage() []byte {
	if m != nil {
		return m.CftImage
	}
	return nil
}

func (m *QQWalletAioElem) GetPbReserve() []byte {
	if m != nil {
		return m.PbReserve
	}
	return nil
}

type RichMsg struct {
	Template1 []byte `protobuf:"bytes,1,opt,name=template1" json:"template1"`
	ServiceId int32  `protobuf:"varint,2,opt,name=serviceId" json:"serviceId"`
	MsgResId  []byte `protobuf:"bytes,3,opt,name=msgResId" json:"msgResId"`
	Rand      int32  `protobuf:"varint,4,opt,name=rand" json:"rand"`
	Seq       int32  `protobuf:"varint,5,opt,name=seq" json:"seq"`
}

func (m *RichMsg) Reset()         { *m = RichMsg{} }
func (m *RichMsg) String() string { return proto.CompactTextString(m) }
func (*RichMsg) ProtoMessage()    {}
func (*RichMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{27}
}
func (m *RichMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RichMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RichMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RichMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RichMsg.Merge(m, src)
}
func (m *RichMsg) XXX_Size() int {
	return m.Size()
}
func (m *RichMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_RichMsg.DiscardUnknown(m)
}

var xxx_messageInfo_RichMsg proto.InternalMessageInfo

func (m *RichMsg) GetTemplate1() []byte {
	if m != nil {
		return m.Template1
	}
	return nil
}

func (m *RichMsg) GetServiceId() int32 {
	if m != nil {
		return m.ServiceId
	}
	return 0
}

func (m *RichMsg) GetMsgResId() []byte {
	if m != nil {
		return m.MsgResId
	}
	return nil
}

func (m *RichMsg) GetRand() int32 {
	if m != nil {
		return m.Rand
	}
	return 0
}

func (m *RichMsg) GetSeq() int32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

type CustomElem struct {
	Desc     []byte `protobuf:"bytes,1,opt,name=desc" json:"desc"`
	Data     []byte `protobuf:"bytes,2,opt,name=data" json:"data"`
	EnumType int32  `protobuf:"varint,3,opt,name=enumType" json:"enumType"`
	Ext      []byte `protobuf:"bytes,4,opt,name=ext" json:"ext"`
	Sound    []byte `protobuf:"bytes,5,opt,name=sound" json:"sound"`
}

func (m *CustomElem) Reset()         { *m = CustomElem{} }
func (m *CustomElem) String() string { return proto.CompactTextString(m) }
func (*CustomElem) ProtoMessage()    {}
func (*CustomElem) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{28}
}
func (m *CustomElem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CustomElem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CustomElem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CustomElem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CustomElem.Merge(m, src)
}
func (m *CustomElem) XXX_Size() int {
	return m.Size()
}
func (m *CustomElem) XXX_DiscardUnknown() {
	xxx_messageInfo_CustomElem.DiscardUnknown(m)
}

var xxx_messageInfo_CustomElem proto.InternalMessageInfo

func (m *CustomElem) GetDesc() []byte {
	if m != nil {
		return m.Desc
	}
	return nil
}

func (m *CustomElem) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *CustomElem) GetEnumType() int32 {
	if m != nil {
		return m.EnumType
	}
	return 0
}

func (m *CustomElem) GetExt() []byte {
	if m != nil {
		return m.Ext
	}
	return nil
}

func (m *CustomElem) GetSound() []byte {
	if m != nil {
		return m.Sound
	}
	return nil
}

type Text struct {
	Str       string `protobuf:"bytes,1,opt,name=str" json:"str"`
	Link      string `protobuf:"bytes,2,opt,name=link" json:"link"`
	Attr6Buf  []byte `protobuf:"bytes,3,opt,name=attr6Buf" json:"attr6Buf"`
	Attr7Buf  []byte `protobuf:"bytes,4,opt,name=attr7Buf" json:"attr7Buf"`
	Buf       []byte `protobuf:"bytes,11,opt,name=buf" json:"buf"`
	PbReserve []byte `protobuf:"bytes,12,opt,name=pbReserve" json:"pbReserve"`
}

func (m *Text) Reset()         { *m = Text{} }
func (m *Text) String() string { return proto.CompactTextString(m) }
func (*Text) ProtoMessage()    {}
func (*Text) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{29}
}
func (m *Text) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Text) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Text.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Text) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Text.Merge(m, src)
}
func (m *Text) XXX_Size() int {
	return m.Size()
}
func (m *Text) XXX_DiscardUnknown() {
	xxx_messageInfo_Text.DiscardUnknown(m)
}

var xxx_messageInfo_Text proto.InternalMessageInfo

func (m *Text) GetStr() string {
	if m != nil {
		return m.Str
	}
	return ""
}

func (m *Text) GetLink() string {
	if m != nil {
		return m.Link
	}
	return ""
}

func (m *Text) GetAttr6Buf() []byte {
	if m != nil {
		return m.Attr6Buf
	}
	return nil
}

func (m *Text) GetAttr7Buf() []byte {
	if m != nil {
		return m.Attr7Buf
	}
	return nil
}

func (m *Text) GetBuf() []byte {
	if m != nil {
		return m.Buf
	}
	return nil
}

func (m *Text) GetPbReserve() []byte {
	if m != nil {
		return m.PbReserve
	}
	return nil
}

type Attr struct {
	CodePage       int32  `protobuf:"varint,1,opt,name=codePage" json:"codePage"`
	Time           int32  `protobuf:"varint,2,opt,name=time" json:"time"`
	Random         int32  `protobuf:"varint,3,opt,name=random" json:"random"`
	Color          int32  `protobuf:"varint,4,opt,name=color" json:"color"`
	Size_          int32  `protobuf:"varint,5,opt,name=size" json:"size"`
	Effect         int32  `protobuf:"varint,6,opt,name=effect" json:"effect"`
	CharSet        int32  `protobuf:"varint,7,opt,name=charSet" json:"charSet"`
	PitchAndFamily int32  `protobuf:"varint,8,opt,name=pitchAndFamily" json:"pitchAndFamily"`
	FontName       string `protobuf:"bytes,9,opt,name=fontName" json:"fontName"`
	ReserveData    []byte `protobuf:"bytes,10,opt,name=reserveData" json:"reserveData"`
}

func (m *Attr) Reset()         { *m = Attr{} }
func (m *Attr) String() string { return proto.CompactTextString(m) }
func (*Attr) ProtoMessage()    {}
func (*Attr) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{30}
}
func (m *Attr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Attr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Attr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Attr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Attr.Merge(m, src)
}
func (m *Attr) XXX_Size() int {
	return m.Size()
}
func (m *Attr) XXX_DiscardUnknown() {
	xxx_messageInfo_Attr.DiscardUnknown(m)
}

var xxx_messageInfo_Attr proto.InternalMessageInfo

func (m *Attr) GetCodePage() int32 {
	if m != nil {
		return m.CodePage
	}
	return 0
}

func (m *Attr) GetTime() int32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *Attr) GetRandom() int32 {
	if m != nil {
		return m.Random
	}
	return 0
}

func (m *Attr) GetColor() int32 {
	if m != nil {
		return m.Color
	}
	return 0
}

func (m *Attr) GetSize_() int32 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *Attr) GetEffect() int32 {
	if m != nil {
		return m.Effect
	}
	return 0
}

func (m *Attr) GetCharSet() int32 {
	if m != nil {
		return m.CharSet
	}
	return 0
}

func (m *Attr) GetPitchAndFamily() int32 {
	if m != nil {
		return m.PitchAndFamily
	}
	return 0
}

func (m *Attr) GetFontName() string {
	if m != nil {
		return m.FontName
	}
	return ""
}

func (m *Attr) GetReserveData() []byte {
	if m != nil {
		return m.ReserveData
	}
	return nil
}

type Ptt struct {
	FileType      int32    `protobuf:"varint,1,opt,name=fileType" json:"fileType"`
	SrcUin        int64    `protobuf:"varint,2,opt,name=srcUin" json:"srcUin"`
	FileUuid      []byte   `protobuf:"bytes,3,opt,name=fileUuid" json:"fileUuid"`
	FileMd5       []byte   `protobuf:"bytes,4,opt,name=fileMd5" json:"fileMd5"`
	FileName      string   `protobuf:"bytes,5,opt,name=fileName" json:"fileName"`
	FileSize      int32    `protobuf:"varint,6,opt,name=fileSize" json:"fileSize"`
	Reserve       []byte   `protobuf:"bytes,7,opt,name=reserve" json:"reserve"`
	FileId        int32    `protobuf:"varint,8,opt,name=fileId" json:"fileId"`
	ServerIp      int32    `protobuf:"varint,9,opt,name=serverIp" json:"serverIp"`
	ServerPort    int32    `protobuf:"varint,10,opt,name=serverPort" json:"serverPort"`
	BoolValid     bool     `protobuf:"varint,11,opt,name=boolValid" json:"boolValid"`
	Signature     []byte   `protobuf:"bytes,12,opt,name=signature" json:"signature"`
	Shortcut      []byte   `protobuf:"bytes,13,opt,name=shortcut" json:"shortcut"`
	FileKey       []byte   `protobuf:"bytes,14,opt,name=fileKey" json:"fileKey"`
	MagicPttIndex int32    `protobuf:"varint,15,opt,name=magicPttIndex" json:"magicPttIndex"`
	VoiceSwitch   int32    `protobuf:"varint,16,opt,name=voiceSwitch" json:"voiceSwitch"`
	PttUrl        []byte   `protobuf:"bytes,17,opt,name=pttUrl" json:"pttUrl"`
	GroupFileKey  []byte   `protobuf:"bytes,18,opt,name=groupFileKey" json:"groupFileKey"`
	Time          int32    `protobuf:"varint,19,opt,name=time" json:"time"`
	DownPara      []byte   `protobuf:"bytes,20,opt,name=downPara" json:"downPara"`
	Format        int32    `protobuf:"varint,29,opt,name=format" json:"format"`
	PbReserve     []byte   `protobuf:"bytes,30,opt,name=pbReserve" json:"pbReserve"`
	BytesPttUrls  [][]byte `protobuf:"bytes,31,rep,name=bytesPttUrls" json:"bytesPttUrls,omitempty"`
	DownloadFlag  int32    `protobuf:"varint,32,opt,name=downloadFlag" json:"downloadFlag"`
}

func (m *Ptt) Reset()         { *m = Ptt{} }
func (m *Ptt) String() string { return proto.CompactTextString(m) }
func (*Ptt) ProtoMessage()    {}
func (*Ptt) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{31}
}
func (m *Ptt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ptt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Ptt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Ptt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ptt.Merge(m, src)
}
func (m *Ptt) XXX_Size() int {
	return m.Size()
}
func (m *Ptt) XXX_DiscardUnknown() {
	xxx_messageInfo_Ptt.DiscardUnknown(m)
}

var xxx_messageInfo_Ptt proto.InternalMessageInfo

func (m *Ptt) GetFileType() int32 {
	if m != nil {
		return m.FileType
	}
	return 0
}

func (m *Ptt) GetSrcUin() int64 {
	if m != nil {
		return m.SrcUin
	}
	return 0
}

func (m *Ptt) GetFileUuid() []byte {
	if m != nil {
		return m.FileUuid
	}
	return nil
}

func (m *Ptt) GetFileMd5() []byte {
	if m != nil {
		return m.FileMd5
	}
	return nil
}

func (m *Ptt) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *Ptt) GetFileSize() int32 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *Ptt) GetReserve() []byte {
	if m != nil {
		return m.Reserve
	}
	return nil
}

func (m *Ptt) GetFileId() int32 {
	if m != nil {
		return m.FileId
	}
	return 0
}

func (m *Ptt) GetServerIp() int32 {
	if m != nil {
		return m.ServerIp
	}
	return 0
}

func (m *Ptt) GetServerPort() int32 {
	if m != nil {
		return m.ServerPort
	}
	return 0
}

func (m *Ptt) GetBoolValid() bool {
	if m != nil {
		return m.BoolValid
	}
	return false
}

func (m *Ptt) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *Ptt) GetShortcut() []byte {
	if m != nil {
		return m.Shortcut
	}
	return nil
}

func (m *Ptt) GetFileKey() []byte {
	if m != nil {
		return m.FileKey
	}
	return nil
}

func (m *Ptt) GetMagicPttIndex() int32 {
	if m != nil {
		return m.MagicPttIndex
	}
	return 0
}

func (m *Ptt) GetVoiceSwitch() int32 {
	if m != nil {
		return m.VoiceSwitch
	}
	return 0
}

func (m *Ptt) GetPttUrl() []byte {
	if m != nil {
		return m.PttUrl
	}
	return nil
}

func (m *Ptt) GetGroupFileKey() []byte {
	if m != nil {
		return m.GroupFileKey
	}
	return nil
}

func (m *Ptt) GetTime() int32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *Ptt) GetDownPara() []byte {
	if m != nil {
		return m.DownPara
	}
	return nil
}

func (m *Ptt) GetFormat() int32 {
	if m != nil {
		return m.Format
	}
	return 0
}

func (m *Ptt) GetPbReserve() []byte {
	if m != nil {
		return m.PbReserve
	}
	return nil
}

func (m *Ptt) GetBytesPttUrls() [][]byte {
	if m != nil {
		return m.BytesPttUrls
	}
	return nil
}

func (m *Ptt) GetDownloadFlag() int32 {
	if m != nil {
		return m.DownloadFlag
	}
	return 0
}

type OnlineImage struct {
	Guid           []byte `protobuf:"bytes,1,opt,name=guid" json:"guid"`
	FilePath       []byte `protobuf:"bytes,2,opt,name=filePath" json:"filePath"`
	OldVerSendFile []byte `protobuf:"bytes,3,opt,name=oldVerSendFile" json:"oldVerSendFile"`
}

func (m *OnlineImage) Reset()         { *m = OnlineImage{} }
func (m *OnlineImage) String() string { return proto.CompactTextString(m) }
func (*OnlineImage) ProtoMessage()    {}
func (*OnlineImage) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{32}
}
func (m *OnlineImage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OnlineImage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OnlineImage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OnlineImage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OnlineImage.Merge(m, src)
}
func (m *OnlineImage) XXX_Size() int {
	return m.Size()
}
func (m *OnlineImage) XXX_DiscardUnknown() {
	xxx_messageInfo_OnlineImage.DiscardUnknown(m)
}

var xxx_messageInfo_OnlineImage proto.InternalMessageInfo

func (m *OnlineImage) GetGuid() []byte {
	if m != nil {
		return m.Guid
	}
	return nil
}

func (m *OnlineImage) GetFilePath() []byte {
	if m != nil {
		return m.FilePath
	}
	return nil
}

func (m *OnlineImage) GetOldVerSendFile() []byte {
	if m != nil {
		return m.OldVerSendFile
	}
	return nil
}

type NotOnlineImage struct {
	FilePath       string `protobuf:"bytes,1,opt,name=filePath" json:"filePath"`
	FileLen        int32  `protobuf:"varint,2,opt,name=fileLen" json:"fileLen"`
	DownloadPath   string `protobuf:"bytes,3,opt,name=downloadPath" json:"downloadPath"`
	OldVerSendFile []byte `protobuf:"bytes,4,opt,name=oldVerSendFile" json:"oldVerSendFile"`
	ImgType        int32  `protobuf:"varint,5,opt,name=imgType" json:"imgType"`
	PreviewsImage  []byte `protobuf:"bytes,6,opt,name=previewsImage" json:"previewsImage"`
	PicMd5         []byte `protobuf:"bytes,7,opt,name=picMd5" json:"picMd5"`
	PicHeight      int32  `protobuf:"varint,8,opt,name=picHeight" json:"picHeight"`
	PicWidth       int32  `protobuf:"varint,9,opt,name=picWidth" json:"picWidth"`
	ResId          string `protobuf:"bytes,10,opt,name=resId" json:"resId"`
	Flag           []byte `protobuf:"bytes,11,opt,name=flag" json:"flag"`
	ThumbUrl       string `protobuf:"bytes,12,opt,name=thumbUrl" json:"thumbUrl"`
	Original       int32  `protobuf:"varint,13,opt,name=original" json:"original"`
	BigUrl         string `protobuf:"bytes,14,opt,name=bigUrl" json:"bigUrl"`
	OrigUrl        string `protobuf:"bytes,15,opt,name=origUrl" json:"origUrl"`
	BizType        int32  `protobuf:"varint,16,opt,name=bizType" json:"bizType"`
	Result         int32  `protobuf:"varint,17,opt,name=result" json:"result"`
	Index          int32  `protobuf:"varint,18,opt,name=index" json:"index"`
	OpFaceBuf      []byte `protobuf:"bytes,19,opt,name=opFaceBuf" json:"opFaceBuf"`
	OldPicMd5      bool   `protobuf:"varint,20,opt,name=oldPicMd5" json:"oldPicMd5"`
	ThumbWidth     int32  `protobuf:"varint,21,opt,name=thumbWidth" json:"thumbWidth"`
	ThumbHeight    int32  `protobuf:"varint,22,opt,name=thumbHeight" json:"thumbHeight"`
	FileId         int32  `protobuf:"varint,23,opt,name=fileId" json:"fileId"`
	ShowLen        int32  `protobuf:"varint,24,opt,name=showLen" json:"showLen"`
	DownloadLen    int32  `protobuf:"varint,25,opt,name=downloadLen" json:"downloadLen"`
	PbReserve      []byte `protobuf:"bytes,29,opt,name=pbReserve" json:"pbReserve"`
}

func (m *NotOnlineImage) Reset()         { *m = NotOnlineImage{} }
func (m *NotOnlineImage) String() string { return proto.CompactTextString(m) }
func (*NotOnlineImage) ProtoMessage()    {}
func (*NotOnlineImage) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{33}
}
func (m *NotOnlineImage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotOnlineImage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NotOnlineImage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NotOnlineImage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotOnlineImage.Merge(m, src)
}
func (m *NotOnlineImage) XXX_Size() int {
	return m.Size()
}
func (m *NotOnlineImage) XXX_DiscardUnknown() {
	xxx_messageInfo_NotOnlineImage.DiscardUnknown(m)
}

var xxx_messageInfo_NotOnlineImage proto.InternalMessageInfo

func (m *NotOnlineImage) GetFilePath() string {
	if m != nil {
		return m.FilePath
	}
	return ""
}

func (m *NotOnlineImage) GetFileLen() int32 {
	if m != nil {
		return m.FileLen
	}
	return 0
}

func (m *NotOnlineImage) GetDownloadPath() string {
	if m != nil {
		return m.DownloadPath
	}
	return ""
}

func (m *NotOnlineImage) GetOldVerSendFile() []byte {
	if m != nil {
		return m.OldVerSendFile
	}
	return nil
}

func (m *NotOnlineImage) GetImgType() int32 {
	if m != nil {
		return m.ImgType
	}
	return 0
}

func (m *NotOnlineImage) GetPreviewsImage() []byte {
	if m != nil {
		return m.PreviewsImage
	}
	return nil
}

func (m *NotOnlineImage) GetPicMd5() []byte {
	if m != nil {
		return m.PicMd5
	}
	return nil
}

func (m *NotOnlineImage) GetPicHeight() int32 {
	if m != nil {
		return m.PicHeight
	}
	return 0
}

func (m *NotOnlineImage) GetPicWidth() int32 {
	if m != nil {
		return m.PicWidth
	}
	return 0
}

func (m *NotOnlineImage) GetResId() string {
	if m != nil {
		return m.ResId
	}
	return ""
}

func (m *NotOnlineImage) GetFlag() []byte {
	if m != nil {
		return m.Flag
	}
	return nil
}

func (m *NotOnlineImage) GetThumbUrl() string {
	if m != nil {
		return m.ThumbUrl
	}
	return ""
}

func (m *NotOnlineImage) GetOriginal() int32 {
	if m != nil {
		return m.Original
	}
	return 0
}

func (m *NotOnlineImage) GetBigUrl() string {
	if m != nil {
		return m.BigUrl
	}
	return ""
}

func (m *NotOnlineImage) GetOrigUrl() string {
	if m != nil {
		return m.OrigUrl
	}
	return ""
}

func (m *NotOnlineImage) GetBizType() int32 {
	if m != nil {
		return m.BizType
	}
	return 0
}

func (m *NotOnlineImage) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

func (m *NotOnlineImage) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *NotOnlineImage) GetOpFaceBuf() []byte {
	if m != nil {
		return m.OpFaceBuf
	}
	return nil
}

func (m *NotOnlineImage) GetOldPicMd5() bool {
	if m != nil {
		return m.OldPicMd5
	}
	return false
}

func (m *NotOnlineImage) GetThumbWidth() int32 {
	if m != nil {
		return m.ThumbWidth
	}
	return 0
}

func (m *NotOnlineImage) GetThumbHeight() int32 {
	if m != nil {
		return m.ThumbHeight
	}
	return 0
}

func (m *NotOnlineImage) GetFileId() int32 {
	if m != nil {
		return m.FileId
	}
	return 0
}

func (m *NotOnlineImage) GetShowLen() int32 {
	if m != nil {
		return m.ShowLen
	}
	return 0
}

func (m *NotOnlineImage) GetDownloadLen() int32 {
	if m != nil {
		return m.DownloadLen
	}
	return 0
}

func (m *NotOnlineImage) GetPbReserve() []byte {
	if m != nil {
		return m.PbReserve
	}
	return nil
}

type NotOnlineFile struct {
	FileType      int32    `protobuf:"varint,1,opt,name=fileType" json:"fileType"`
	Sig           []byte   `protobuf:"bytes,2,opt,name=sig" json:"sig"`
	FileUuid      []byte   `protobuf:"bytes,3,opt,name=fileUuid" json:"fileUuid"`
	FileMd5       []byte   `protobuf:"bytes,4,opt,name=fileMd5" json:"fileMd5"`
	FileName      []byte   `protobuf:"bytes,5,opt,name=fileName" json:"fileName"`
	FileSize      int64    `protobuf:"varint,6,opt,name=fileSize" json:"fileSize"`
	Note          []byte   `protobuf:"bytes,7,opt,name=note" json:"note"`
	Reserved      int32    `protobuf:"varint,8,opt,name=reserved" json:"reserved"`
	Subcmd        int32    `protobuf:"varint,9,opt,name=subcmd" json:"subcmd"`
	MicroCloud    int32    `protobuf:"varint,10,opt,name=microCloud" json:"microCloud"`
	BytesFileUrls [][]byte `protobuf:"bytes,11,rep,name=bytesFileUrls" json:"bytesFileUrls,omitempty"`
	DownloadFlag  int32    `protobuf:"varint,12,opt,name=downloadFlag" json:"downloadFlag"`
	DangerEvel    int32    `protobuf:"varint,50,opt,name=dangerEvel" json:"dangerEvel"`
	LifeTime      int32    `protobuf:"varint,51,opt,name=lifeTime" json:"lifeTime"`
	UploadTime    int32    `protobuf:"varint,52,opt,name=uploadTime" json:"uploadTime"`
	AbsFileType   int32    `protobuf:"varint,53,opt,name=absFileType" json:"absFileType"`
	ClientType    int32    `protobuf:"varint,54,opt,name=clientType" json:"clientType"`
	ExpireTime    int32    `protobuf:"varint,55,opt,name=expireTime" json:"expireTime"`
	PbReserve     []byte   `protobuf:"bytes,56,opt,name=pbReserve" json:"pbReserve"`
}

func (m *NotOnlineFile) Reset()         { *m = NotOnlineFile{} }
func (m *NotOnlineFile) String() string { return proto.CompactTextString(m) }
func (*NotOnlineFile) ProtoMessage()    {}
func (*NotOnlineFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{34}
}
func (m *NotOnlineFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotOnlineFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NotOnlineFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NotOnlineFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotOnlineFile.Merge(m, src)
}
func (m *NotOnlineFile) XXX_Size() int {
	return m.Size()
}
func (m *NotOnlineFile) XXX_DiscardUnknown() {
	xxx_messageInfo_NotOnlineFile.DiscardUnknown(m)
}

var xxx_messageInfo_NotOnlineFile proto.InternalMessageInfo

func (m *NotOnlineFile) GetFileType() int32 {
	if m != nil {
		return m.FileType
	}
	return 0
}

func (m *NotOnlineFile) GetSig() []byte {
	if m != nil {
		return m.Sig
	}
	return nil
}

func (m *NotOnlineFile) GetFileUuid() []byte {
	if m != nil {
		return m.FileUuid
	}
	return nil
}

func (m *NotOnlineFile) GetFileMd5() []byte {
	if m != nil {
		return m.FileMd5
	}
	return nil
}

func (m *NotOnlineFile) GetFileName() []byte {
	if m != nil {
		return m.FileName
	}
	return nil
}

func (m *NotOnlineFile) GetFileSize() int64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *NotOnlineFile) GetNote() []byte {
	if m != nil {
		return m.Note
	}
	return nil
}

func (m *NotOnlineFile) GetReserved() int32 {
	if m != nil {
		return m.Reserved
	}
	return 0
}

func (m *NotOnlineFile) GetSubcmd() int32 {
	if m != nil {
		return m.Subcmd
	}
	return 0
}

func (m *NotOnlineFile) GetMicroCloud() int32 {
	if m != nil {
		return m.MicroCloud
	}
	return 0
}

func (m *NotOnlineFile) GetBytesFileUrls() [][]byte {
	if m != nil {
		return m.BytesFileUrls
	}
	return nil
}

func (m *NotOnlineFile) GetDownloadFlag() int32 {
	if m != nil {
		return m.DownloadFlag
	}
	return 0
}

func (m *NotOnlineFile) GetDangerEvel() int32 {
	if m != nil {
		return m.DangerEvel
	}
	return 0
}

func (m *NotOnlineFile) GetLifeTime() int32 {
	if m != nil {
		return m.LifeTime
	}
	return 0
}

func (m *NotOnlineFile) GetUploadTime() int32 {
	if m != nil {
		return m.UploadTime
	}
	return 0
}

func (m *NotOnlineFile) GetAbsFileType() int32 {
	if m != nil {
		return m.AbsFileType
	}
	return 0
}

func (m *NotOnlineFile) GetClientType() int32 {
	if m != nil {
		return m.ClientType
	}
	return 0
}

func (m *NotOnlineFile) GetExpireTime() int32 {
	if m != nil {
		return m.ExpireTime
	}
	return 0
}

func (m *NotOnlineFile) GetPbReserve() []byte {
	if m != nil {
		return m.PbReserve
	}
	return nil
}

type TransElem struct {
	ElemType  int32  `protobuf:"varint,1,opt,name=elemType" json:"elemType"`
	ElemValue []byte `protobuf:"bytes,2,opt,name=elemValue" json:"elemValue"`
}

func (m *TransElem) Reset()         { *m = TransElem{} }
func (m *TransElem) String() string { return proto.CompactTextString(m) }
func (*TransElem) ProtoMessage()    {}
func (*TransElem) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{35}
}
func (m *TransElem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransElem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransElem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransElem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransElem.Merge(m, src)
}
func (m *TransElem) XXX_Size() int {
	return m.Size()
}
func (m *TransElem) XXX_DiscardUnknown() {
	xxx_messageInfo_TransElem.DiscardUnknown(m)
}

var xxx_messageInfo_TransElem proto.InternalMessageInfo

func (m *TransElem) GetElemType() int32 {
	if m != nil {
		return m.ElemType
	}
	return 0
}

func (m *TransElem) GetElemValue() []byte {
	if m != nil {
		return m.ElemValue
	}
	return nil
}

type ExtraInfo struct {
	Nick          []byte `protobuf:"bytes,1,opt,name=nick" json:"nick"`
	GroupCard     []byte `protobuf:"bytes,2,opt,name=groupCard" json:"groupCard"`
	Level         int32  `protobuf:"varint,3,opt,name=level" json:"level"`
	Flags         int32  `protobuf:"varint,4,opt,name=flags" json:"flags"`
	GroupMask     int32  `protobuf:"varint,5,opt,name=groupMask" json:"groupMask"`
	MsgTailId     int32  `protobuf:"varint,6,opt,name=msgTailId" json:"msgTailId"`
	SenderTitle   []byte `protobuf:"bytes,7,opt,name=senderTitle" json:"senderTitle"`
	ApnsTips      []byte `protobuf:"bytes,8,opt,name=apnsTips" json:"apnsTips"`
	Uin           int64  `protobuf:"varint,9,opt,name=uin" json:"uin"`
	MsgStateFlag  int32  `protobuf:"varint,10,opt,name=msgStateFlag" json:"msgStateFlag"`
	ApnsSoundType int32  `protobuf:"varint,11,opt,name=apnsSoundType" json:"apnsSoundType"`
	NewGroupFlag  int32  `protobuf:"varint,12,opt,name=newGroupFlag" json:"newGroupFlag"`
}

func (m *ExtraInfo) Reset()         { *m = ExtraInfo{} }
func (m *ExtraInfo) String() string { return proto.CompactTextString(m) }
func (*ExtraInfo) ProtoMessage()    {}
func (*ExtraInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{36}
}
func (m *ExtraInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExtraInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExtraInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExtraInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtraInfo.Merge(m, src)
}
func (m *ExtraInfo) XXX_Size() int {
	return m.Size()
}
func (m *ExtraInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtraInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ExtraInfo proto.InternalMessageInfo

func (m *ExtraInfo) GetNick() []byte {
	if m != nil {
		return m.Nick
	}
	return nil
}

func (m *ExtraInfo) GetGroupCard() []byte {
	if m != nil {
		return m.GroupCard
	}
	return nil
}

func (m *ExtraInfo) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *ExtraInfo) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *ExtraInfo) GetGroupMask() int32 {
	if m != nil {
		return m.GroupMask
	}
	return 0
}

func (m *ExtraInfo) GetMsgTailId() int32 {
	if m != nil {
		return m.MsgTailId
	}
	return 0
}

func (m *ExtraInfo) GetSenderTitle() []byte {
	if m != nil {
		return m.SenderTitle
	}
	return nil
}

func (m *ExtraInfo) GetApnsTips() []byte {
	if m != nil {
		return m.ApnsTips
	}
	return nil
}

func (m *ExtraInfo) GetUin() int64 {
	if m != nil {
		return m.Uin
	}
	return 0
}

func (m *ExtraInfo) GetMsgStateFlag() int32 {
	if m != nil {
		return m.MsgStateFlag
	}
	return 0
}

func (m *ExtraInfo) GetApnsSoundType() int32 {
	if m != nil {
		return m.ApnsSoundType
	}
	return 0
}

func (m *ExtraInfo) GetNewGroupFlag() int32 {
	if m != nil {
		return m.NewGroupFlag
	}
	return 0
}

type GroupFile struct {
	Filename    []byte `protobuf:"bytes,1,opt,name=filename" json:"filename"`
	FileSize    int64  `protobuf:"varint,2,opt,name=fileSize" json:"fileSize"`
	FileId      []byte `protobuf:"bytes,3,opt,name=fileId" json:"fileId"`
	BatchId     []byte `protobuf:"bytes,4,opt,name=batchId" json:"batchId"`
	FileKey     []byte `protobuf:"bytes,5,opt,name=fileKey" json:"fileKey"`
	Mark        []byte `protobuf:"bytes,6,opt,name=mark" json:"mark"`
	Sequence    int64  `protobuf:"varint,7,opt,name=sequence" json:"sequence"`
	BatchItemId []byte `protobuf:"bytes,8,opt,name=batchItemId" json:"batchItemId"`
	FeedMsgTime int32  `protobuf:"varint,9,opt,name=feedMsgTime" json:"feedMsgTime"`
	PbReserve   []byte `protobuf:"bytes,10,opt,name=pbReserve" json:"pbReserve"`
}

func (m *GroupFile) Reset()         { *m = GroupFile{} }
func (m *GroupFile) String() string { return proto.CompactTextString(m) }
func (*GroupFile) ProtoMessage()    {}
func (*GroupFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{37}
}
func (m *GroupFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupFile.Merge(m, src)
}
func (m *GroupFile) XXX_Size() int {
	return m.Size()
}
func (m *GroupFile) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupFile.DiscardUnknown(m)
}

var xxx_messageInfo_GroupFile proto.InternalMessageInfo

func (m *GroupFile) GetFilename() []byte {
	if m != nil {
		return m.Filename
	}
	return nil
}

func (m *GroupFile) GetFileSize() int64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *GroupFile) GetFileId() []byte {
	if m != nil {
		return m.FileId
	}
	return nil
}

func (m *GroupFile) GetBatchId() []byte {
	if m != nil {
		return m.BatchId
	}
	return nil
}

func (m *GroupFile) GetFileKey() []byte {
	if m != nil {
		return m.FileKey
	}
	return nil
}

func (m *GroupFile) GetMark() []byte {
	if m != nil {
		return m.Mark
	}
	return nil
}

func (m *GroupFile) GetSequence() int64 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *GroupFile) GetBatchItemId() []byte {
	if m != nil {
		return m.BatchItemId
	}
	return nil
}

func (m *GroupFile) GetFeedMsgTime() int32 {
	if m != nil {
		return m.FeedMsgTime
	}
	return 0
}

func (m *GroupFile) GetPbReserve() []byte {
	if m != nil {
		return m.PbReserve
	}
	return nil
}

type AnonymousGroupMessage struct {
	Flags        int32  `protobuf:"varint,1,opt,name=flags" json:"flags"`
	AnonId       []byte `protobuf:"bytes,2,opt,name=anonId" json:"anonId"`
	AnonNick     []byte `protobuf:"bytes,3,opt,name=anonNick" json:"anonNick"`
	HeadPortrait int32  `protobuf:"varint,4,opt,name=headPortrait" json:"headPortrait"`
	ExpireTime   int32  `protobuf:"varint,5,opt,name=expireTime" json:"expireTime"`
	BubbleId     int32  `protobuf:"varint,6,opt,name=bubbleId" json:"bubbleId"`
	RankColor    []byte `protobuf:"bytes,7,opt,name=rankColor" json:"rankColor"`
}

func (m *AnonymousGroupMessage) Reset()         { *m = AnonymousGroupMessage{} }
func (m *AnonymousGroupMessage) String() string { return proto.CompactTextString(m) }
func (*AnonymousGroupMessage) ProtoMessage()    {}
func (*AnonymousGroupMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{38}
}
func (m *AnonymousGroupMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AnonymousGroupMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AnonymousGroupMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AnonymousGroupMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnonymousGroupMessage.Merge(m, src)
}
func (m *AnonymousGroupMessage) XXX_Size() int {
	return m.Size()
}
func (m *AnonymousGroupMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_AnonymousGroupMessage.DiscardUnknown(m)
}

var xxx_messageInfo_AnonymousGroupMessage proto.InternalMessageInfo

func (m *AnonymousGroupMessage) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *AnonymousGroupMessage) GetAnonId() []byte {
	if m != nil {
		return m.AnonId
	}
	return nil
}

func (m *AnonymousGroupMessage) GetAnonNick() []byte {
	if m != nil {
		return m.AnonNick
	}
	return nil
}

func (m *AnonymousGroupMessage) GetHeadPortrait() int32 {
	if m != nil {
		return m.HeadPortrait
	}
	return 0
}

func (m *AnonymousGroupMessage) GetExpireTime() int32 {
	if m != nil {
		return m.ExpireTime
	}
	return 0
}

func (m *AnonymousGroupMessage) GetBubbleId() int32 {
	if m != nil {
		return m.BubbleId
	}
	return 0
}

func (m *AnonymousGroupMessage) GetRankColor() []byte {
	if m != nil {
		return m.RankColor
	}
	return nil
}

type VideoFile struct {
	FileUuid               []byte   `protobuf:"bytes,1,opt,name=fileUuid" json:"fileUuid"`
	FileMd5                []byte   `protobuf:"bytes,2,opt,name=fileMd5" json:"fileMd5"`
	FileName               []byte   `protobuf:"bytes,3,opt,name=fileName" json:"fileName"`
	FileFormat             int32    `protobuf:"varint,4,opt,name=fileFormat" json:"fileFormat"`
	FileTime               int32    `protobuf:"varint,5,opt,name=fileTime" json:"fileTime"`
	FileSize               int32    `protobuf:"varint,6,opt,name=fileSize" json:"fileSize"`
	ThumbWidth             int32    `protobuf:"varint,7,opt,name=thumbWidth" json:"thumbWidth"`
	ThumbHeight            int32    `protobuf:"varint,8,opt,name=thumbHeight" json:"thumbHeight"`
	ThumbFileMd5           []byte   `protobuf:"bytes,9,opt,name=thumbFileMd5" json:"thumbFileMd5"`
	Source                 []byte   `protobuf:"bytes,10,opt,name=source" json:"source"`
	ThumbFileSize          int32    `protobuf:"varint,11,opt,name=thumbFileSize" json:"thumbFileSize"`
	BusiType               int32    `protobuf:"varint,12,opt,name=busiType" json:"busiType"`
	FromChatType           int32    `protobuf:"varint,13,opt,name=fromChatType" json:"fromChatType"`
	ToChatType             int32    `protobuf:"varint,14,opt,name=toChatType" json:"toChatType"`
	BoolSupportProgressive bool     `protobuf:"varint,15,opt,name=boolSupportProgressive" json:"boolSupportProgressive"`
	FileWidth              int32    `protobuf:"varint,16,opt,name=fileWidth" json:"fileWidth"`
	FileHeight             int32    `protobuf:"varint,17,opt,name=fileHeight" json:"fileHeight"`
	SubBusiType            int32    `protobuf:"varint,18,opt,name=subBusiType" json:"subBusiType"`
	VideoAttr              int32    `protobuf:"varint,19,opt,name=videoAttr" json:"videoAttr"`
	BytesThumbFileUrls     [][]byte `protobuf:"bytes,20,rep,name=bytesThumbFileUrls" json:"bytesThumbFileUrls,omitempty"`
	BytesVideoFileUrls     [][]byte `protobuf:"bytes,21,rep,name=bytesVideoFileUrls" json:"bytesVideoFileUrls,omitempty"`
	ThumbDownloadFlag      int32    `protobuf:"varint,22,opt,name=thumbDownloadFlag" json:"thumbDownloadFlag"`
	VideoDownloadFlag      int32    `protobuf:"varint,23,opt,name=videoDownloadFlag" json:"videoDownloadFlag"`
	PbReserve              []byte   `protobuf:"bytes,24,opt,name=pbReserve" json:"pbReserve"`
}

func (m *VideoFile) Reset()         { *m = VideoFile{} }
func (m *VideoFile) String() string { return proto.CompactTextString(m) }
func (*VideoFile) ProtoMessage()    {}
func (*VideoFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{39}
}
func (m *VideoFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VideoFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VideoFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VideoFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VideoFile.Merge(m, src)
}
func (m *VideoFile) XXX_Size() int {
	return m.Size()
}
func (m *VideoFile) XXX_DiscardUnknown() {
	xxx_messageInfo_VideoFile.DiscardUnknown(m)
}

var xxx_messageInfo_VideoFile proto.InternalMessageInfo

func (m *VideoFile) GetFileUuid() []byte {
	if m != nil {
		return m.FileUuid
	}
	return nil
}

func (m *VideoFile) GetFileMd5() []byte {
	if m != nil {
		return m.FileMd5
	}
	return nil
}

func (m *VideoFile) GetFileName() []byte {
	if m != nil {
		return m.FileName
	}
	return nil
}

func (m *VideoFile) GetFileFormat() int32 {
	if m != nil {
		return m.FileFormat
	}
	return 0
}

func (m *VideoFile) GetFileTime() int32 {
	if m != nil {
		return m.FileTime
	}
	return 0
}

func (m *VideoFile) GetFileSize() int32 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *VideoFile) GetThumbWidth() int32 {
	if m != nil {
		return m.ThumbWidth
	}
	return 0
}

func (m *VideoFile) GetThumbHeight() int32 {
	if m != nil {
		return m.ThumbHeight
	}
	return 0
}

func (m *VideoFile) GetThumbFileMd5() []byte {
	if m != nil {
		return m.ThumbFileMd5
	}
	return nil
}

func (m *VideoFile) GetSource() []byte {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *VideoFile) GetThumbFileSize() int32 {
	if m != nil {
		return m.ThumbFileSize
	}
	return 0
}

func (m *VideoFile) GetBusiType() int32 {
	if m != nil {
		return m.BusiType
	}
	return 0
}

func (m *VideoFile) GetFromChatType() int32 {
	if m != nil {
		return m.FromChatType
	}
	return 0
}

func (m *VideoFile) GetToChatType() int32 {
	if m != nil {
		return m.ToChatType
	}
	return 0
}

func (m *VideoFile) GetBoolSupportProgressive() bool {
	if m != nil {
		return m.BoolSupportProgressive
	}
	return false
}

func (m *VideoFile) GetFileWidth() int32 {
	if m != nil {
		return m.FileWidth
	}
	return 0
}

func (m *VideoFile) GetFileHeight() int32 {
	if m != nil {
		return m.FileHeight
	}
	return 0
}

func (m *VideoFile) GetSubBusiType() int32 {
	if m != nil {
		return m.SubBusiType
	}
	return 0
}

func (m *VideoFile) GetVideoAttr() int32 {
	if m != nil {
		return m.VideoAttr
	}
	return 0
}

func (m *VideoFile) GetBytesThumbFileUrls() [][]byte {
	if m != nil {
		return m.BytesThumbFileUrls
	}
	return nil
}

func (m *VideoFile) GetBytesVideoFileUrls() [][]byte {
	if m != nil {
		return m.BytesVideoFileUrls
	}
	return nil
}

func (m *VideoFile) GetThumbDownloadFlag() int32 {
	if m != nil {
		return m.ThumbDownloadFlag
	}
	return 0
}

func (m *VideoFile) GetVideoDownloadFlag() int32 {
	if m != nil {
		return m.VideoDownloadFlag
	}
	return 0
}

func (m *VideoFile) GetPbReserve() []byte {
	if m != nil {
		return m.PbReserve
	}
	return nil
}

type SourceMsg struct {
	OrigSeqs  []int32 `protobuf:"varint,1,rep,name=origSeqs" json:"origSeqs,omitempty"`
	SenderUin int64   `protobuf:"varint,2,opt,name=senderUin" json:"senderUin"`
	Time      int32   `protobuf:"varint,3,opt,name=time" json:"time"`
	Flag      int32   `protobuf:"varint,4,opt,name=flag" json:"flag"`
	Elems     []*Elem `protobuf:"bytes,5,rep,name=elems" json:"elems,omitempty"`
	Type      int32   `protobuf:"varint,6,opt,name=type" json:"type"`
	RichMsg   []byte  `protobuf:"bytes,7,opt,name=richMsg" json:"richMsg"`
	PbReserve []byte  `protobuf:"bytes,8,opt,name=pbReserve" json:"pbReserve"`
	SrcMsg    []byte  `protobuf:"bytes,9,opt,name=srcMsg" json:"srcMsg"`
	ToUin     int64   `protobuf:"varint,10,opt,name=toUin" json:"toUin"`
	TroopName []byte  `protobuf:"bytes,11,opt,name=troopName" json:"troopName"`
}

func (m *SourceMsg) Reset()         { *m = SourceMsg{} }
func (m *SourceMsg) String() string { return proto.CompactTextString(m) }
func (*SourceMsg) ProtoMessage()    {}
func (*SourceMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{40}
}
func (m *SourceMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SourceMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SourceMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SourceMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SourceMsg.Merge(m, src)
}
func (m *SourceMsg) XXX_Size() int {
	return m.Size()
}
func (m *SourceMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_SourceMsg.DiscardUnknown(m)
}

var xxx_messageInfo_SourceMsg proto.InternalMessageInfo

func (m *SourceMsg) GetOrigSeqs() []int32 {
	if m != nil {
		return m.OrigSeqs
	}
	return nil
}

func (m *SourceMsg) GetSenderUin() int64 {
	if m != nil {
		return m.SenderUin
	}
	return 0
}

func (m *SourceMsg) GetTime() int32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *SourceMsg) GetFlag() int32 {
	if m != nil {
		return m.Flag
	}
	return 0
}

func (m *SourceMsg) GetElems() []*Elem {
	if m != nil {
		return m.Elems
	}
	return nil
}

func (m *SourceMsg) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *SourceMsg) GetRichMsg() []byte {
	if m != nil {
		return m.RichMsg
	}
	return nil
}

func (m *SourceMsg) GetPbReserve() []byte {
	if m != nil {
		return m.PbReserve
	}
	return nil
}

func (m *SourceMsg) GetSrcMsg() []byte {
	if m != nil {
		return m.SrcMsg
	}
	return nil
}

func (m *SourceMsg) GetToUin() int64 {
	if m != nil {
		return m.ToUin
	}
	return 0
}

func (m *SourceMsg) GetTroopName() []byte {
	if m != nil {
		return m.TroopName
	}
	return nil
}

type Face struct {
	Index int32  `protobuf:"varint,1,opt,name=index" json:"index"`
	Old   []byte `protobuf:"bytes,2,opt,name=old" json:"old"`
	Buf   []byte `protobuf:"bytes,11,opt,name=buf" json:"buf"`
}

func (m *Face) Reset()         { *m = Face{} }
func (m *Face) String() string { return proto.CompactTextString(m) }
func (*Face) ProtoMessage()    {}
func (*Face) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{41}
}
func (m *Face) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Face) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Face.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Face) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Face.Merge(m, src)
}
func (m *Face) XXX_Size() int {
	return m.Size()
}
func (m *Face) XXX_DiscardUnknown() {
	xxx_messageInfo_Face.DiscardUnknown(m)
}

var xxx_messageInfo_Face proto.InternalMessageInfo

func (m *Face) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Face) GetOld() []byte {
	if m != nil {
		return m.Old
	}
	return nil
}

func (m *Face) GetBuf() []byte {
	if m != nil {
		return m.Buf
	}
	return nil
}

type LightAppElem struct {
	Data     []byte `protobuf:"bytes,1,opt,name=data" json:"data"`
	MsgResid []byte `protobuf:"bytes,2,opt,name=msgResid" json:"msgResid"`
}

func (m *LightAppElem) Reset()         { *m = LightAppElem{} }
func (m *LightAppElem) String() string { return proto.CompactTextString(m) }
func (*LightAppElem) ProtoMessage()    {}
func (*LightAppElem) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{42}
}
func (m *LightAppElem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LightAppElem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LightAppElem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LightAppElem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LightAppElem.Merge(m, src)
}
func (m *LightAppElem) XXX_Size() int {
	return m.Size()
}
func (m *LightAppElem) XXX_DiscardUnknown() {
	xxx_messageInfo_LightAppElem.DiscardUnknown(m)
}

var xxx_messageInfo_LightAppElem proto.InternalMessageInfo

func (m *LightAppElem) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *LightAppElem) GetMsgResid() []byte {
	if m != nil {
		return m.MsgResid
	}
	return nil
}

type CustomFace struct {
	Guid        []byte `protobuf:"bytes,1,opt,name=guid" json:"guid"`
	FilePath    string `protobuf:"bytes,2,opt,name=filePath" json:"filePath"`
	Shortcut    string `protobuf:"bytes,3,opt,name=shortcut" json:"shortcut"`
	Buffer      []byte `protobuf:"bytes,4,opt,name=buffer" json:"buffer"`
	Flag        []byte `protobuf:"bytes,5,opt,name=flag" json:"flag"`
	OldData     []byte `protobuf:"bytes,6,opt,name=oldData" json:"oldData"`
	FileId      int32  `protobuf:"varint,7,opt,name=fileId" json:"fileId"`
	ServerIp    int32  `protobuf:"varint,8,opt,name=serverIp" json:"serverIp"`
	ServerPort  int32  `protobuf:"varint,9,opt,name=serverPort" json:"serverPort"`
	FileType    int32  `protobuf:"varint,10,opt,name=fileType" json:"fileType"`
	Signature   []byte `protobuf:"bytes,11,opt,name=signature" json:"signature"`
	Useful      int32  `protobuf:"varint,12,opt,name=useful" json:"useful"`
	Md5         []byte `protobuf:"bytes,13,opt,name=md5" json:"md5"`
	ThumbUrl    string `protobuf:"bytes,14,opt,name=thumbUrl" json:"thumbUrl"`
	BigUrl      string `protobuf:"bytes,15,opt,name=bigUrl" json:"bigUrl"`
	OrigUrl     string `protobuf:"bytes,16,opt,name=origUrl" json:"origUrl"`
	BizType     int32  `protobuf:"varint,17,opt,name=bizType" json:"bizType"`
	RepeatIndex int32  `protobuf:"varint,18,opt,name=repeatIndex" json:"repeatIndex"`
	RepeatImage int32  `protobuf:"varint,19,opt,name=repeatImage" json:"repeatImage"`
	ImageType   int32  `protobuf:"varint,20,opt,name=imageType" json:"imageType"`
	Index       int32  `protobuf:"varint,21,opt,name=index" json:"index"`
	Width       int32  `protobuf:"varint,22,opt,name=width" json:"width"`
	Height      int32  `protobuf:"varint,23,opt,name=height" json:"height"`
	Source      int32  `protobuf:"varint,24,opt,name=source" json:"source"`
	Size_       int32  `protobuf:"varint,25,opt,name=size" json:"size"`
	Origin      int32  `protobuf:"varint,26,opt,name=origin" json:"origin"`
	ThumbWidth  int32  `protobuf:"varint,27,opt,name=thumbWidth" json:"thumbWidth"`
	ThumbHeight int32  `protobuf:"varint,28,opt,name=thumbHeight" json:"thumbHeight"`
	ShowLen     int32  `protobuf:"varint,29,opt,name=showLen" json:"showLen"`
	DownloadLen int32  `protobuf:"varint,30,opt,name=downloadLen" json:"downloadLen"`
	X400Url     string `protobuf:"bytes,31,opt,name=_400Url,json=400Url" json:"_400Url"`
	X400Width   int32  `protobuf:"varint,32,opt,name=_400Width,json=400Width" json:"_400Width"`
	X400Height  int32  `protobuf:"varint,33,opt,name=_400Height,json=400Height" json:"_400Height"`
	PbReserve   []byte `protobuf:"bytes,34,opt,name=pbReserve" json:"pbReserve"`
}

func (m *CustomFace) Reset()         { *m = CustomFace{} }
func (m *CustomFace) String() string { return proto.CompactTextString(m) }
func (*CustomFace) ProtoMessage()    {}
func (*CustomFace) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{43}
}
func (m *CustomFace) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CustomFace) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CustomFace.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CustomFace) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CustomFace.Merge(m, src)
}
func (m *CustomFace) XXX_Size() int {
	return m.Size()
}
func (m *CustomFace) XXX_DiscardUnknown() {
	xxx_messageInfo_CustomFace.DiscardUnknown(m)
}

var xxx_messageInfo_CustomFace proto.InternalMessageInfo

func (m *CustomFace) GetGuid() []byte {
	if m != nil {
		return m.Guid
	}
	return nil
}

func (m *CustomFace) GetFilePath() string {
	if m != nil {
		return m.FilePath
	}
	return ""
}

func (m *CustomFace) GetShortcut() string {
	if m != nil {
		return m.Shortcut
	}
	return ""
}

func (m *CustomFace) GetBuffer() []byte {
	if m != nil {
		return m.Buffer
	}
	return nil
}

func (m *CustomFace) GetFlag() []byte {
	if m != nil {
		return m.Flag
	}
	return nil
}

func (m *CustomFace) GetOldData() []byte {
	if m != nil {
		return m.OldData
	}
	return nil
}

func (m *CustomFace) GetFileId() int32 {
	if m != nil {
		return m.FileId
	}
	return 0
}

func (m *CustomFace) GetServerIp() int32 {
	if m != nil {
		return m.ServerIp
	}
	return 0
}

func (m *CustomFace) GetServerPort() int32 {
	if m != nil {
		return m.ServerPort
	}
	return 0
}

func (m *CustomFace) GetFileType() int32 {
	if m != nil {
		return m.FileType
	}
	return 0
}

func (m *CustomFace) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *CustomFace) GetUseful() int32 {
	if m != nil {
		return m.Useful
	}
	return 0
}

func (m *CustomFace) GetMd5() []byte {
	if m != nil {
		return m.Md5
	}
	return nil
}

func (m *CustomFace) GetThumbUrl() string {
	if m != nil {
		return m.ThumbUrl
	}
	return ""
}

func (m *CustomFace) GetBigUrl() string {
	if m != nil {
		return m.BigUrl
	}
	return ""
}

func (m *CustomFace) GetOrigUrl() string {
	if m != nil {
		return m.OrigUrl
	}
	return ""
}

func (m *CustomFace) GetBizType() int32 {
	if m != nil {
		return m.BizType
	}
	return 0
}

func (m *CustomFace) GetRepeatIndex() int32 {
	if m != nil {
		return m.RepeatIndex
	}
	return 0
}

func (m *CustomFace) GetRepeatImage() int32 {
	if m != nil {
		return m.RepeatImage
	}
	return 0
}

func (m *CustomFace) GetImageType() int32 {
	if m != nil {
		return m.ImageType
	}
	return 0
}

func (m *CustomFace) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *CustomFace) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *CustomFace) GetHeight() int32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *CustomFace) GetSource() int32 {
	if m != nil {
		return m.Source
	}
	return 0
}

func (m *CustomFace) GetSize_() int32 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *CustomFace) GetOrigin() int32 {
	if m != nil {
		return m.Origin
	}
	return 0
}

func (m *CustomFace) GetThumbWidth() int32 {
	if m != nil {
		return m.ThumbWidth
	}
	return 0
}

func (m *CustomFace) GetThumbHeight() int32 {
	if m != nil {
		return m.ThumbHeight
	}
	return 0
}

func (m *CustomFace) GetShowLen() int32 {
	if m != nil {
		return m.ShowLen
	}
	return 0
}

func (m *CustomFace) GetDownloadLen() int32 {
	if m != nil {
		return m.DownloadLen
	}
	return 0
}

func (m *CustomFace) GetX400Url() string {
	if m != nil {
		return m.X400Url
	}
	return ""
}

func (m *CustomFace) GetX400Width() int32 {
	if m != nil {
		return m.X400Width
	}
	return 0
}

func (m *CustomFace) GetX400Height() int32 {
	if m != nil {
		return m.X400Height
	}
	return 0
}

func (m *CustomFace) GetPbReserve() []byte {
	if m != nil {
		return m.PbReserve
	}
	return nil
}

type ContentHead struct {
	PkgNum    int32 `protobuf:"varint,1,opt,name=pkgNum" json:"pkgNum"`
	PkgIndex  int32 `protobuf:"varint,2,opt,name=pkgIndex" json:"pkgIndex"`
	DivSeq    int32 `protobuf:"varint,3,opt,name=divSeq" json:"divSeq"`
	AutoReply int32 `protobuf:"varint,4,opt,name=autoReply" json:"autoReply"`
}

func (m *ContentHead) Reset()         { *m = ContentHead{} }
func (m *ContentHead) String() string { return proto.CompactTextString(m) }
func (*ContentHead) ProtoMessage()    {}
func (*ContentHead) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{44}
}
func (m *ContentHead) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContentHead) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContentHead.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContentHead) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContentHead.Merge(m, src)
}
func (m *ContentHead) XXX_Size() int {
	return m.Size()
}
func (m *ContentHead) XXX_DiscardUnknown() {
	xxx_messageInfo_ContentHead.DiscardUnknown(m)
}

var xxx_messageInfo_ContentHead proto.InternalMessageInfo

func (m *ContentHead) GetPkgNum() int32 {
	if m != nil {
		return m.PkgNum
	}
	return 0
}

func (m *ContentHead) GetPkgIndex() int32 {
	if m != nil {
		return m.PkgIndex
	}
	return 0
}

func (m *ContentHead) GetDivSeq() int32 {
	if m != nil {
		return m.DivSeq
	}
	return 0
}

func (m *ContentHead) GetAutoReply() int32 {
	if m != nil {
		return m.AutoReply
	}
	return 0
}

type MessageHead struct {
	FromUin                    int64               `protobuf:"varint,1,opt,name=fromUin" json:"fromUin"`
	ToUin                      int64               `protobuf:"varint,2,opt,name=toUin" json:"toUin"`
	MsgType                    int32               `protobuf:"varint,3,opt,name=msgType" json:"msgType"`
	C2CCmd                     int32               `protobuf:"varint,4,opt,name=c2cCmd" json:"c2cCmd"`
	MsgSeq                     int32               `protobuf:"varint,5,opt,name=msgSeq" json:"msgSeq"`
	MsgTime                    int32               `protobuf:"varint,6,opt,name=msgTime" json:"msgTime"`
	MsgUid                     int64               `protobuf:"varint,7,opt,name=msgUid" json:"msgUid"`
	C2CTmpMsgHead              *C2CTempMessageHead `protobuf:"bytes,8,opt,name=c2cTmpMsgHead" json:"c2cTmpMsgHead,omitempty"`
	GroupInfo                  *GroupInfo          `protobuf:"bytes,9,opt,name=groupInfo" json:"groupInfo,omitempty"`
	FromAppid                  int32               `protobuf:"varint,10,opt,name=fromAppid" json:"fromAppid"`
	FromInstid                 int32               `protobuf:"varint,11,opt,name=fromInstid" json:"fromInstid"`
	UserActive                 int32               `protobuf:"varint,12,opt,name=userActive" json:"userActive"`
	DiscussInfo                *DiscussInfo        `protobuf:"bytes,13,opt,name=discussInfo" json:"discussInfo,omitempty"`
	FromNick                   string              `protobuf:"bytes,14,opt,name=fromNick" json:"fromNick"`
	AuthUin                    int64               `protobuf:"varint,15,opt,name=authUin" json:"authUin"`
	AuthNick                   string              `protobuf:"bytes,16,opt,name=authNick" json:"authNick"`
	MsgFlag                    int32               `protobuf:"varint,17,opt,name=msgFlag" json:"msgFlag"`
	AuthRemark                 string              `protobuf:"bytes,18,opt,name=authRemark" json:"authRemark"`
	GroupName                  string              `protobuf:"bytes,19,opt,name=groupName" json:"groupName"`
	MutiltransHead             *MutilTransHead     `protobuf:"bytes,20,opt,name=mutiltransHead" json:"mutiltransHead,omitempty"`
	MsgInstCtrl                *InstCtrl           `protobuf:"bytes,21,opt,name=msgInstCtrl" json:"msgInstCtrl,omitempty"`
	PublicAccountGroupSendFlag int32               `protobuf:"varint,22,opt,name=publicAccountGroupSendFlag" json:"publicAccountGroupSendFlag"`
	WseqInC2CMsghead           int32               `protobuf:"varint,23,opt,name=wseqInC2cMsghead" json:"wseqInC2cMsghead"`
	Cpid                       int64               `protobuf:"varint,24,opt,name=cpid" json:"cpid"`
	ExtGroupKeyInfo            *ExtGroupKeyInfo    `protobuf:"bytes,25,opt,name=extGroupKeyInfo" json:"extGroupKeyInfo,omitempty"`
	MultiCompatibleText        string              `protobuf:"bytes,26,opt,name=multiCompatibleText" json:"multiCompatibleText"`
	AuthSex                    int32               `protobuf:"varint,27,opt,name=authSex" json:"authSex"`
	IsSrcMsg                   bool                `protobuf:"varint,28,opt,name=isSrcMsg" json:"isSrcMsg"`
}

func (m *MessageHead) Reset()         { *m = MessageHead{} }
func (m *MessageHead) String() string { return proto.CompactTextString(m) }
func (*MessageHead) ProtoMessage()    {}
func (*MessageHead) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{45}
}
func (m *MessageHead) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageHead) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageHead.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageHead) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageHead.Merge(m, src)
}
func (m *MessageHead) XXX_Size() int {
	return m.Size()
}
func (m *MessageHead) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageHead.DiscardUnknown(m)
}

var xxx_messageInfo_MessageHead proto.InternalMessageInfo

func (m *MessageHead) GetFromUin() int64 {
	if m != nil {
		return m.FromUin
	}
	return 0
}

func (m *MessageHead) GetToUin() int64 {
	if m != nil {
		return m.ToUin
	}
	return 0
}

func (m *MessageHead) GetMsgType() int32 {
	if m != nil {
		return m.MsgType
	}
	return 0
}

func (m *MessageHead) GetC2CCmd() int32 {
	if m != nil {
		return m.C2CCmd
	}
	return 0
}

func (m *MessageHead) GetMsgSeq() int32 {
	if m != nil {
		return m.MsgSeq
	}
	return 0
}

func (m *MessageHead) GetMsgTime() int32 {
	if m != nil {
		return m.MsgTime
	}
	return 0
}

func (m *MessageHead) GetMsgUid() int64 {
	if m != nil {
		return m.MsgUid
	}
	return 0
}

func (m *MessageHead) GetC2CTmpMsgHead() *C2CTempMessageHead {
	if m != nil {
		return m.C2CTmpMsgHead
	}
	return nil
}

func (m *MessageHead) GetGroupInfo() *GroupInfo {
	if m != nil {
		return m.GroupInfo
	}
	return nil
}

func (m *MessageHead) GetFromAppid() int32 {
	if m != nil {
		return m.FromAppid
	}
	return 0
}

func (m *MessageHead) GetFromInstid() int32 {
	if m != nil {
		return m.FromInstid
	}
	return 0
}

func (m *MessageHead) GetUserActive() int32 {
	if m != nil {
		return m.UserActive
	}
	return 0
}

func (m *MessageHead) GetDiscussInfo() *DiscussInfo {
	if m != nil {
		return m.DiscussInfo
	}
	return nil
}

func (m *MessageHead) GetFromNick() string {
	if m != nil {
		return m.FromNick
	}
	return ""
}

func (m *MessageHead) GetAuthUin() int64 {
	if m != nil {
		return m.AuthUin
	}
	return 0
}

func (m *MessageHead) GetAuthNick() string {
	if m != nil {
		return m.AuthNick
	}
	return ""
}

func (m *MessageHead) GetMsgFlag() int32 {
	if m != nil {
		return m.MsgFlag
	}
	return 0
}

func (m *MessageHead) GetAuthRemark() string {
	if m != nil {
		return m.AuthRemark
	}
	return ""
}

func (m *MessageHead) GetGroupName() string {
	if m != nil {
		return m.GroupName
	}
	return ""
}

func (m *MessageHead) GetMutiltransHead() *MutilTransHead {
	if m != nil {
		return m.MutiltransHead
	}
	return nil
}

func (m *MessageHead) GetMsgInstCtrl() *InstCtrl {
	if m != nil {
		return m.MsgInstCtrl
	}
	return nil
}

func (m *MessageHead) GetPublicAccountGroupSendFlag() int32 {
	if m != nil {
		return m.PublicAccountGroupSendFlag
	}
	return 0
}

func (m *MessageHead) GetWseqInC2CMsghead() int32 {
	if m != nil {
		return m.WseqInC2CMsghead
	}
	return 0
}

func (m *MessageHead) GetCpid() int64 {
	if m != nil {
		return m.Cpid
	}
	return 0
}

func (m *MessageHead) GetExtGroupKeyInfo() *ExtGroupKeyInfo {
	if m != nil {
		return m.ExtGroupKeyInfo
	}
	return nil
}

func (m *MessageHead) GetMultiCompatibleText() string {
	if m != nil {
		return m.MultiCompatibleText
	}
	return ""
}

func (m *MessageHead) GetAuthSex() int32 {
	if m != nil {
		return m.AuthSex
	}
	return 0
}

func (m *MessageHead) GetIsSrcMsg() bool {
	if m != nil {
		return m.IsSrcMsg
	}
	return false
}

type GroupInfo struct {
	GroupCode     int64  `protobuf:"varint,1,opt,name=groupCode" json:"groupCode"`
	GroupType     int32  `protobuf:"varint,2,opt,name=groupType" json:"groupType"`
	GroupInfoSeq  int64  `protobuf:"varint,3,opt,name=groupInfoSeq" json:"groupInfoSeq"`
	GroupCard     string `protobuf:"bytes,4,opt,name=groupCard" json:"groupCard"`
	GroupRank     []byte `protobuf:"bytes,5,opt,name=groupRank" json:"groupRank"`
	GroupLevel    int32  `protobuf:"varint,6,opt,name=groupLevel" json:"groupLevel"`
	GroupCardType int32  `protobuf:"varint,7,opt,name=groupCardType" json:"groupCardType"`
	GroupName     []byte `protobuf:"bytes,8,opt,name=groupName" json:"groupName"`
}

func (m *GroupInfo) Reset()         { *m = GroupInfo{} }
func (m *GroupInfo) String() string { return proto.CompactTextString(m) }
func (*GroupInfo) ProtoMessage()    {}
func (*GroupInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{46}
}
func (m *GroupInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupInfo.Merge(m, src)
}
func (m *GroupInfo) XXX_Size() int {
	return m.Size()
}
func (m *GroupInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GroupInfo proto.InternalMessageInfo

func (m *GroupInfo) GetGroupCode() int64 {
	if m != nil {
		return m.GroupCode
	}
	return 0
}

func (m *GroupInfo) GetGroupType() int32 {
	if m != nil {
		return m.GroupType
	}
	return 0
}

func (m *GroupInfo) GetGroupInfoSeq() int64 {
	if m != nil {
		return m.GroupInfoSeq
	}
	return 0
}

func (m *GroupInfo) GetGroupCard() string {
	if m != nil {
		return m.GroupCard
	}
	return ""
}

func (m *GroupInfo) GetGroupRank() []byte {
	if m != nil {
		return m.GroupRank
	}
	return nil
}

func (m *GroupInfo) GetGroupLevel() int32 {
	if m != nil {
		return m.GroupLevel
	}
	return 0
}

func (m *GroupInfo) GetGroupCardType() int32 {
	if m != nil {
		return m.GroupCardType
	}
	return 0
}

func (m *GroupInfo) GetGroupName() []byte {
	if m != nil {
		return m.GroupName
	}
	return nil
}

type DiscussInfo struct {
	DiscussUin     int64  `protobuf:"varint,1,opt,name=discussUin" json:"discussUin"`
	DiscussType    int32  `protobuf:"varint,2,opt,name=discussType" json:"discussType"`
	DiscussInfoSeq int64  `protobuf:"varint,3,opt,name=discussInfoSeq" json:"discussInfoSeq"`
	DiscussRemark  []byte `protobuf:"bytes,4,opt,name=discussRemark" json:"discussRemark"`
	DiscussName    []byte `protobuf:"bytes,5,opt,name=discussName" json:"discussName"`
}

func (m *DiscussInfo) Reset()         { *m = DiscussInfo{} }
func (m *DiscussInfo) String() string { return proto.CompactTextString(m) }
func (*DiscussInfo) ProtoMessage()    {}
func (*DiscussInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{47}
}
func (m *DiscussInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiscussInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DiscussInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DiscussInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiscussInfo.Merge(m, src)
}
func (m *DiscussInfo) XXX_Size() int {
	return m.Size()
}
func (m *DiscussInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DiscussInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DiscussInfo proto.InternalMessageInfo

func (m *DiscussInfo) GetDiscussUin() int64 {
	if m != nil {
		return m.DiscussUin
	}
	return 0
}

func (m *DiscussInfo) GetDiscussType() int32 {
	if m != nil {
		return m.DiscussType
	}
	return 0
}

func (m *DiscussInfo) GetDiscussInfoSeq() int64 {
	if m != nil {
		return m.DiscussInfoSeq
	}
	return 0
}

func (m *DiscussInfo) GetDiscussRemark() []byte {
	if m != nil {
		return m.DiscussRemark
	}
	return nil
}

func (m *DiscussInfo) GetDiscussName() []byte {
	if m != nil {
		return m.DiscussName
	}
	return nil
}

type MutilTransHead struct {
	Status int32 `protobuf:"varint,1,opt,name=status" json:"status"`
	MsgId  int32 `protobuf:"varint,2,opt,name=msgId" json:"msgId"`
}

func (m *MutilTransHead) Reset()         { *m = MutilTransHead{} }
func (m *MutilTransHead) String() string { return proto.CompactTextString(m) }
func (*MutilTransHead) ProtoMessage()    {}
func (*MutilTransHead) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{48}
}
func (m *MutilTransHead) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MutilTransHead) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MutilTransHead.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MutilTransHead) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MutilTransHead.Merge(m, src)
}
func (m *MutilTransHead) XXX_Size() int {
	return m.Size()
}
func (m *MutilTransHead) XXX_DiscardUnknown() {
	xxx_messageInfo_MutilTransHead.DiscardUnknown(m)
}

var xxx_messageInfo_MutilTransHead proto.InternalMessageInfo

func (m *MutilTransHead) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *MutilTransHead) GetMsgId() int32 {
	if m != nil {
		return m.MsgId
	}
	return 0
}

type C2CTempMessageHead struct {
	C2CType       int32  `protobuf:"varint,1,opt,name=c2cType" json:"c2cType"`
	ServiceType   int32  `protobuf:"varint,2,opt,name=serviceType" json:"serviceType"`
	GroupUin      int64  `protobuf:"varint,3,opt,name=groupUin" json:"groupUin"`
	GroupCode     int64  `protobuf:"varint,4,opt,name=groupCode" json:"groupCode"`
	Sig           []byte `protobuf:"bytes,5,opt,name=sig" json:"sig"`
	SigType       int32  `protobuf:"varint,6,opt,name=sigType" json:"sigType"`
	FromPhone     string `protobuf:"bytes,7,opt,name=fromPhone" json:"fromPhone"`
	ToPhone       string `protobuf:"bytes,8,opt,name=toPhone" json:"toPhone"`
	LockDisplay   int32  `protobuf:"varint,9,opt,name=lockDisplay" json:"lockDisplay"`
	DirectionFlag int32  `protobuf:"varint,10,opt,name=directionFlag" json:"directionFlag"`
	Reserved      []byte `protobuf:"bytes,11,opt,name=reserved" json:"reserved"`
}

func (m *C2CTempMessageHead) Reset()         { *m = C2CTempMessageHead{} }
func (m *C2CTempMessageHead) String() string { return proto.CompactTextString(m) }
func (*C2CTempMessageHead) ProtoMessage()    {}
func (*C2CTempMessageHead) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{49}
}
func (m *C2CTempMessageHead) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2CTempMessageHead) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2CTempMessageHead.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2CTempMessageHead) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2CTempMessageHead.Merge(m, src)
}
func (m *C2CTempMessageHead) XXX_Size() int {
	return m.Size()
}
func (m *C2CTempMessageHead) XXX_DiscardUnknown() {
	xxx_messageInfo_C2CTempMessageHead.DiscardUnknown(m)
}

var xxx_messageInfo_C2CTempMessageHead proto.InternalMessageInfo

func (m *C2CTempMessageHead) GetC2CType() int32 {
	if m != nil {
		return m.C2CType
	}
	return 0
}

func (m *C2CTempMessageHead) GetServiceType() int32 {
	if m != nil {
		return m.ServiceType
	}
	return 0
}

func (m *C2CTempMessageHead) GetGroupUin() int64 {
	if m != nil {
		return m.GroupUin
	}
	return 0
}

func (m *C2CTempMessageHead) GetGroupCode() int64 {
	if m != nil {
		return m.GroupCode
	}
	return 0
}

func (m *C2CTempMessageHead) GetSig() []byte {
	if m != nil {
		return m.Sig
	}
	return nil
}

func (m *C2CTempMessageHead) GetSigType() int32 {
	if m != nil {
		return m.SigType
	}
	return 0
}

func (m *C2CTempMessageHead) GetFromPhone() string {
	if m != nil {
		return m.FromPhone
	}
	return ""
}

func (m *C2CTempMessageHead) GetToPhone() string {
	if m != nil {
		return m.ToPhone
	}
	return ""
}

func (m *C2CTempMessageHead) GetLockDisplay() int32 {
	if m != nil {
		return m.LockDisplay
	}
	return 0
}

func (m *C2CTempMessageHead) GetDirectionFlag() int32 {
	if m != nil {
		return m.DirectionFlag
	}
	return 0
}

func (m *C2CTempMessageHead) GetReserved() []byte {
	if m != nil {
		return m.Reserved
	}
	return nil
}

type InstCtrl struct {
	MsgSendToInst  []*InstInfo `protobuf:"bytes,1,rep,name=msgSendToInst" json:"msgSendToInst,omitempty"`
	MsgExcludeInst []*InstInfo `protobuf:"bytes,2,rep,name=msgExcludeInst" json:"msgExcludeInst,omitempty"`
	MsgFromInst    *InstInfo   `protobuf:"bytes,3,opt,name=msgFromInst" json:"msgFromInst,omitempty"`
}

func (m *InstCtrl) Reset()         { *m = InstCtrl{} }
func (m *InstCtrl) String() string { return proto.CompactTextString(m) }
func (*InstCtrl) ProtoMessage()    {}
func (*InstCtrl) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{50}
}
func (m *InstCtrl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstCtrl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstCtrl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InstCtrl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstCtrl.Merge(m, src)
}
func (m *InstCtrl) XXX_Size() int {
	return m.Size()
}
func (m *InstCtrl) XXX_DiscardUnknown() {
	xxx_messageInfo_InstCtrl.DiscardUnknown(m)
}

var xxx_messageInfo_InstCtrl proto.InternalMessageInfo

func (m *InstCtrl) GetMsgSendToInst() []*InstInfo {
	if m != nil {
		return m.MsgSendToInst
	}
	return nil
}

func (m *InstCtrl) GetMsgExcludeInst() []*InstInfo {
	if m != nil {
		return m.MsgExcludeInst
	}
	return nil
}

func (m *InstCtrl) GetMsgFromInst() *InstInfo {
	if m != nil {
		return m.MsgFromInst
	}
	return nil
}

type InstInfo struct {
	Apppid         int32 `protobuf:"varint,1,opt,name=apppid" json:"apppid"`
	Instid         int32 `protobuf:"varint,2,opt,name=instid" json:"instid"`
	Platform       int32 `protobuf:"varint,3,opt,name=platform" json:"platform"`
	EnumDeviceType int32 `protobuf:"varint,10,opt,name=enumDeviceType" json:"enumDeviceType"`
}

func (m *InstInfo) Reset()         { *m = InstInfo{} }
func (m *InstInfo) String() string { return proto.CompactTextString(m) }
func (*InstInfo) ProtoMessage()    {}
func (*InstInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{51}
}
func (m *InstInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InstInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstInfo.Merge(m, src)
}
func (m *InstInfo) XXX_Size() int {
	return m.Size()
}
func (m *InstInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_InstInfo.DiscardUnknown(m)
}

var xxx_messageInfo_InstInfo proto.InternalMessageInfo

func (m *InstInfo) GetApppid() int32 {
	if m != nil {
		return m.Apppid
	}
	return 0
}

func (m *InstInfo) GetInstid() int32 {
	if m != nil {
		return m.Instid
	}
	return 0
}

func (m *InstInfo) GetPlatform() int32 {
	if m != nil {
		return m.Platform
	}
	return 0
}

func (m *InstInfo) GetEnumDeviceType() int32 {
	if m != nil {
		return m.EnumDeviceType
	}
	return 0
}

type ExtGroupKeyInfo struct {
	CurMaxSeq int32 `protobuf:"varint,1,opt,name=curMaxSeq" json:"curMaxSeq"`
	CurTime   int64 `protobuf:"varint,2,opt,name=curTime" json:"curTime"`
}

func (m *ExtGroupKeyInfo) Reset()         { *m = ExtGroupKeyInfo{} }
func (m *ExtGroupKeyInfo) String() string { return proto.CompactTextString(m) }
func (*ExtGroupKeyInfo) ProtoMessage()    {}
func (*ExtGroupKeyInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{52}
}
func (m *ExtGroupKeyInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExtGroupKeyInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExtGroupKeyInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExtGroupKeyInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtGroupKeyInfo.Merge(m, src)
}
func (m *ExtGroupKeyInfo) XXX_Size() int {
	return m.Size()
}
func (m *ExtGroupKeyInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtGroupKeyInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ExtGroupKeyInfo proto.InternalMessageInfo

func (m *ExtGroupKeyInfo) GetCurMaxSeq() int32 {
	if m != nil {
		return m.CurMaxSeq
	}
	return 0
}

func (m *ExtGroupKeyInfo) GetCurTime() int64 {
	if m != nil {
		return m.CurTime
	}
	return 0
}

type SyncCookie struct {
	Time1        int64 `protobuf:"varint,1,opt,name=time1" json:"time1"`
	Time         int64 `protobuf:"varint,2,opt,name=time" json:"time"`
	Ran1         int64 `protobuf:"varint,3,opt,name=ran1" json:"ran1"`
	Ran2         int64 `protobuf:"varint,4,opt,name=ran2" json:"ran2"`
	Const1       int64 `protobuf:"varint,5,opt,name=const1" json:"const1"`
	Const2       int64 `protobuf:"varint,11,opt,name=const2" json:"const2"`
	Const3       int64 `protobuf:"varint,12,opt,name=const3" json:"const3"`
	LastSyncTime int64 `protobuf:"varint,13,opt,name=lastSyncTime" json:"lastSyncTime"`
	Const4       int64 `protobuf:"varint,14,opt,name=const4" json:"const4"`
}

func (m *SyncCookie) Reset()         { *m = SyncCookie{} }
func (m *SyncCookie) String() string { return proto.CompactTextString(m) }
func (*SyncCookie) ProtoMessage()    {}
func (*SyncCookie) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{53}
}
func (m *SyncCookie) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncCookie) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncCookie.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncCookie) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncCookie.Merge(m, src)
}
func (m *SyncCookie) XXX_Size() int {
	return m.Size()
}
func (m *SyncCookie) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncCookie.DiscardUnknown(m)
}

var xxx_messageInfo_SyncCookie proto.InternalMessageInfo

func (m *SyncCookie) GetTime1() int64 {
	if m != nil {
		return m.Time1
	}
	return 0
}

func (m *SyncCookie) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *SyncCookie) GetRan1() int64 {
	if m != nil {
		return m.Ran1
	}
	return 0
}

func (m *SyncCookie) GetRan2() int64 {
	if m != nil {
		return m.Ran2
	}
	return 0
}

func (m *SyncCookie) GetConst1() int64 {
	if m != nil {
		return m.Const1
	}
	return 0
}

func (m *SyncCookie) GetConst2() int64 {
	if m != nil {
		return m.Const2
	}
	return 0
}

func (m *SyncCookie) GetConst3() int64 {
	if m != nil {
		return m.Const3
	}
	return 0
}

func (m *SyncCookie) GetLastSyncTime() int64 {
	if m != nil {
		return m.LastSyncTime
	}
	return 0
}

func (m *SyncCookie) GetConst4() int64 {
	if m != nil {
		return m.Const4
	}
	return 0
}

type TransMsgInfo struct {
	FromUin         int64            `protobuf:"varint,1,opt,name=fromUin" json:"fromUin"`
	ToUin           int64            `protobuf:"varint,2,opt,name=toUin" json:"toUin"`
	MsgType         int32            `protobuf:"varint,3,opt,name=msgType" json:"msgType"`
	MsgSubtype      int32            `protobuf:"varint,4,opt,name=msgSubtype" json:"msgSubtype"`
	MsgSeq          int32            `protobuf:"varint,5,opt,name=msgSeq" json:"msgSeq"`
	MsgUid          int64            `protobuf:"varint,6,opt,name=msgUid" json:"msgUid"`
	MsgTime         int32            `protobuf:"varint,7,opt,name=msgTime" json:"msgTime"`
	RealMsgTime     int32            `protobuf:"varint,8,opt,name=realMsgTime" json:"realMsgTime"`
	NickName        string           `protobuf:"bytes,9,opt,name=nickName" json:"nickName"`
	MsgData         []byte           `protobuf:"bytes,10,opt,name=msgData" json:"msgData"`
	SvrIp           int32            `protobuf:"varint,11,opt,name=svrIp" json:"svrIp"`
	ExtGroupKeyInfo *ExtGroupKeyInfo `protobuf:"bytes,12,opt,name=extGroupKeyInfo" json:"extGroupKeyInfo,omitempty"`
	GeneralFlag     int32            `protobuf:"varint,17,opt,name=generalFlag" json:"generalFlag"`
}

func (m *TransMsgInfo) Reset()         { *m = TransMsgInfo{} }
func (m *TransMsgInfo) String() string { return proto.CompactTextString(m) }
func (*TransMsgInfo) ProtoMessage()    {}
func (*TransMsgInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{54}
}
func (m *TransMsgInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransMsgInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransMsgInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransMsgInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransMsgInfo.Merge(m, src)
}
func (m *TransMsgInfo) XXX_Size() int {
	return m.Size()
}
func (m *TransMsgInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TransMsgInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TransMsgInfo proto.InternalMessageInfo

func (m *TransMsgInfo) GetFromUin() int64 {
	if m != nil {
		return m.FromUin
	}
	return 0
}

func (m *TransMsgInfo) GetToUin() int64 {
	if m != nil {
		return m.ToUin
	}
	return 0
}

func (m *TransMsgInfo) GetMsgType() int32 {
	if m != nil {
		return m.MsgType
	}
	return 0
}

func (m *TransMsgInfo) GetMsgSubtype() int32 {
	if m != nil {
		return m.MsgSubtype
	}
	return 0
}

func (m *TransMsgInfo) GetMsgSeq() int32 {
	if m != nil {
		return m.MsgSeq
	}
	return 0
}

func (m *TransMsgInfo) GetMsgUid() int64 {
	if m != nil {
		return m.MsgUid
	}
	return 0
}

func (m *TransMsgInfo) GetMsgTime() int32 {
	if m != nil {
		return m.MsgTime
	}
	return 0
}

func (m *TransMsgInfo) GetRealMsgTime() int32 {
	if m != nil {
		return m.RealMsgTime
	}
	return 0
}

func (m *TransMsgInfo) GetNickName() string {
	if m != nil {
		return m.NickName
	}
	return ""
}

func (m *TransMsgInfo) GetMsgData() []byte {
	if m != nil {
		return m.MsgData
	}
	return nil
}

func (m *TransMsgInfo) GetSvrIp() int32 {
	if m != nil {
		return m.SvrIp
	}
	return 0
}

func (m *TransMsgInfo) GetExtGroupKeyInfo() *ExtGroupKeyInfo {
	if m != nil {
		return m.ExtGroupKeyInfo
	}
	return nil
}

func (m *TransMsgInfo) GetGeneralFlag() int32 {
	if m != nil {
		return m.GeneralFlag
	}
	return 0
}

type GeneralFlags struct {
	BubbleDiyTextId     int32  `protobuf:"varint,1,opt,name=bubbleDiyTextId" json:"bubbleDiyTextId"`
	GroupFlagNew        int32  `protobuf:"varint,2,opt,name=groupFlagNew" json:"groupFlagNew"`
	Uin                 int64  `protobuf:"varint,3,opt,name=uin" json:"uin"`
	RpId                []byte `protobuf:"bytes,4,opt,name=rpId" json:"rpId"`
	PrpFold             int32  `protobuf:"varint,5,opt,name=prpFold" json:"prpFold"`
	LongTextFlag        int32  `protobuf:"varint,6,opt,name=longTextFlag" json:"longTextFlag"`
	LongTextResid       string `protobuf:"bytes,7,opt,name=longTextResid" json:"longTextResid"`
	GroupType           int32  `protobuf:"varint,8,opt,name=groupType" json:"groupType"`
	ToUinFlag           int32  `protobuf:"varint,9,opt,name=toUinFlag" json:"toUinFlag"`
	GlamourLevel        int32  `protobuf:"varint,10,opt,name=glamourLevel" json:"glamourLevel"`
	MemberLevel         int32  `protobuf:"varint,11,opt,name=memberLevel" json:"memberLevel"`
	GroupRankSeq        int64  `protobuf:"varint,12,opt,name=groupRankSeq" json:"groupRankSeq"`
	OlympicTorch        int32  `protobuf:"varint,13,opt,name=olympicTorch" json:"olympicTorch"`
	BabyqGuideMsgCookie []byte `protobuf:"bytes,14,opt,name=babyqGuideMsgCookie" json:"babyqGuideMsgCookie"`
	Uin32ExpertFlag     int32  `protobuf:"varint,15,opt,name=uin32ExpertFlag" json:"uin32ExpertFlag"`
	BubbleSubId         int32  `protobuf:"varint,16,opt,name=bubbleSubId" json:"bubbleSubId"`
	PendantId           int64  `protobuf:"varint,17,opt,name=pendantId" json:"pendantId"`
	RpIndex             []byte `protobuf:"bytes,18,opt,name=rpIndex" json:"rpIndex"`
	PbReserve           []byte `protobuf:"bytes,19,opt,name=pbReserve" json:"pbReserve"`
}

func (m *GeneralFlags) Reset()         { *m = GeneralFlags{} }
func (m *GeneralFlags) String() string { return proto.CompactTextString(m) }
func (*GeneralFlags) ProtoMessage()    {}
func (*GeneralFlags) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{55}
}
func (m *GeneralFlags) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GeneralFlags) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GeneralFlags.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GeneralFlags) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GeneralFlags.Merge(m, src)
}
func (m *GeneralFlags) XXX_Size() int {
	return m.Size()
}
func (m *GeneralFlags) XXX_DiscardUnknown() {
	xxx_messageInfo_GeneralFlags.DiscardUnknown(m)
}

var xxx_messageInfo_GeneralFlags proto.InternalMessageInfo

func (m *GeneralFlags) GetBubbleDiyTextId() int32 {
	if m != nil {
		return m.BubbleDiyTextId
	}
	return 0
}

func (m *GeneralFlags) GetGroupFlagNew() int32 {
	if m != nil {
		return m.GroupFlagNew
	}
	return 0
}

func (m *GeneralFlags) GetUin() int64 {
	if m != nil {
		return m.Uin
	}
	return 0
}

func (m *GeneralFlags) GetRpId() []byte {
	if m != nil {
		return m.RpId
	}
	return nil
}

func (m *GeneralFlags) GetPrpFold() int32 {
	if m != nil {
		return m.PrpFold
	}
	return 0
}

func (m *GeneralFlags) GetLongTextFlag() int32 {
	if m != nil {
		return m.LongTextFlag
	}
	return 0
}

func (m *GeneralFlags) GetLongTextResid() string {
	if m != nil {
		return m.LongTextResid
	}
	return ""
}

func (m *GeneralFlags) GetGroupType() int32 {
	if m != nil {
		return m.GroupType
	}
	return 0
}

func (m *GeneralFlags) GetToUinFlag() int32 {
	if m != nil {
		return m.ToUinFlag
	}
	return 0
}

func (m *GeneralFlags) GetGlamourLevel() int32 {
	if m != nil {
		return m.GlamourLevel
	}
	return 0
}

func (m *GeneralFlags) GetMemberLevel() int32 {
	if m != nil {
		return m.MemberLevel
	}
	return 0
}

func (m *GeneralFlags) GetGroupRankSeq() int64 {
	if m != nil {
		return m.GroupRankSeq
	}
	return 0
}

func (m *GeneralFlags) GetOlympicTorch() int32 {
	if m != nil {
		return m.OlympicTorch
	}
	return 0
}

func (m *GeneralFlags) GetBabyqGuideMsgCookie() []byte {
	if m != nil {
		return m.BabyqGuideMsgCookie
	}
	return nil
}

func (m *GeneralFlags) GetUin32ExpertFlag() int32 {
	if m != nil {
		return m.Uin32ExpertFlag
	}
	return 0
}

func (m *GeneralFlags) GetBubbleSubId() int32 {
	if m != nil {
		return m.BubbleSubId
	}
	return 0
}

func (m *GeneralFlags) GetPendantId() int64 {
	if m != nil {
		return m.PendantId
	}
	return 0
}

func (m *GeneralFlags) GetRpIndex() []byte {
	if m != nil {
		return m.RpIndex
	}
	return nil
}

func (m *GeneralFlags) GetPbReserve() []byte {
	if m != nil {
		return m.PbReserve
	}
	return nil
}

type PbMultiMsgItem struct {
	FileName string         `protobuf:"bytes,1,opt,name=fileName" json:"fileName"`
	Buffer   *PbMultiMsgNew `protobuf:"bytes,2,opt,name=buffer" json:"buffer,omitempty"`
}

func (m *PbMultiMsgItem) Reset()         { *m = PbMultiMsgItem{} }
func (m *PbMultiMsgItem) String() string { return proto.CompactTextString(m) }
func (*PbMultiMsgItem) ProtoMessage()    {}
func (*PbMultiMsgItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{56}
}
func (m *PbMultiMsgItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PbMultiMsgItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PbMultiMsgItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PbMultiMsgItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PbMultiMsgItem.Merge(m, src)
}
func (m *PbMultiMsgItem) XXX_Size() int {
	return m.Size()
}
func (m *PbMultiMsgItem) XXX_DiscardUnknown() {
	xxx_messageInfo_PbMultiMsgItem.DiscardUnknown(m)
}

var xxx_messageInfo_PbMultiMsgItem proto.InternalMessageInfo

func (m *PbMultiMsgItem) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *PbMultiMsgItem) GetBuffer() *PbMultiMsgNew {
	if m != nil {
		return m.Buffer
	}
	return nil
}

type PbMultiMsgNew struct {
	Msg []*Message `protobuf:"bytes,1,rep,name=msg" json:"msg,omitempty"`
}

func (m *PbMultiMsgNew) Reset()         { *m = PbMultiMsgNew{} }
func (m *PbMultiMsgNew) String() string { return proto.CompactTextString(m) }
func (*PbMultiMsgNew) ProtoMessage()    {}
func (*PbMultiMsgNew) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{57}
}
func (m *PbMultiMsgNew) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PbMultiMsgNew) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PbMultiMsgNew.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PbMultiMsgNew) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PbMultiMsgNew.Merge(m, src)
}
func (m *PbMultiMsgNew) XXX_Size() int {
	return m.Size()
}
func (m *PbMultiMsgNew) XXX_DiscardUnknown() {
	xxx_messageInfo_PbMultiMsgNew.DiscardUnknown(m)
}

var xxx_messageInfo_PbMultiMsgNew proto.InternalMessageInfo

func (m *PbMultiMsgNew) GetMsg() []*Message {
	if m != nil {
		return m.Msg
	}
	return nil
}

type PbMultiMsgTransmit struct {
	Msg        []*Message        `protobuf:"bytes,1,rep,name=msg" json:"msg,omitempty"`
	PbItemList []*PbMultiMsgItem `protobuf:"bytes,2,rep,name=pbItemList" json:"pbItemList,omitempty"`
}

func (m *PbMultiMsgTransmit) Reset()         { *m = PbMultiMsgTransmit{} }
func (m *PbMultiMsgTransmit) String() string { return proto.CompactTextString(m) }
func (*PbMultiMsgTransmit) ProtoMessage()    {}
func (*PbMultiMsgTransmit) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{58}
}
func (m *PbMultiMsgTransmit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PbMultiMsgTransmit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PbMultiMsgTransmit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PbMultiMsgTransmit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PbMultiMsgTransmit.Merge(m, src)
}
func (m *PbMultiMsgTransmit) XXX_Size() int {
	return m.Size()
}
func (m *PbMultiMsgTransmit) XXX_DiscardUnknown() {
	xxx_messageInfo_PbMultiMsgTransmit.DiscardUnknown(m)
}

var xxx_messageInfo_PbMultiMsgTransmit proto.InternalMessageInfo

func (m *PbMultiMsgTransmit) GetMsg() []*Message {
	if m != nil {
		return m.Msg
	}
	return nil
}

func (m *PbMultiMsgTransmit) GetPbItemList() []*PbMultiMsgItem {
	if m != nil {
		return m.PbItemList
	}
	return nil
}

type MsgElemInfoServtype3 struct {
	FlashTroopPic *CustomFace     `protobuf:"bytes,1,opt,name=flash_troop_pic,json=flashTroopPic" json:"flash_troop_pic,omitempty"`
	FlashC2CPic   *NotOnlineImage `protobuf:"bytes,2,opt,name=flash_c2c_pic,json=flashC2cPic" json:"flash_c2c_pic,omitempty"`
}

func (m *MsgElemInfoServtype3) Reset()         { *m = MsgElemInfoServtype3{} }
func (m *MsgElemInfoServtype3) String() string { return proto.CompactTextString(m) }
func (*MsgElemInfoServtype3) ProtoMessage()    {}
func (*MsgElemInfoServtype3) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{59}
}
func (m *MsgElemInfoServtype3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgElemInfoServtype3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgElemInfoServtype3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgElemInfoServtype3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgElemInfoServtype3.Merge(m, src)
}
func (m *MsgElemInfoServtype3) XXX_Size() int {
	return m.Size()
}
func (m *MsgElemInfoServtype3) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgElemInfoServtype3.DiscardUnknown(m)
}

var xxx_messageInfo_MsgElemInfoServtype3 proto.InternalMessageInfo

func (m *MsgElemInfoServtype3) GetFlashTroopPic() *CustomFace {
	if m != nil {
		return m.FlashTroopPic
	}
	return nil
}

func (m *MsgElemInfoServtype3) GetFlashC2CPic() *NotOnlineImage {
	if m != nil {
		return m.FlashC2CPic
	}
	return nil
}

type MsgElemInfoServtype33 struct {
	Index  uint32 `protobuf:"varint,1,opt,name=index" json:"index"`
	Text   []byte `protobuf:"bytes,2,opt,name=text" json:"text"`
	Compat []byte `protobuf:"bytes,3,opt,name=compat" json:"compat"`
	Buf    []byte `protobuf:"bytes,4,opt,name=buf" json:"buf"`
}

func (m *MsgElemInfoServtype33) Reset()         { *m = MsgElemInfoServtype33{} }
func (m *MsgElemInfoServtype33) String() string { return proto.CompactTextString(m) }
func (*MsgElemInfoServtype33) ProtoMessage()    {}
func (*MsgElemInfoServtype33) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{60}
}
func (m *MsgElemInfoServtype33) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgElemInfoServtype33) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgElemInfoServtype33.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgElemInfoServtype33) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgElemInfoServtype33.Merge(m, src)
}
func (m *MsgElemInfoServtype33) XXX_Size() int {
	return m.Size()
}
func (m *MsgElemInfoServtype33) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgElemInfoServtype33.DiscardUnknown(m)
}

var xxx_messageInfo_MsgElemInfoServtype33 proto.InternalMessageInfo

func (m *MsgElemInfoServtype33) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *MsgElemInfoServtype33) GetText() []byte {
	if m != nil {
		return m.Text
	}
	return nil
}

func (m *MsgElemInfoServtype33) GetCompat() []byte {
	if m != nil {
		return m.Compat
	}
	return nil
}

func (m *MsgElemInfoServtype33) GetBuf() []byte {
	if m != nil {
		return m.Buf
	}
	return nil
}

type SubMsgType0X4Body struct {
	NotOnlineFile              *NotOnlineFile `protobuf:"bytes,1,opt,name=notOnlineFile" json:"notOnlineFile,omitempty"`
	MsgTime                    uint32         `protobuf:"varint,2,opt,name=msgTime" json:"msgTime"`
	OnlineFileForPolyToOffline uint32         `protobuf:"varint,3,opt,name=onlineFileForPolyToOffline" json:"onlineFileForPolyToOffline"`
}

func (m *SubMsgType0X4Body) Reset()         { *m = SubMsgType0X4Body{} }
func (m *SubMsgType0X4Body) String() string { return proto.CompactTextString(m) }
func (*SubMsgType0X4Body) ProtoMessage()    {}
func (*SubMsgType0X4Body) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{61}
}
func (m *SubMsgType0X4Body) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubMsgType0X4Body) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubMsgType0X4Body.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubMsgType0X4Body) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubMsgType0X4Body.Merge(m, src)
}
func (m *SubMsgType0X4Body) XXX_Size() int {
	return m.Size()
}
func (m *SubMsgType0X4Body) XXX_DiscardUnknown() {
	xxx_messageInfo_SubMsgType0X4Body.DiscardUnknown(m)
}

var xxx_messageInfo_SubMsgType0X4Body proto.InternalMessageInfo

func (m *SubMsgType0X4Body) GetNotOnlineFile() *NotOnlineFile {
	if m != nil {
		return m.NotOnlineFile
	}
	return nil
}

func (m *SubMsgType0X4Body) GetMsgTime() uint32 {
	if m != nil {
		return m.MsgTime
	}
	return 0
}

func (m *SubMsgType0X4Body) GetOnlineFileForPolyToOffline() uint32 {
	if m != nil {
		return m.OnlineFileForPolyToOffline
	}
	return 0
}

type ResvAttr struct {
	ImageShow *AnimationImageShow `protobuf:"bytes,7,opt,name=image_show,json=imageShow" json:"image_show,omitempty"`
}

func (m *ResvAttr) Reset()         { *m = ResvAttr{} }
func (m *ResvAttr) String() string { return proto.CompactTextString(m) }
func (*ResvAttr) ProtoMessage()    {}
func (*ResvAttr) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{62}
}
func (m *ResvAttr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResvAttr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResvAttr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResvAttr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResvAttr.Merge(m, src)
}
func (m *ResvAttr) XXX_Size() int {
	return m.Size()
}
func (m *ResvAttr) XXX_DiscardUnknown() {
	xxx_messageInfo_ResvAttr.DiscardUnknown(m)
}

var xxx_messageInfo_ResvAttr proto.InternalMessageInfo

func (m *ResvAttr) GetImageShow() *AnimationImageShow {
	if m != nil {
		return m.ImageShow
	}
	return nil
}

type AnimationImageShow struct {
	EffectId       int32  `protobuf:"varint,1,opt,name=effect_id,json=effectId" json:"effect_id"`
	AnimationParam []byte `protobuf:"bytes,2,opt,name=animation_param,json=animationParam" json:"animation_param"`
}

func (m *AnimationImageShow) Reset()         { *m = AnimationImageShow{} }
func (m *AnimationImageShow) String() string { return proto.CompactTextString(m) }
func (*AnimationImageShow) ProtoMessage()    {}
func (*AnimationImageShow) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{63}
}
func (m *AnimationImageShow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AnimationImageShow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AnimationImageShow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AnimationImageShow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnimationImageShow.Merge(m, src)
}
func (m *AnimationImageShow) XXX_Size() int {
	return m.Size()
}
func (m *AnimationImageShow) XXX_DiscardUnknown() {
	xxx_messageInfo_AnimationImageShow.DiscardUnknown(m)
}

var xxx_messageInfo_AnimationImageShow proto.InternalMessageInfo

func (m *AnimationImageShow) GetEffectId() int32 {
	if m != nil {
		return m.EffectId
	}
	return 0
}

func (m *AnimationImageShow) GetAnimationParam() []byte {
	if m != nil {
		return m.AnimationParam
	}
	return nil
}

type UinTypeUserDef struct {
	FromUinType   int32  `protobuf:"varint,1,opt,name=fromUinType" json:"fromUinType"`
	FromGroupCode int64  `protobuf:"varint,2,opt,name=fromGroupCode" json:"fromGroupCode"`
	FileUuid      string `protobuf:"bytes,3,opt,name=fileUuid" json:"fileUuid"`
}

func (m *UinTypeUserDef) Reset()         { *m = UinTypeUserDef{} }
func (m *UinTypeUserDef) String() string { return proto.CompactTextString(m) }
func (*UinTypeUserDef) ProtoMessage()    {}
func (*UinTypeUserDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{64}
}
func (m *UinTypeUserDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UinTypeUserDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UinTypeUserDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UinTypeUserDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UinTypeUserDef.Merge(m, src)
}
func (m *UinTypeUserDef) XXX_Size() int {
	return m.Size()
}
func (m *UinTypeUserDef) XXX_DiscardUnknown() {
	xxx_messageInfo_UinTypeUserDef.DiscardUnknown(m)
}

var xxx_messageInfo_UinTypeUserDef proto.InternalMessageInfo

func (m *UinTypeUserDef) GetFromUinType() int32 {
	if m != nil {
		return m.FromUinType
	}
	return 0
}

func (m *UinTypeUserDef) GetFromGroupCode() int64 {
	if m != nil {
		return m.FromGroupCode
	}
	return 0
}

func (m *UinTypeUserDef) GetFileUuid() string {
	if m != nil {
		return m.FileUuid
	}
	return ""
}

type GetGroupMsgReq struct {
	GroupCode       uint64 `protobuf:"varint,1,opt,name=groupCode" json:"groupCode"`
	BeginSeq        uint64 `protobuf:"varint,2,opt,name=beginSeq" json:"beginSeq"`
	EndSeq          uint64 `protobuf:"varint,3,opt,name=endSeq" json:"endSeq"`
	Filter          uint32 `protobuf:"varint,4,opt,name=filter" json:"filter"`
	MemberSeq       uint64 `protobuf:"varint,5,opt,name=memberSeq" json:"memberSeq"`
	PublicGroup     bool   `protobuf:"varint,6,opt,name=publicGroup" json:"publicGroup"`
	ShieldFlag      uint32 `protobuf:"varint,7,opt,name=shieldFlag" json:"shieldFlag"`
	SaveTrafficFlag uint32 `protobuf:"varint,8,opt,name=saveTrafficFlag" json:"saveTrafficFlag"`
}

func (m *GetGroupMsgReq) Reset()         { *m = GetGroupMsgReq{} }
func (m *GetGroupMsgReq) String() string { return proto.CompactTextString(m) }
func (*GetGroupMsgReq) ProtoMessage()    {}
func (*GetGroupMsgReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{65}
}
func (m *GetGroupMsgReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetGroupMsgReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetGroupMsgReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetGroupMsgReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetGroupMsgReq.Merge(m, src)
}
func (m *GetGroupMsgReq) XXX_Size() int {
	return m.Size()
}
func (m *GetGroupMsgReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetGroupMsgReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetGroupMsgReq proto.InternalMessageInfo

func (m *GetGroupMsgReq) GetGroupCode() uint64 {
	if m != nil {
		return m.GroupCode
	}
	return 0
}

func (m *GetGroupMsgReq) GetBeginSeq() uint64 {
	if m != nil {
		return m.BeginSeq
	}
	return 0
}

func (m *GetGroupMsgReq) GetEndSeq() uint64 {
	if m != nil {
		return m.EndSeq
	}
	return 0
}

func (m *GetGroupMsgReq) GetFilter() uint32 {
	if m != nil {
		return m.Filter
	}
	return 0
}

func (m *GetGroupMsgReq) GetMemberSeq() uint64 {
	if m != nil {
		return m.MemberSeq
	}
	return 0
}

func (m *GetGroupMsgReq) GetPublicGroup() bool {
	if m != nil {
		return m.PublicGroup
	}
	return false
}

func (m *GetGroupMsgReq) GetShieldFlag() uint32 {
	if m != nil {
		return m.ShieldFlag
	}
	return 0
}

func (m *GetGroupMsgReq) GetSaveTrafficFlag() uint32 {
	if m != nil {
		return m.SaveTrafficFlag
	}
	return 0
}

type GetGroupMsgResp struct {
	Result         uint32     `protobuf:"varint,1,opt,name=result" json:"result"`
	Errmsg         string     `protobuf:"bytes,2,opt,name=errmsg" json:"errmsg"`
	GroupCode      uint64     `protobuf:"varint,3,opt,name=groupCode" json:"groupCode"`
	ReturnBeginSeq uint64     `protobuf:"varint,4,opt,name=returnBeginSeq" json:"returnBeginSeq"`
	ReturnEndSeq   uint64     `protobuf:"varint,5,opt,name=returnEndSeq" json:"returnEndSeq"`
	Msg            []*Message `protobuf:"bytes,6,rep,name=msg" json:"msg,omitempty"`
}

func (m *GetGroupMsgResp) Reset()         { *m = GetGroupMsgResp{} }
func (m *GetGroupMsgResp) String() string { return proto.CompactTextString(m) }
func (*GetGroupMsgResp) ProtoMessage()    {}
func (*GetGroupMsgResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_c06e4cca6c2cc899, []int{66}
}
func (m *GetGroupMsgResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetGroupMsgResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetGroupMsgResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetGroupMsgResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetGroupMsgResp.Merge(m, src)
}
func (m *GetGroupMsgResp) XXX_Size() int {
	return m.Size()
}
func (m *GetGroupMsgResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetGroupMsgResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetGroupMsgResp proto.InternalMessageInfo

func (m *GetGroupMsgResp) GetResult() uint32 {
	if m != nil {
		return m.Result
	}
	return 0
}

func (m *GetGroupMsgResp) GetErrmsg() string {
	if m != nil {
		return m.Errmsg
	}
	return ""
}

func (m *GetGroupMsgResp) GetGroupCode() uint64 {
	if m != nil {
		return m.GroupCode
	}
	return 0
}

func (m *GetGroupMsgResp) GetReturnBeginSeq() uint64 {
	if m != nil {
		return m.ReturnBeginSeq
	}
	return 0
}

func (m *GetGroupMsgResp) GetReturnEndSeq() uint64 {
	if m != nil {
		return m.ReturnEndSeq
	}
	return 0
}

func (m *GetGroupMsgResp) GetMsg() []*Message {
	if m != nil {
		return m.Msg
	}
	return nil
}

func init() {
	proto.RegisterEnum("SyncFlag", SyncFlag_name, SyncFlag_value)
	proto.RegisterType((*GetMessageRequest)(nil), "GetMessageRequest")
	proto.RegisterType((*SendMessageRequest)(nil), "SendMessageRequest")
	proto.RegisterType((*SendMessageResponse)(nil), "SendMessageResponse")
	proto.RegisterType((*MsgWithDrawReq)(nil), "MsgWithDrawReq")
	proto.RegisterType((*C2CMsgWithDrawReq)(nil), "C2CMsgWithDrawReq")
	proto.RegisterType((*GroupMsgWithDrawReq)(nil), "GroupMsgWithDrawReq")
	proto.RegisterType((*MsgWithDrawResp)(nil), "MsgWithDrawResp")
	proto.RegisterType((*C2CMsgWithDrawResp)(nil), "C2CMsgWithDrawResp")
	proto.RegisterType((*GroupMsgWithDrawResp)(nil), "GroupMsgWithDrawResp")
	proto.RegisterType((*GroupMsgInfo)(nil), "GroupMsgInfo")
	proto.RegisterType((*C2CMsgInfo)(nil), "C2CMsgInfo")
	proto.RegisterType((*RoutingHead)(nil), "RoutingHead")
	proto.RegisterType((*C2C)(nil), "C2C")
	proto.RegisterType((*Grp)(nil), "Grp")
	proto.RegisterType((*GrpTmp)(nil), "GrpTmp")
	proto.RegisterType((*MsgCtrl)(nil), "MsgCtrl")
	proto.RegisterType((*GetMessageResponse)(nil), "GetMessageResponse")
	proto.RegisterType((*PushMessagePacket)(nil), "PushMessagePacket")
	proto.RegisterType((*UinPairMessage)(nil), "UinPairMessage")
	proto.RegisterType((*Message)(nil), "Message")
	proto.RegisterType((*MessageBody)(nil), "MessageBody")
	proto.RegisterType((*RichText)(nil), "RichText")
	proto.RegisterType((*Elem)(nil), "Elem")
	proto.RegisterType((*CommonElem)(nil), "CommonElem")
	proto.RegisterType((*QQWalletMsg)(nil), "QQWalletMsg")
	proto.RegisterType((*QQWalletAioBody)(nil), "QQWalletAioBody")
	proto.RegisterType((*QQWalletAioElem)(nil), "QQWalletAioElem")
	proto.RegisterType((*RichMsg)(nil), "RichMsg")
	proto.RegisterType((*CustomElem)(nil), "CustomElem")
	proto.RegisterType((*Text)(nil), "Text")
	proto.RegisterType((*Attr)(nil), "Attr")
	proto.RegisterType((*Ptt)(nil), "Ptt")
	proto.RegisterType((*OnlineImage)(nil), "OnlineImage")
	proto.RegisterType((*NotOnlineImage)(nil), "NotOnlineImage")
	proto.RegisterType((*NotOnlineFile)(nil), "NotOnlineFile")
	proto.RegisterType((*TransElem)(nil), "TransElem")
	proto.RegisterType((*ExtraInfo)(nil), "ExtraInfo")
	proto.RegisterType((*GroupFile)(nil), "GroupFile")
	proto.RegisterType((*AnonymousGroupMessage)(nil), "AnonymousGroupMessage")
	proto.RegisterType((*VideoFile)(nil), "VideoFile")
	proto.RegisterType((*SourceMsg)(nil), "SourceMsg")
	proto.RegisterType((*Face)(nil), "Face")
	proto.RegisterType((*LightAppElem)(nil), "LightAppElem")
	proto.RegisterType((*CustomFace)(nil), "CustomFace")
	proto.RegisterType((*ContentHead)(nil), "ContentHead")
	proto.RegisterType((*MessageHead)(nil), "MessageHead")
	proto.RegisterType((*GroupInfo)(nil), "GroupInfo")
	proto.RegisterType((*DiscussInfo)(nil), "DiscussInfo")
	proto.RegisterType((*MutilTransHead)(nil), "MutilTransHead")
	proto.RegisterType((*C2CTempMessageHead)(nil), "C2CTempMessageHead")
	proto.RegisterType((*InstCtrl)(nil), "InstCtrl")
	proto.RegisterType((*InstInfo)(nil), "InstInfo")
	proto.RegisterType((*ExtGroupKeyInfo)(nil), "ExtGroupKeyInfo")
	proto.RegisterType((*SyncCookie)(nil), "SyncCookie")
	proto.RegisterType((*TransMsgInfo)(nil), "TransMsgInfo")
	proto.RegisterType((*GeneralFlags)(nil), "GeneralFlags")
	proto.RegisterType((*PbMultiMsgItem)(nil), "PbMultiMsgItem")
	proto.RegisterType((*PbMultiMsgNew)(nil), "PbMultiMsgNew")
	proto.RegisterType((*PbMultiMsgTransmit)(nil), "PbMultiMsgTransmit")
	proto.RegisterType((*MsgElemInfoServtype3)(nil), "MsgElemInfo_servtype3")
	proto.RegisterType((*MsgElemInfoServtype33)(nil), "MsgElemInfo_servtype33")
	proto.RegisterType((*SubMsgType0X4Body)(nil), "SubMsgType0x4Body")
	proto.RegisterType((*ResvAttr)(nil), "ResvAttr")
	proto.RegisterType((*AnimationImageShow)(nil), "AnimationImageShow")
	proto.RegisterType((*UinTypeUserDef)(nil), "UinTypeUserDef")
	proto.RegisterType((*GetGroupMsgReq)(nil), "GetGroupMsgReq")
	proto.RegisterType((*GetGroupMsgResp)(nil), "GetGroupMsgResp")
}

func init() { proto.RegisterFile("msg.proto", fileDescriptor_c06e4cca6c2cc899) }

var fileDescriptor_c06e4cca6c2cc899 = []byte{
	// 6016 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x5c, 0x4d, 0x8c, 0x24, 0xc9,
	0x55, 0xde, 0xea, 0xaa, 0xea, 0xae, 0x8a, 0xfe, 0x9b, 0xce, 0x99, 0x59, 0xd7, 0x8e, 0x67, 0x67,
	0x67, 0x93, 0xb5, 0x19, 0xef, 0xae, 0xcb, 0xbb, 0x3d, 0xb3, 0x5e, 0x6c, 0x23, 0xa4, 0x99, 0x9e,
	0x1f, 0xb7, 0xbd, 0x3d, 0xdb, 0x9b, 0xdd, 0xb3, 0x96, 0x7c, 0x60, 0x94, 0x95, 0x15, 0x55, 0x95,
	0x74, 0xfe, 0x4d, 0xfe, 0xf4, 0x4c, 0x5b, 0x5c, 0x40, 0x80, 0x84, 0x84, 0xc0, 0x07, 0x64, 0x21,
	0xf9, 0xc2, 0x85, 0x0b, 0x20, 0x71, 0xe1, 0x80, 0xc4, 0x09, 0xc1, 0xc1, 0x07, 0x90, 0x7c, 0x42,
	0xbe, 0x18, 0x90, 0x8d, 0xaf, 0x1c, 0x7d, 0x46, 0xef, 0xc5, 0x4f, 0xbe, 0x97, 0x95, 0xbd, 0x3d,
	0x92, 0xe1, 0xd6, 0xf5, 0xbd, 0x97, 0x91, 0x91, 0x2f, 0x5e, 0xbc, 0xf7, 0xc5, 0x8b, 0x88, 0x16,
	0xc3, 0xb8, 0x98, 0x8f, 0xb3, 0x3c, 0x2d, 0x53, 0xf7, 0x2f, 0x7b, 0x62, 0xe7, 0x91, 0x2c, 0x0f,
	0x64, 0x51, 0xf8, 0x73, 0xe9, 0xc9, 0x67, 0x95, 0x2c, 0x4a, 0xe7, 0x1d, 0x31, 0x28, 0xce, 0x92,
	0xe0, 0x61, 0xe4, 0xcf, 0x47, 0x9d, 0x9b, 0x9d, 0x5b, 0x5b, 0xbb, 0xc3, 0xf1, 0x91, 0x06, 0xee,
	0xf5, 0x7e, 0xf4, 0x1f, 0x6f, 0xbc, 0xe2, 0x59, 0x05, 0xe7, 0x2d, 0x21, 0xe0, 0xef, 0xbd, 0x34,
	0x3d, 0x09, 0xe5, 0x68, 0xe5, 0x66, 0xe7, 0xd6, 0x86, 0xd6, 0x21, 0x38, 0x68, 0xe5, 0x7e, 0x3c,
	0x89, 0x24, 0x36, 0xda, 0xbd, 0xd9, 0xb9, 0xd5, 0x37, 0x5a, 0x35, 0xee, 0xdc, 0x11, 0x4e, 0xe4,
	0x97, 0xb2, 0x28, 0x3d, 0xc4, 0x1e, 0x57, 0xf1, 0x44, 0xe6, 0xa3, 0x1e, 0xd1, 0x6e, 0x91, 0x3b,
	0xbb, 0x62, 0x27, 0x2d, 0x17, 0x32, 0x67, 0x0f, 0xf5, 0xc9, 0x43, 0xcb, 0x62, 0xe7, 0x5d, 0xb1,
	0x95, 0x26, 0x51, 0x98, 0x48, 0xf3, 0x5d, 0xa3, 0x55, 0xf2, 0x40, 0x43, 0xe6, 0x7c, 0x51, 0xac,
	0x07, 0x69, 0x52, 0xca, 0x17, 0x25, 0xaa, 0xae, 0x11, 0x55, 0x2a, 0x70, 0xde, 0x13, 0x97, 0x9e,
	0x2f, 0xc2, 0x22, 0x93, 0xf9, 0x91, 0x2c, 0x8a, 0x30, 0x4d, 0xf6, 0xa7, 0xa3, 0x01, 0x51, 0x5e,
	0x92, 0x82, 0x5d, 0xe2, 0x62, 0xee, 0xc9, 0x67, 0xc7, 0x67, 0x99, 0x1c, 0x0d, 0xa9, 0x5d, 0x6a,
	0x1c, 0xda, 0xcd, 0xaa, 0x89, 0x1f, 0x04, 0x69, 0x95, 0x94, 0xda, 0xd2, 0x82, 0x58, 0x7a, 0x49,
	0xaa, 0xdb, 0xdd, 0x2b, 0xf3, 0xe8, 0x5e, 0x35, 0x1b, 0xad, 0xd3, 0x51, 0xa9, 0x71, 0xc7, 0x15,
	0xc3, 0x42, 0xe6, 0xa7, 0x32, 0x07, 0xa5, 0x0d, 0xa2, 0x54, 0xc3, 0xee, 0x9f, 0x77, 0x85, 0x73,
	0x24, 0x93, 0x69, 0xc3, 0x47, 0xc6, 0x62, 0x3d, 0x4f, 0xab, 0x32, 0x4c, 0xe6, 0xdf, 0x94, 0xfe,
	0x14, 0xdd, 0x64, 0x7d, 0x77, 0x63, 0xec, 0xd5, 0x98, 0x47, 0x15, 0x40, 0x1f, 0x2d, 0x95, 0x94,
	0xa8, 0xbf, 0xa2, 0xf5, 0xf7, 0x6a, 0xcc, 0xa3, 0x0a, 0xce, 0x17, 0xc5, 0x5a, 0x5c, 0xcc, 0xef,
	0xa5, 0xd3, 0x33, 0xf4, 0x16, 0xd0, 0xd5, 0x3d, 0x00, 0xcc, 0x33, 0x42, 0xe7, 0xba, 0x58, 0x8d,
	0x8b, 0xf9, 0x91, 0x7c, 0xc6, 0xdc, 0x44, 0x63, 0xce, 0x0d, 0x6c, 0xc5, 0xf3, 0x93, 0x29, 0x73,
	0x08, 0x03, 0x36, 0x9c, 0x77, 0xf5, 0x1c, 0xe7, 0x55, 0xef, 0xf8, 0x34, 0xf4, 0xd9, 0x60, 0x6a,
	0x0c, 0x9c, 0x63, 0xea, 0x97, 0xfe, 0x51, 0xe9, 0x97, 0x61, 0x51, 0xb2, 0x31, 0xa4, 0x02, 0xc7,
	0xc5, 0xbe, 0x80, 0xe9, 0xd1, 0xd4, 0xeb, 0xbb, 0x83, 0xf1, 0x81, 0xfa, 0xed, 0x19, 0x81, 0x73,
	0x4b, 0x6c, 0xc4, 0x55, 0x54, 0x86, 0x60, 0x70, 0xf8, 0xa6, 0x2d, 0xd2, 0x18, 0x93, 0xb8, 0x9f,
	0x88, 0xcb, 0x6c, 0x54, 0x8a, 0x2c, 0x4d, 0x0a, 0xec, 0x6a, 0x2e, 0x8b, 0x2a, 0x2a, 0x71, 0x44,
	0x6c, 0x57, 0x15, 0x06, 0x52, 0x99, 0xe7, 0x07, 0xc5, 0x1c, 0xed, 0x3f, 0x34, 0x52, 0x85, 0xb9,
	0xbf, 0xdf, 0x11, 0x5b, 0x07, 0xc5, 0xfc, 0x3b, 0x61, 0xb9, 0xb8, 0x9f, 0xfb, 0xcf, 0x3d, 0xf9,
	0xcc, 0xb9, 0x23, 0xd6, 0x83, 0xdd, 0xc0, 0x20, 0xa3, 0xce, 0xcd, 0xee, 0xad, 0xf5, 0x5d, 0x67,
	0xbc, 0xb7, 0xbb, 0xc7, 0x15, 0x3d, 0xaa, 0xe6, 0x7c, 0x5d, 0x6c, 0xce, 0xf3, 0xb4, 0xca, 0xec,
	0x73, 0x2b, 0xf8, 0xdc, 0x95, 0xf1, 0x23, 0x40, 0x1b, 0x4f, 0x72, 0x55, 0xf7, 0xaf, 0x3b, 0x62,
	0x67, 0xa9, 0x79, 0xe7, 0x0b, 0x68, 0xbb, 0xfd, 0x64, 0x96, 0xea, 0x3e, 0xac, 0xeb, 0x3e, 0x00,
	0xe4, 0x19, 0x99, 0x33, 0x16, 0xdb, 0x51, 0x9a, 0xcc, 0xb5, 0x51, 0x70, 0xae, 0xae, 0x10, 0x33,
	0x34, 0x85, 0xce, 0x4d, 0x31, 0xc8, 0x25, 0xba, 0xfa, 0x14, 0xbd, 0xcc, 0x0c, 0xbe, 0x45, 0xc1,
	0x62, 0x45, 0x35, 0xd9, 0x8b, 0xa7, 0xdc, 0xbd, 0x14, 0xe6, 0xfe, 0x4b, 0x47, 0x5c, 0x6e, 0xf9,
	0x26, 0xf2, 0x54, 0x67, 0xf9, 0x29, 0x98, 0x75, 0xf8, 0xcd, 0x38, 0xe5, 0x69, 0xff, 0x6a, 0xd8,
	0xea, 0xec, 0xa5, 0x53, 0x89, 0x5d, 0xeb, 0x32, 0x1d, 0x80, 0x9d, 0x5f, 0x47, 0xa3, 0x7c, 0x04,
	0x4e, 0xd7, 0x43, 0xa3, 0x6c, 0x5a, 0x03, 0x5b, 0xb3, 0x80, 0x14, 0x66, 0x41, 0x55, 0xc8, 0xfc,
	0xbe, 0x9c, 0xe1, 0x2c, 0x30, 0x5f, 0x69, 0x40, 0xf7, 0x0f, 0x3b, 0x62, 0x9b, 0x7d, 0x41, 0x91,
	0x39, 0x1f, 0xb4, 0x8d, 0xfc, 0xe5, 0xa5, 0x91, 0x2f, 0x32, 0x3e, 0xf4, 0xdf, 0x68, 0x1f, 0xfa,
	0xab, 0x2d, 0x43, 0x5f, 0x64, 0xcd, 0xb1, 0x3f, 0x14, 0xce, 0x72, 0xfb, 0xbf, 0x92, 0x4b, 0x7b,
	0xe2, 0x4a, 0xdb, 0x8b, 0x7f, 0xa5, 0x36, 0x33, 0xb1, 0x41, 0xcd, 0x4c, 0x22, 0x50, 0xa7, 0x25,
	0x02, 0xb9, 0x98, 0x6e, 0x21, 0xd8, 0xa4, 0x31, 0x1f, 0x6c, 0x0b, 0xeb, 0x28, 0x85, 0xee, 0xd0,
	0x6d, 0x44, 0x29, 0x00, 0xdd, 0x5f, 0xae, 0x08, 0x51, 0xbb, 0x3b, 0xa8, 0xcf, 0xf2, 0x34, 0x7e,
	0x12, 0x26, 0xf8, 0x46, 0xe3, 0x19, 0x06, 0x74, 0xae, 0x89, 0x7e, 0x99, 0x82, 0x74, 0x85, 0x48,
	0x15, 0x44, 0x3a, 0xdb, 0x6d, 0xe9, 0xac, 0x92, 0x3e, 0x09, 0x95, 0xb7, 0x77, 0x89, 0xf4, 0x49,
	0x38, 0x35, 0xdd, 0x0c, 0x63, 0x89, 0x6e, 0xd4, 0xa5, 0xdd, 0x0c, 0x63, 0xc9, 0x3f, 0x75, 0xb5,
	0xfd, 0x53, 0xaf, 0x8b, 0xd5, 0xec, 0x64, 0xfe, 0xb8, 0x8a, 0x59, 0x12, 0xd5, 0x18, 0xcc, 0xc7,
	0xec, 0x64, 0xbe, 0x9f, 0x4c, 0xe5, 0x0b, 0x16, 0x6a, 0x2d, 0x0a, 0xcf, 0x4f, 0xc3, 0x53, 0xe8,
	0x3f, 0x8d, 0xb3, 0x1a, 0xa3, 0x86, 0x14, 0x2d, 0x86, 0x6c, 0x26, 0xad, 0x2b, 0x17, 0x24, 0x2d,
	0xf7, 0xb7, 0xc5, 0x3a, 0x91, 0x39, 0xaf, 0x8a, 0x6e, 0xb0, 0x1b, 0xe8, 0x5c, 0xd7, 0x83, 0xb9,
	0xe0, 0x01, 0x00, 0xf8, 0x3c, 0xcf, 0x74, 0x4e, 0xeb, 0x8d, 0x1f, 0xe5, 0x99, 0x07, 0x80, 0xf3,
	0x86, 0x58, 0x9d, 0xe7, 0xd9, 0x71, 0x9c, 0xe9, 0x14, 0xb6, 0x06, 0xa2, 0xe3, 0x38, 0xf3, 0x34,
	0xec, 0xbe, 0x29, 0xba, 0x7b, 0xbb, 0x7b, 0xf5, 0x80, 0x75, 0x96, 0x06, 0xcc, 0xfd, 0x92, 0xe8,
	0x3e, 0xca, 0x33, 0x1e, 0x0f, 0x3a, 0xad, 0xf1, 0xc0, 0x7d, 0x28, 0x56, 0x55, 0xfb, 0x60, 0x47,
	0x84, 0x9b, 0x6d, 0x5a, 0xf4, 0xb3, 0x7c, 0xc4, 0xfd, 0x92, 0x58, 0xd3, 0x89, 0x49, 0x1b, 0xd4,
	0x12, 0x41, 0x6a, 0x50, 0x00, 0xdd, 0xbf, 0xed, 0x0a, 0x87, 0xf2, 0xc7, 0x97, 0xca, 0x42, 0xb7,
	0xc4, 0x86, 0xcc, 0xf3, 0x34, 0xd7, 0x4f, 0xb1, 0x49, 0xc6, 0x24, 0x8d, 0xf4, 0xdc, 0x3d, 0x27,
	0x3d, 0x53, 0xba, 0xda, 0xbb, 0x88, 0xae, 0xbe, 0x2f, 0xd6, 0xab, 0x30, 0x39, 0xf4, 0x43, 0x98,
	0xcb, 0xc5, 0xa8, 0x8f, 0xe1, 0x69, 0x7b, 0xfc, 0x44, 0x63, 0xfa, 0x43, 0xa8, 0x0e, 0x18, 0x61,
	0x12, 0x26, 0x53, 0xb0, 0xd6, 0x2a, 0xf5, 0x7b, 0x0d, 0x1a, 0x0e, 0x57, 0xa8, 0x80, 0xbe, 0xd6,
	0xe4, 0x70, 0x0a, 0xd7, 0x1c, 0xee, 0x2e, 0xe3, 0x70, 0x83, 0x06, 0x87, 0x63, 0x52, 0xe7, 0x6d,
	0xb1, 0x19, 0x16, 0x87, 0x7e, 0x5e, 0x86, 0x7e, 0x04, 0xdf, 0x83, 0x2e, 0x3f, 0xd0, 0xea, 0x5c,
	0xd4, 0xe0, 0x7b, 0xa2, 0x9d, 0xef, 0xb9, 0xff, 0xd4, 0x11, 0x3b, 0x87, 0x55, 0xb1, 0xd0, 0x9f,
	0x79, 0xe8, 0x07, 0x27, 0x52, 0x11, 0x13, 0x3d, 0x14, 0x1d, 0x43, 0x4c, 0xb4, 0x1d, 0x8c, 0x00,
	0xfc, 0xa5, 0x38, 0xcd, 0xc3, 0x8c, 0x85, 0x30, 0x05, 0x81, 0x6f, 0x66, 0x55, 0xb1, 0x38, 0x4e,
	0x4f, 0x64, 0xc2, 0x06, 0xa9, 0x86, 0x71, 0x66, 0x87, 0xc9, 0xfc, 0xe1, 0x47, 0x7a, 0x8c, 0xea,
	0x99, 0xad, 0x51, 0xa0, 0x51, 0x73, 0x99, 0xc8, 0xdc, 0x8f, 0x70, 0x20, 0x19, 0x8d, 0x22, 0x02,
	0x20, 0x08, 0x5b, 0x7c, 0xb4, 0xc0, 0xa1, 0x22, 0xbf, 0x28, 0x3d, 0xe9, 0x4f, 0x31, 0x3a, 0x51,
	0xa7, 0x63, 0x12, 0x18, 0xca, 0x4c, 0xca, 0xbc, 0xe9, 0xf8, 0x06, 0x44, 0xfe, 0x55, 0xcc, 0xf7,
	0xd2, 0x38, 0x8b, 0x64, 0xa9, 0x49, 0x41, 0xcd, 0xbf, 0x88, 0xc4, 0x79, 0x4b, 0x0c, 0xb4, 0x6d,
	0x0a, 0x9d, 0x7d, 0x6b, 0xab, 0x59, 0x89, 0x5b, 0x89, 0x35, 0xd3, 0xc9, 0x9b, 0xa2, 0xb7, 0xa0,
	0x4c, 0x59, 0xe3, 0x18, 0x74, 0x50, 0x02, 0x94, 0x57, 0x33, 0xe0, 0x56, 0x7a, 0x6c, 0x84, 0xd0,
	0xd2, 0xe4, 0x3c, 0x5e, 0x8c, 0x12, 0xf7, 0x4f, 0x3b, 0x62, 0x9d, 0xa0, 0xce, 0x17, 0xc4, 0x20,
	0x0f, 0x83, 0xc5, 0xb1, 0x7c, 0x51, 0xea, 0xf7, 0x0f, 0xc7, 0x9e, 0x06, 0x3c, 0x2b, 0x32, 0x4e,
	0x44, 0xfa, 0xc0, 0x9c, 0x48, 0xbf, 0x7e, 0x57, 0xec, 0xc4, 0xc5, 0xfc, 0x41, 0x12, 0xe4, 0x67,
	0x59, 0x69, 0x94, 0xe9, 0xb0, 0x2f, 0x8b, 0xdd, 0xef, 0x77, 0xc4, 0xc0, 0xbc, 0xd0, 0x79, 0x4d,
	0xf4, 0xfc, 0xb2, 0xcc, 0x75, 0x4f, 0xfa, 0xe3, 0xbb, 0x65, 0x99, 0x7b, 0x08, 0x39, 0x9f, 0x17,
	0x7d, 0x19, 0xc9, 0xb8, 0xd0, 0xb4, 0xa1, 0x3f, 0x7e, 0x10, 0xc9, 0xd8, 0x53, 0x98, 0x73, 0x47,
	0x6c, 0x26, 0x69, 0xf9, 0x31, 0x2e, 0xcd, 0x1e, 0x86, 0x91, 0xd4, 0x06, 0xd8, 0x1a, 0x3f, 0xa6,
	0xa8, 0xc7, 0x95, 0x20, 0x38, 0x67, 0x65, 0x89, 0x4e, 0x07, 0xc1, 0xf9, 0xb0, 0x2c, 0x3d, 0x00,
	0xdc, 0xff, 0xe9, 0x8b, 0x1e, 0xb4, 0x0e, 0xdd, 0x29, 0x6b, 0xc3, 0xf4, 0xc7, 0x68, 0x14, 0x84,
	0x40, 0x34, 0xf3, 0x03, 0xa9, 0x87, 0xa3, 0x3f, 0x7e, 0xe8, 0x07, 0xd2, 0x43, 0x08, 0x52, 0x89,
	0x5a, 0x24, 0xee, 0xc7, 0x30, 0x71, 0xcc, 0x58, 0x7c, 0x5c, 0x63, 0x1e, 0x55, 0x70, 0x3e, 0x14,
	0x5b, 0xb6, 0x5f, 0xea, 0x11, 0xd5, 0xa3, 0xed, 0xba, 0xf7, 0xea, 0xa9, 0x86, 0x9a, 0xf3, 0x9e,
	0xd8, 0x2c, 0x73, 0x3f, 0x29, 0xa0, 0xaf, 0x48, 0x80, 0xfb, 0xf8, 0x9c, 0x18, 0x1f, 0x1b, 0xd4,
	0xe3, 0x0a, 0xce, 0x3b, 0x42, 0x04, 0x55, 0x51, 0xa6, 0x31, 0x74, 0x17, 0x63, 0x0c, 0xf2, 0x65,
	0x0b, 0x79, 0x44, 0x0c, 0x93, 0x1f, 0xc6, 0x1f, 0xc8, 0x8e, 0x59, 0x95, 0x78, 0xea, 0xb7, 0x67,
	0x04, 0xce, 0x2d, 0x9d, 0x7c, 0xd0, 0xe8, 0x9b, 0xfa, 0xf5, 0x8f, 0x0c, 0xe2, 0xd5, 0x42, 0xd0,
	0x94, 0x2f, 0xca, 0xdc, 0xc7, 0x8e, 0x5e, 0xd2, 0x9a, 0x0f, 0x0c, 0xe2, 0xd5, 0x42, 0xd0, 0x3c,
	0x0d, 0xa7, 0x32, 0xc5, 0x36, 0x2f, 0x6b, 0xcd, 0x4f, 0x0d, 0xe2, 0xd5, 0x42, 0xe7, 0xeb, 0x62,
	0xc3, 0x4f, 0xd2, 0xc4, 0x70, 0xae, 0xd1, 0x55, 0x54, 0x7e, 0x75, 0x7c, 0x37, 0x49, 0x93, 0xb3,
	0x38, 0xad, 0x0a, 0x25, 0xd1, 0x73, 0x8f, 0xe9, 0xc2, 0x28, 0x7d, 0xf2, 0xc9, 0x77, 0xfc, 0x28,
	0x92, 0x25, 0x3c, 0x3a, 0xd2, 0xa3, 0x44, 0x30, 0x8f, 0x2a, 0xd4, 0xa6, 0x03, 0x63, 0x8e, 0xde,
	0x60, 0xa6, 0x43, 0x53, 0x13, 0xb1, 0xf3, 0xbe, 0xd8, 0x20, 0x81, 0xa9, 0x18, 0x7d, 0x01, 0xd5,
	0x37, 0xc7, 0x8f, 0x08, 0xe8, 0x31, 0x15, 0xc7, 0x15, 0xab, 0x45, 0x1e, 0x40, 0x57, 0xbe, 0xac,
	0x3f, 0xf9, 0x28, 0xad, 0xf2, 0x40, 0x42, 0x47, 0xb4, 0xc4, 0xf9, 0x92, 0x18, 0x44, 0xe1, 0x7c,
	0x51, 0xde, 0xcd, 0xb2, 0xd1, 0x6d, 0xdd, 0xe4, 0x47, 0x1a, 0xc0, 0x3e, 0x58, 0x31, 0x76, 0x37,
	0x8d, 0xe3, 0x34, 0xc1, 0xee, 0x7e, 0x60, 0xba, 0x6b, 0x21, 0x8f, 0x88, 0xdd, 0xdf, 0x15, 0xa2,
	0x96, 0x40, 0xb8, 0x85, 0x25, 0x4e, 0x18, 0x48, 0xcc, 0x5a, 0x34, 0x64, 0x52, 0x01, 0x12, 0xb6,
	0x09, 0x36, 0x4f, 0xe3, 0x81, 0xc6, 0x20, 0x5e, 0x4e, 0xaa, 0x22, 0x4c, 0x64, 0x51, 0x2c, 0xd1,
	0x57, 0x26, 0x71, 0xbf, 0xc6, 0x46, 0xc2, 0x79, 0x5b, 0xac, 0xf9, 0x61, 0x8a, 0xcb, 0x7b, 0x35,
	0xef, 0x2e, 0xd9, 0x41, 0xb9, 0xab, 0x70, 0xcf, 0x28, 0xb8, 0xff, 0xd9, 0x17, 0xdb, 0x0d, 0x21,
	0x04, 0xf2, 0x42, 0xaa, 0x9c, 0x0c, 0xcf, 0xf7, 0x4c, 0x20, 0xd7, 0xa0, 0x73, 0x4b, 0xac, 0xc2,
	0x9f, 0x32, 0xd7, 0x73, 0x97, 0x35, 0x8f, 0xa6, 0xd1, 0x72, 0xe7, 0x5d, 0x58, 0x03, 0x06, 0x32,
	0x3c, 0x95, 0xb9, 0x9e, 0xc5, 0xcb, 0xba, 0x56, 0x03, 0x72, 0xdd, 0xde, 0xc2, 0x4f, 0x12, 0x19,
	0xed, 0x2b, 0x92, 0xbc, 0x63, 0x72, 0x9d, 0x85, 0x21, 0x8c, 0x96, 0x32, 0xce, 0x22, 0xbf, 0x94,
	0xfb, 0xaa, 0xee, 0x60, 0x94, 0x08, 0xae, 0x39, 0x92, 0x4c, 0xa6, 0x48, 0x2a, 0x36, 0x09, 0x47,
	0x92, 0x09, 0xe4, 0x82, 0xf5, 0xb8, 0x98, 0x1f, 0xe6, 0x61, 0x9a, 0x87, 0xe5, 0x19, 0x92, 0x0a,
	0xa3, 0x42, 0x05, 0x60, 0x87, 0x5c, 0x4e, 0xd1, 0xf6, 0x03, 0xf2, 0x22, 0x03, 0xc2, 0x5b, 0x26,
	0x61, 0x14, 0x3d, 0x4e, 0x31, 0xa1, 0xda, 0xe1, 0x53, 0x18, 0x3c, 0xed, 0x57, 0xe5, 0xe2, 0xdb,
	0xf2, 0x8c, 0x51, 0x06, 0x03, 0x2a, 0x27, 0xc1, 0x52, 0x15, 0xbe, 0x61, 0x9d, 0xbc, 0x81, 0x0a,
	0x28, 0xef, 0xde, 0xa0, 0xbd, 0x30, 0xbc, 0xfb, 0x2d, 0x21, 0x64, 0x72, 0x2a, 0xa3, 0x8f, 0x33,
	0xb0, 0xc8, 0x26, 0xb5, 0x48, 0x8d, 0x3b, 0x23, 0xd1, 0x4b, 0xfc, 0x58, 0x62, 0xd1, 0xc3, 0x74,
	0x05, 0x11, 0x60, 0x0f, 0x41, 0x9a, 0xcc, 0xf0, 0x05, 0xdb, 0xe4, 0x69, 0x8b, 0x1a, 0xa2, 0x9a,
	0xa7, 0x31, 0x86, 0x1d, 0xda, 0x03, 0x00, 0xd1, 0x8d, 0x03, 0x74, 0xb7, 0x1d, 0xe6, 0xc6, 0x88,
	0x01, 0xbb, 0x09, 0x71, 0xd1, 0xe1, 0x10, 0xa1, 0x82, 0xb0, 0x72, 0x29, 0xa7, 0x7a, 0x74, 0x31,
	0x52, 0x6d, 0xda, 0xca, 0xa5, 0xc5, 0x9d, 0x91, 0x58, 0x9b, 0xe7, 0x3e, 0x12, 0xee, 0x2b, 0x37,
	0xbb, 0xb7, 0x7a, 0x9e, 0xf9, 0x89, 0xec, 0x68, 0xe2, 0xa9, 0x7a, 0x02, 0xc6, 0xae, 0x9a, 0x1d,
	0x19, 0xd8, 0xfd, 0xe1, 0x2a, 0xf3, 0x70, 0x9c, 0x5a, 0x6f, 0x09, 0x31, 0xf1, 0x83, 0x13, 0x88,
	0xad, 0x89, 0x62, 0x0d, 0xf6, 0xbd, 0x35, 0x0e, 0x36, 0x0b, 0x83, 0x54, 0xb1, 0x19, 0x23, 0x47,
	0x04, 0x19, 0x7e, 0x58, 0xea, 0x2c, 0x39, 0xb4, 0x0c, 0x1f, 0x20, 0xb0, 0x67, 0x51, 0x4d, 0x94,
	0xb8, 0x47, 0xc4, 0x16, 0x05, 0x7b, 0x1a, 0x2e, 0xd2, 0x27, 0x0a, 0x96, 0x83, 0xdc, 0x10, 0x6b,
	0x51, 0x98, 0x9c, 0x3c, 0xc9, 0x23, 0x56, 0x35, 0x33, 0x20, 0x78, 0xce, 0x24, 0xf2, 0x83, 0x93,
	0xa3, 0x32, 0x0f, 0x35, 0x29, 0x36, 0x3a, 0x54, 0x00, 0xe3, 0x92, 0xa4, 0x65, 0x18, 0x70, 0x2e,
	0xac, 0x31, 0x9c, 0x49, 0xd0, 0x9d, 0xbd, 0x34, 0x4a, 0x73, 0xf4, 0x60, 0x6b, 0x83, 0x1a, 0x07,
	0x9e, 0x6c, 0xfa, 0xad, 0x14, 0x05, 0x51, 0xe4, 0x22, 0x67, 0x2c, 0xb6, 0xfd, 0xa0, 0x0c, 0xd3,
	0xa4, 0xb0, 0x73, 0x8b, 0x16, 0x47, 0x9b, 0x42, 0xf8, 0xce, 0xdf, 0xa9, 0xe2, 0xec, 0x89, 0x2e,
	0xda, 0xd9, 0xef, 0xd4, 0x20, 0x8c, 0x6e, 0xe2, 0x97, 0xe1, 0xa9, 0xdc, 0x4f, 0x0b, 0x74, 0x6c,
	0x3b, 0xba, 0x16, 0x86, 0xfe, 0xa9, 0x1f, 0x77, 0x93, 0x69, 0x9e, 0x86, 0x53, 0xe6, 0xe0, 0x5c,
	0x04, 0xef, 0x83, 0xd1, 0x83, 0xf7, 0x6d, 0xd3, 0xf7, 0x69, 0x10, 0x02, 0xae, 0x1e, 0x02, 0xf5,
	0xa9, 0x97, 0xc8, 0xa7, 0x32, 0x89, 0xf3, 0xae, 0xd8, 0xd2, 0xbf, 0xef, 0xcd, 0x95, 0xee, 0x0e,
	0xd1, 0x6d, 0xc8, 0xa0, 0x5d, 0x3f, 0x4c, 0x91, 0x71, 0x7c, 0x24, 0x67, 0x25, 0x9b, 0x08, 0x4c,
	0x02, 0x5f, 0x63, 0x7e, 0x7b, 0x90, 0x87, 0x70, 0x4a, 0xd8, 0xaf, 0x61, 0x22, 0x9c, 0xb7, 0xb3,
	0x52, 0xd1, 0x9d, 0x2b, 0xb4, 0xbe, 0x66, 0xd0, 0x97, 0x9a, 0x1d, 0x7f, 0xd5, 0x11, 0x6b, 0x9a,
	0x93, 0x80, 0xbe, 0x89, 0xa1, 0xef, 0xe3, 0xa4, 0xb0, 0xfa, 0x16, 0x36, 0x55, 0xed, 0x30, 0x80,
	0x60, 0xc3, 0x4a, 0x2e, 0x16, 0x86, 0x9e, 0x61, 0x7d, 0xbd, 0xd8, 0x6f, 0x54, 0xfe, 0x0c, 0x0a,
	0x33, 0x2b, 0xf7, 0x13, 0x5e, 0xf7, 0x43, 0x04, 0x18, 0x65, 0x21, 0x9f, 0xb1, 0x82, 0x32, 0x00,
	0xee, 0x0f, 0x3a, 0x42, 0xd4, 0x54, 0x01, 0x1a, 0x98, 0xca, 0x22, 0x60, 0xbd, 0x44, 0x04, 0x25,
	0x7e, 0xe9, 0xb3, 0x8c, 0x8a, 0x08, 0x74, 0x4b, 0x26, 0x55, 0xbc, 0x94, 0x4b, 0x2d, 0x0a, 0x2f,
	0x07, 0xb2, 0xda, 0x23, 0x8f, 0x02, 0x80, 0x0b, 0x34, 0x8c, 0x14, 0xb4, 0xc2, 0xa7, 0x20, 0xf7,
	0x1f, 0x3a, 0xa2, 0x87, 0xcc, 0x1b, 0x7a, 0xae, 0x89, 0xf7, 0xd0, 0xf6, 0xbc, 0xcc, 0xa1, 0x43,
	0x30, 0x71, 0xd9, 0x4a, 0x1c, 0x11, 0xe8, 0x10, 0x10, 0xf3, 0xaf, 0xc2, 0xaa, 0x92, 0xd9, 0xc9,
	0xa0, 0x46, 0xe3, 0x43, 0xd0, 0xe8, 0x35, 0x35, 0x00, 0x85, 0xb7, 0x4e, 0x1a, 0x9b, 0x10, 0x00,
	0xf0, 0xb1, 0xdf, 0x68, 0x1f, 0xfb, 0x7f, 0x5d, 0x11, 0x3d, 0x58, 0x1f, 0xa8, 0x14, 0x30, 0x95,
	0x87, 0x66, 0x95, 0xda, 0xaf, 0x53, 0x80, 0x42, 0xe1, 0x23, 0x4a, 0x58, 0xfd, 0xd1, 0x11, 0x47,
	0x04, 0x53, 0xad, 0xaa, 0x4a, 0xb1, 0xa2, 0x97, 0xc2, 0xc0, 0x72, 0x01, 0xce, 0x0f, 0x3a, 0xd2,
	0x0a, 0x82, 0x36, 0x8b, 0xf0, 0x7b, 0x92, 0x8d, 0x35, 0x22, 0x58, 0x23, 0x9c, 0xcd, 0x64, 0x50,
	0xb2, 0x4a, 0x97, 0xc6, 0x30, 0x7c, 0x2e, 0xfc, 0xfc, 0x48, 0x96, 0xac, 0x1e, 0x60, 0x40, 0x98,
	0x9c, 0x59, 0x58, 0x06, 0x8b, 0xbb, 0xc9, 0xf4, 0xa1, 0x1f, 0x87, 0xd1, 0x19, 0x2b, 0x77, 0x35,
	0x64, 0xf0, 0xed, 0xb3, 0x34, 0x29, 0x1f, 0x43, 0x72, 0x1c, 0xd2, 0x70, 0x6d, 0x50, 0x08, 0xb7,
	0xba, 0x64, 0x7d, 0x1f, 0x1c, 0x8b, 0x26, 0x73, 0x2a, 0x70, 0xff, 0x79, 0x55, 0x74, 0x0f, 0x4b,
	0x9c, 0x98, 0xb3, 0x30, 0x5a, 0xa6, 0x7e, 0x16, 0xc5, 0x12, 0x76, 0x1e, 0x34, 0x17, 0xca, 0x1a,
	0x33, 0xcf, 0x3f, 0xa9, 0xc2, 0xc6, 0xf4, 0x31, 0x28, 0x16, 0x29, 0xc3, 0x48, 0x1e, 0x4c, 0x3f,
	0x60, 0x5e, 0x61, 0x40, 0xd3, 0x02, 0x7e, 0x53, 0x9f, 0x7d, 0x93, 0x46, 0x8d, 0xc6, 0x11, 0xd8,
	0x7f, 0xb5, 0xd9, 0x47, 0x40, 0x15, 0xf9, 0x51, 0xee, 0x43, 0x13, 0x8c, 0x01, 0xe1, 0x1b, 0x40,
	0xb7, 0xb1, 0x09, 0xa7, 0x31, 0x4c, 0x82, 0xb8, 0xcb, 0xb5, 0x9f, 0xb1, 0x6a, 0x83, 0x45, 0xb1,
	0xfc, 0x84, 0x7f, 0x1f, 0xa6, 0x79, 0xc9, 0x2a, 0x8a, 0x04, 0x07, 0x37, 0x9e, 0xa4, 0x69, 0xf4,
	0xa9, 0x1f, 0x85, 0x53, 0x74, 0x72, 0x53, 0xa2, 0xa9, 0x61, 0x0c, 0x49, 0xe1, 0x3c, 0xf1, 0xcb,
	0x2a, 0x6f, 0xb8, 0xba, 0x85, 0xb1, 0x3f, 0x8b, 0x34, 0x2f, 0x83, 0xaa, 0x64, 0x99, 0xc4, 0xa2,
	0xc6, 0xa6, 0x40, 0xd7, 0xb6, 0x9a, 0x36, 0x05, 0xba, 0xf6, 0xb6, 0xd8, 0x8c, 0xfd, 0x79, 0x18,
	0x1c, 0x96, 0xa5, 0xaa, 0xa1, 0x6e, 0x93, 0x2e, 0x73, 0x11, 0x78, 0xcc, 0x69, 0x1a, 0x06, 0xf2,
	0xe8, 0x39, 0xf8, 0x1a, 0xe6, 0x11, 0xcb, 0xff, 0x89, 0x00, 0x89, 0x53, 0x59, 0x42, 0x3e, 0xe2,
	0xc4, 0x09, 0x31, 0x48, 0x1b, 0x76, 0xf1, 0x07, 0xdd, 0x62, 0x69, 0x83, 0x4a, 0xec, 0xec, 0xbc,
	0xbc, 0x34, 0x3b, 0x6f, 0x8a, 0xc1, 0x34, 0x7d, 0x9e, 0x1c, 0xfa, 0xb9, 0xcf, 0x93, 0x84, 0x41,
	0x71, 0x1c, 0xd3, 0x3c, 0xf6, 0xcb, 0xd1, 0xeb, 0x6c, 0x1c, 0x11, 0xe3, 0x61, 0xe4, 0x46, 0x6b,
	0x18, 0x71, 0x5c, 0xb1, 0x31, 0x39, 0x2b, 0x65, 0x71, 0x88, 0xdd, 0x2e, 0x46, 0x6f, 0xdc, 0xec,
	0xde, 0xda, 0xf0, 0x18, 0x06, 0xdf, 0x02, 0x6f, 0x8c, 0x52, 0x7f, 0x8a, 0x15, 0xa8, 0x9b, 0x74,
	0x2d, 0x43, 0x25, 0xee, 0x73, 0xb1, 0x4e, 0x57, 0xe8, 0x23, 0xd1, 0x9b, 0xc3, 0x44, 0x60, 0x81,
	0x1e, 0x10, 0xe3, 0xc2, 0x87, 0x7e, 0xb9, 0x60, 0xc1, 0xde, 0xa2, 0xb8, 0x0f, 0x1d, 0x4d, 0x3f,
	0x95, 0xf9, 0x91, 0x4c, 0xa6, 0xb6, 0xa8, 0xb1, 0x61, 0xf7, 0xa1, 0x99, 0xcc, 0xfd, 0x93, 0x35,
	0xb1, 0xc5, 0xcb, 0x05, 0xec, 0x15, 0x9d, 0xe6, 0x3c, 0xc2, 0x57, 0x68, 0xaf, 0xf9, 0x48, 0x26,
	0x2c, 0x34, 0x1a, 0x90, 0x7e, 0x37, 0xb6, 0x42, 0xf9, 0x22, 0x93, 0xb4, 0x74, 0xb6, 0x77, 0x7e,
	0x67, 0x91, 0xca, 0xc4, 0x6a, 0x51, 0xc0, 0xf6, 0x5e, 0x35, 0x08, 0xde, 0x9a, 0xe5, 0xf2, 0x34,
	0x94, 0xcf, 0x0b, 0xc5, 0x10, 0x28, 0x91, 0xe4, 0x22, 0xf4, 0xc2, 0x30, 0x80, 0x60, 0xb2, 0xc6,
	0xbc, 0x10, 0x31, 0xf4, 0x80, 0x30, 0xf8, 0xa6, 0x44, 0x3a, 0x42, 0xa7, 0x7a, 0x0d, 0xab, 0x02,
	0x64, 0xf0, 0x9d, 0x70, 0x5a, 0x2e, 0xf8, 0x6c, 0x37, 0x28, 0xe4, 0x81, 0x1c, 0xf9, 0x80, 0xa0,
	0x84, 0x39, 0x37, 0x64, 0x60, 0x06, 0x3e, 0x41, 0x73, 0x18, 0x22, 0xd0, 0x6e, 0xb9, 0xa8, 0xe2,
	0x89, 0x61, 0x88, 0xd6, 0xfe, 0x06, 0x05, 0x8d, 0x34, 0x0f, 0xe7, 0x61, 0xe2, 0x47, 0x38, 0xaf,
	0xed, 0x9b, 0x0d, 0xaa, 0x16, 0x69, 0x73, 0x68, 0x61, 0x8b, 0xee, 0x37, 0x29, 0x0c, 0xec, 0x08,
	0x9a, 0x86, 0x12, 0x5a, 0x2a, 0xae, 0x41, 0x55, 0x9e, 0xfe, 0x1e, 0xda, 0x99, 0xce, 0x62, 0x03,
	0x92, 0x62, 0xfc, 0x4e, 0x4b, 0x31, 0x9e, 0x2d, 0x7d, 0xfa, 0x7c, 0xe9, 0xe3, 0x8a, 0x61, 0x9a,
	0x3d, 0xf4, 0x03, 0x09, 0xb9, 0x9d, 0xd2, 0xbc, 0x1a, 0x46, 0x9d, 0x68, 0x7a, 0xa8, 0x06, 0xe7,
	0x0a, 0x8d, 0x7e, 0x16, 0x46, 0x1a, 0x0f, 0xd6, 0x50, 0xd6, 0xbf, 0x4a, 0xe3, 0x68, 0x8d, 0x43,
	0x44, 0xc2, 0x5f, 0x7a, 0x1c, 0x5f, 0xa5, 0x11, 0x89, 0x08, 0x48, 0x54, 0xff, 0x5c, 0x4b, 0x54,
	0xbf, 0x21, 0xd6, 0x8a, 0x45, 0xfa, 0x1c, 0xbc, 0x7d, 0x44, 0xad, 0xa1, 0x41, 0xdc, 0xad, 0xd7,
	0x3e, 0x0d, 0x3a, 0xaf, 0xb1, 0xdd, 0xfa, 0x5a, 0xc0, 0xa3, 0xca, 0xeb, 0xe7, 0x10, 0xd3, 0xbe,
	0xd8, 0x64, 0xb5, 0xc7, 0x97, 0xc8, 0xab, 0x40, 0xc1, 0xc2, 0x39, 0x8b, 0x06, 0x00, 0xfc, 0x3f,
	0x64, 0xd4, 0x8d, 0x0b, 0x33, 0x6a, 0x77, 0x29, 0xa3, 0xc2, 0x12, 0x3c, 0x2d, 0x79, 0x3a, 0x45,
	0x84, 0x6d, 0x95, 0xb3, 0xad, 0xb9, 0xc6, 0x56, 0x79, 0x10, 0x4f, 0xf9, 0xd6, 0x9c, 0xc2, 0xb0,
	0xb6, 0x1c, 0x06, 0x79, 0xba, 0x17, 0xa5, 0xd5, 0x94, 0xe7, 0xd2, 0x1a, 0x77, 0xde, 0x12, 0x9b,
	0x18, 0x93, 0xc1, 0x98, 0x18, 0xa8, 0xd7, 0x31, 0x50, 0x73, 0x70, 0x29, 0x52, 0x6f, 0x9c, 0x17,
	0xa9, 0xe1, 0xad, 0x53, 0x3f, 0x99, 0xcb, 0xfc, 0xc1, 0xa9, 0x8c, 0x46, 0xbb, 0xf4, 0xad, 0x35,
	0x0e, 0xdf, 0x16, 0x85, 0x33, 0x89, 0x7b, 0x07, 0xb7, 0xe9, 0xb7, 0x19, 0x14, 0xda, 0xa9, 0x32,
	0x68, 0x15, 0x75, 0xee, 0xd0, 0x76, 0x6a, 0x1c, 0x7c, 0xcb, 0x9f, 0x60, 0x37, 0xd1, 0x01, 0x3e,
	0xa0, 0xbe, 0x45, 0x04, 0xd0, 0x5a, 0x10, 0x85, 0x32, 0x29, 0x51, 0xed, 0xab, 0xb4, 0xb5, 0x1a,
	0xc7, 0xa2, 0xc9, 0x8b, 0x2c, 0xcc, 0x55, 0xbf, 0x3e, 0xa4, 0x5a, 0x35, 0xce, 0xfd, 0xf4, 0x37,
	0xda, 0xfd, 0xf4, 0x13, 0x31, 0xb4, 0xc5, 0x62, 0x5c, 0x62, 0x44, 0x32, 0x5e, 0x76, 0x51, 0x83,
	0x42, 0x93, 0xf0, 0xf7, 0xa7, 0x7e, 0x54, 0xf1, 0x03, 0x5d, 0x35, 0xec, 0xfe, 0x4d, 0x57, 0x0c,
	0x6d, 0x5d, 0x17, 0xdd, 0x26, 0x0c, 0x4e, 0x78, 0x06, 0x04, 0xa4, 0xde, 0xb7, 0xf4, 0xf3, 0x29,
	0x6f, 0xcb, 0xc2, 0x10, 0x82, 0x22, 0x09, 0xe3, 0x43, 0xd9, 0xb9, 0x82, 0x40, 0x36, 0xc3, 0xe2,
	0x2a, 0x23, 0xe7, 0x33, 0x5d, 0x4c, 0x55, 0x8d, 0x1c, 0xf8, 0xc5, 0x09, 0x4b, 0x31, 0x35, 0xac,
	0xf7, 0xa4, 0x8f, 0xfd, 0x30, 0xda, 0x9f, 0x2e, 0xed, 0x49, 0x2b, 0x58, 0x55, 0xb9, 0x92, 0xa9,
	0xcc, 0x8f, 0xb1, 0x20, 0xc2, 0x6a, 0x15, 0x44, 0x80, 0x2b, 0x9d, 0x2c, 0x29, 0x8e, 0xc3, 0xac,
	0x60, 0xd5, 0x0a, 0x8b, 0xc2, 0xe4, 0xae, 0xc2, 0x04, 0xfd, 0xdf, 0xcc, 0x2d, 0x00, 0xf4, 0xb6,
	0xd2, 0x51, 0xe9, 0x97, 0xea, 0x50, 0x8a, 0x68, 0x6c, 0x2b, 0x59, 0x09, 0xae, 0xae, 0xb3, 0xa4,
	0x38, 0x82, 0x75, 0x9b, 0xad, 0xb9, 0x59, 0x0a, 0xc7, 0x44, 0xd0, 0x6a, 0x22, 0x9f, 0xab, 0x3a,
	0xfc, 0xd2, 0x34, 0xa0, 0x12, 0xf7, 0xa7, 0x2b, 0x62, 0x68, 0xeb, 0xf5, 0x26, 0x0c, 0x60, 0xad,
	0xad, 0xd3, 0x0c, 0x14, 0x49, 0x33, 0x50, 0xac, 0xb4, 0x06, 0x8a, 0x3a, 0x08, 0xd3, 0x60, 0x45,
	0x82, 0xf0, 0xc4, 0x2f, 0x83, 0x85, 0xae, 0x91, 0xda, 0x50, 0xa5, 0x41, 0x4a, 0x64, 0xfb, 0x6d,
	0x44, 0x76, 0x24, 0x7a, 0xb1, 0x9f, 0x9f, 0x30, 0x46, 0x80, 0x88, 0x22, 0xed, 0xcf, 0x2a, 0x99,
	0x04, 0x6a, 0xa0, 0xba, 0x35, 0x69, 0x57, 0x28, 0x56, 0x9e, 0xf0, 0x35, 0xa5, 0x8c, 0x35, 0xf3,
	0xaf, 0x2b, 0x4f, 0xb5, 0x00, 0xf4, 0x66, 0x52, 0x4e, 0x0f, 0xf4, 0x89, 0x06, 0xb6, 0xdf, 0x48,
	0x04, 0x7c, 0x82, 0x89, 0xf6, 0x09, 0xf6, 0xc7, 0x2b, 0xe2, 0x6a, 0xeb, 0x76, 0x44, 0xed, 0xbf,
	0x9d, 0x65, 0xff, 0xbd, 0x2e, 0x56, 0xfd, 0x04, 0xcf, 0x08, 0xb2, 0xd2, 0xba, 0xc2, 0xd0, 0xdb,
	0x92, 0x34, 0x79, 0x0c, 0xf3, 0x8a, 0xaf, 0xbc, 0x35, 0x0a, 0xe3, 0xbf, 0x90, 0xfe, 0x14, 0x16,
	0x21, 0xb9, 0x1f, 0x96, 0x6c, 0x8a, 0x30, 0x49, 0x23, 0x94, 0xf4, 0xcf, 0x09, 0x25, 0x37, 0xc5,
	0x60, 0x52, 0x4d, 0x26, 0x38, 0xaa, 0x6c, 0xc1, 0x65, 0x50, 0xb0, 0x45, 0xee, 0x27, 0x27, 0xaa,
	0x9c, 0x44, 0xe7, 0x49, 0x0d, 0xbb, 0xff, 0xb6, 0x26, 0x86, 0x76, 0x1f, 0x87, 0xa5, 0xb5, 0xce,
	0x45, 0x69, 0x6d, 0xe5, 0xa2, 0xb4, 0xd6, 0x6d, 0x4d, 0x6b, 0x6f, 0x09, 0x01, 0x7f, 0x3f, 0x54,
	0x4b, 0x04, 0x6a, 0x05, 0x82, 0xdb, 0xd4, 0xdc, 0xb4, 0x80, 0x45, 0x5f, 0x62, 0xc1, 0xc9, 0x89,
	0xcc, 0xda, 0xcb, 0x11, 0x99, 0xc1, 0x79, 0x44, 0xe6, 0x96, 0xd8, 0xc0, 0x9f, 0x0f, 0xf5, 0xe7,
	0xd3, 0x0a, 0x3d, 0x93, 0x60, 0x6a, 0xc5, 0x7d, 0x22, 0xe6, 0x80, 0x1a, 0x83, 0x98, 0x61, 0xb5,
	0xb1, 0xf3, 0x2c, 0x66, 0x30, 0x91, 0x1a, 0xe3, 0x22, 0xb4, 0xa5, 0x7a, 0x32, 0xc6, 0x0a, 0x85,
	0x5e, 0xcd, 0xf2, 0x34, 0xde, 0x5b, 0xf8, 0x2a, 0x3d, 0x51, 0xca, 0xca, 0x24, 0x68, 0x8d, 0xd4,
	0xea, 0x6d, 0x31, 0x6b, 0x58, 0xdc, 0xf9, 0x4d, 0xf1, 0x2a, 0xac, 0x83, 0x8f, 0xaa, 0x2c, 0x4b,
	0xf3, 0xf2, 0x30, 0x4f, 0xe7, 0xb9, 0x2c, 0x8a, 0xf0, 0x54, 0x55, 0xf2, 0x0d, 0x5b, 0x3c, 0x47,
	0x07, 0x3c, 0x0e, 0xac, 0xaf, 0x0c, 0x4e, 0xe9, 0x6d, 0x0d, 0x9b, 0xf1, 0xd7, 0xe6, 0xde, 0x69,
	0x8e, 0xbf, 0xb6, 0x36, 0x44, 0xf9, 0x6a, 0x72, 0xcf, 0x7c, 0xbc, 0xc3, 0x36, 0xbc, 0x6a, 0x01,
	0xbc, 0x11, 0xf7, 0x1e, 0xef, 0x96, 0x65, 0xce, 0x56, 0xab, 0x35, 0xec, 0x8c, 0x85, 0x83, 0x8c,
	0xe4, 0xd8, 0xd8, 0x16, 0xb9, 0xca, 0x15, 0xe4, 0x2a, 0x2d, 0x12, 0xab, 0x6f, 0xe7, 0x05, 0xea,
	0x5f, 0x25, 0xfa, 0x4c, 0xe2, 0xec, 0x8a, 0x1d, 0x1c, 0xb6, 0xfb, 0x94, 0xe5, 0x50, 0x42, 0xbc,
	0x2c, 0x86, 0x67, 0xb0, 0x83, 0xec, 0x19, 0xca, 0x90, 0x97, 0xc5, 0x3c, 0xb6, 0x8d, 0xda, 0x63,
	0xdb, 0x4f, 0x56, 0xc4, 0xd0, 0x6e, 0x52, 0x3a, 0xd7, 0xd4, 0x62, 0xe6, 0x48, 0x3e, 0x2b, 0xf0,
	0x4c, 0x60, 0xdf, 0xb3, 0xbf, 0x55, 0xdd, 0x15, 0xd2, 0x65, 0xb3, 0x6a, 0x54, 0xc3, 0xb6, 0x0c,
	0xd0, 0x5d, 0x2a, 0x03, 0x98, 0x25, 0x16, 0xab, 0xb7, 0xe2, 0x12, 0xcb, 0x1e, 0x0a, 0xe8, 0xb7,
	0x1c, 0x0a, 0x80, 0x06, 0x61, 0x3c, 0x57, 0x59, 0x83, 0x7a, 0x4b, 0xc8, 0xec, 0x6c, 0xf3, 0xea,
	0x50, 0x5d, 0x4a, 0xae, 0x3f, 0x7e, 0xd0, 0x5e, 0x37, 0xb8, 0x6e, 0xf7, 0x6b, 0xd9, 0xf6, 0x99,
	0xde, 0xa9, 0xb5, 0x87, 0xa8, 0xc4, 0xf2, 0x41, 0x3b, 0x57, 0x0c, 0xcb, 0x3c, 0x4d, 0x33, 0x8c,
	0x5b, 0xeb, 0xac, 0x50, 0x6d, 0x60, 0xd7, 0x13, 0x3d, 0xdc, 0x83, 0xb7, 0x6b, 0xb0, 0xce, 0xf2,
	0x1a, 0xec, 0x55, 0xd1, 0x4d, 0x23, 0x9e, 0x21, 0x00, 0x38, 0xaf, 0xa8, 0xea, 0x7e, 0x4b, 0x6c,
	0xd0, 0xcd, 0x62, 0x5b, 0x6b, 0xee, 0xb4, 0xd5, 0x9a, 0x55, 0xb1, 0x3b, 0xe4, 0xcd, 0x5b, 0xd4,
	0xfd, 0xc5, 0xc0, 0x14, 0xb4, 0xb1, 0x9b, 0x2f, 0x5f, 0xe7, 0x58, 0x2e, 0x42, 0xd0, 0xe2, 0x56,
	0x97, 0xed, 0x38, 0x99, 0xe2, 0x16, 0x2c, 0x82, 0xab, 0xd9, 0x4c, 0x9f, 0xf7, 0xaf, 0x77, 0x2a,
	0x11, 0xb3, 0xde, 0xd1, 0x5f, 0x5a, 0x80, 0xc3, 0xf2, 0x38, 0x9a, 0x62, 0xd9, 0x93, 0xed, 0x44,
	0x69, 0x90, 0x30, 0x95, 0xb5, 0x0b, 0x8a, 0x80, 0x83, 0x97, 0x28, 0x02, 0x0e, 0xcf, 0x29, 0x02,
	0xd2, 0x85, 0x9f, 0x68, 0x5d, 0xf8, 0xb1, 0x12, 0xe0, 0x7a, 0x7b, 0x09, 0xf0, 0xba, 0x58, 0xad,
	0x0a, 0x39, 0xab, 0x22, 0x16, 0x9b, 0x35, 0x06, 0x43, 0x1e, 0x4f, 0x3f, 0x60, 0xb5, 0x41, 0x00,
	0x58, 0x09, 0x62, 0xab, 0xb5, 0x04, 0x51, 0x17, 0x18, 0xb6, 0x3f, 0xbb, 0xc0, 0x70, 0xe9, 0x82,
	0x02, 0xc3, 0x4e, 0x5b, 0x81, 0x01, 0x8b, 0xcf, 0x99, 0xf4, 0x75, 0xd1, 0x91, 0x45, 0x56, 0x22,
	0x20, 0x7a, 0x58, 0xee, 0xb9, 0xdc, 0xa2, 0x67, 0xf6, 0x84, 0x42, 0xf8, 0x03, 0xdf, 0x78, 0x85,
	0x46, 0x60, 0x0b, 0xd7, 0x53, 0xe6, 0xea, 0xf2, 0x94, 0xb9, 0x26, 0xfa, 0xcf, 0x31, 0x5f, 0xd0,
	0x88, 0xa9, 0x20, 0xb0, 0xc4, 0x42, 0xe5, 0x09, 0x56, 0x3c, 0x58, 0xd8, 0xd2, 0x82, 0xce, 0xb3,
	0x23, 0xb6, 0x84, 0x55, 0x79, 0xd6, 0x6c, 0x06, 0xbc, 0xd6, 0xb6, 0x19, 0xa0, 0x8a, 0x39, 0xa3,
	0x6b, 0xf4, 0x39, 0x85, 0x35, 0x58, 0xc3, 0xe7, 0x5f, 0x8e, 0x35, 0x5c, 0x3f, 0x8f, 0x35, 0x90,
	0x02, 0xc7, 0xeb, 0x2f, 0x51, 0xe0, 0xb8, 0x71, 0x5e, 0x81, 0xe3, 0x75, 0xb1, 0xf6, 0xf4, 0xce,
	0x7b, 0xef, 0xc1, 0xa8, 0xbf, 0x41, 0x9d, 0x42, 0x61, 0xce, 0x9b, 0x62, 0x08, 0x62, 0xd5, 0x67,
	0x5a, 0x0a, 0x1d, 0x18, 0xd4, 0xf9, 0x35, 0x21, 0x40, 0x45, 0x77, 0xf8, 0x4d, 0x3a, 0x50, 0x16,
	0xe6, 0x51, 0xd6, 0x6d, 0x4f, 0x31, 0x7f, 0xd6, 0x11, 0xeb, 0xe4, 0xa4, 0x1b, 0x39, 0x24, 0xdc,
	0xb9, 0xe0, 0x90, 0xf0, 0xca, 0x05, 0x87, 0x84, 0xbb, 0x2d, 0x87, 0x84, 0x5d, 0x31, 0xf4, 0xab,
	0x32, 0xf5, 0x64, 0x16, 0x9d, 0xb1, 0x6c, 0x53, 0xc3, 0xee, 0x7f, 0x0f, 0xec, 0x01, 0x3a, 0xec,
	0xd1, 0xaf, 0x72, 0xe4, 0xfa, 0x82, 0xd3, 0xdd, 0xd0, 0xdb, 0x60, 0x37, 0x58, 0xba, 0x62, 0xa0,
	0x30, 0x72, 0x60, 0xbb, 0x7f, 0xee, 0xfd, 0x16, 0xe4, 0xb4, 0xab, 0xcd, 0xb6, 0xf5, 0xce, 0x97,
	0x3e, 0xd0, 0xbd, 0xd6, 0x72, 0xa0, 0xfb, 0x6b, 0x62, 0x33, 0xd8, 0x0d, 0x8e, 0xe3, 0xec, 0xa0,
	0x50, 0x07, 0xa2, 0xd5, 0x59, 0x31, 0x3c, 0xe5, 0x7f, 0x2c, 0xe3, 0x8c, 0x1e, 0x51, 0xe4, 0x9a,
	0xf6, 0x48, 0x18, 0x1e, 0xf4, 0x1a, 0xd2, 0x23, 0x61, 0xea, 0xa0, 0x97, 0x15, 0x22, 0x83, 0xcb,
	0xd3, 0xf8, 0x6e, 0x96, 0x85, 0xbc, 0xee, 0x53, 0xc3, 0xc8, 0xe0, 0xf2, 0x34, 0xde, 0x4f, 0x8a,
	0x52, 0xef, 0xa1, 0xd4, 0x0c, 0xce, 0xe2, 0x58, 0x84, 0x29, 0x64, 0x7e, 0x37, 0x28, 0xc3, 0x53,
	0xce, 0x5e, 0x09, 0xee, 0x8c, 0xc5, 0xfa, 0x34, 0x2c, 0x82, 0xaa, 0x28, 0xb0, 0x6f, 0x9b, 0xfa,
	0xc8, 0xd7, 0xfd, 0x1a, 0xf3, 0xa8, 0x02, 0x46, 0xee, 0x3c, 0x8d, 0x71, 0x9d, 0xc5, 0xa2, 0xa7,
	0x41, 0xcd, 0x29, 0x19, 0x18, 0xde, 0x6d, 0x3a, 0xf8, 0x1a, 0xc4, 0x95, 0x5a, 0x55, 0x2e, 0xb0,
	0x05, 0x1a, 0x40, 0x2d, 0x4a, 0x8f, 0x51, 0xef, 0xb4, 0x1c, 0xa3, 0x86, 0x2f, 0x03, 0x5d, 0x4f,
	0xe2, 0xaa, 0xd7, 0x21, 0x6d, 0x10, 0xdc, 0xd6, 0x3b, 0x90, 0x52, 0x5c, 0x26, 0x4a, 0x35, 0xec,
	0x7c, 0x28, 0xb6, 0xe2, 0xaa, 0x0c, 0x23, 0x3c, 0x11, 0x48, 0x0e, 0xb9, 0x6f, 0x8f, 0x0f, 0x00,
	0x3e, 0x36, 0xb0, 0xd7, 0x50, 0x73, 0xde, 0xc1, 0x03, 0x47, 0x60, 0x69, 0xbc, 0xa1, 0x74, 0x55,
	0x9f, 0x12, 0x35, 0x80, 0x47, 0xa5, 0xce, 0x7d, 0x71, 0x2d, 0xab, 0x26, 0x51, 0x18, 0xe8, 0x03,
	0xcb, 0x38, 0xf0, 0x58, 0xf8, 0x6f, 0x12, 0xd5, 0xcf, 0xd0, 0xc3, 0xdb, 0x72, 0x85, 0x7c, 0xb6,
	0x9f, 0xec, 0xed, 0x02, 0x9d, 0xc2, 0xd3, 0xb1, 0x9f, 0x63, 0xb7, 0xe5, 0x1a, 0x52, 0x88, 0xc0,
	0x01, 0xb8, 0xd1, 0x88, 0x0c, 0x03, 0x22, 0xce, 0xd7, 0xc5, 0xb6, 0x7c, 0xa1, 0xda, 0xff, 0xb6,
	0x3c, 0xc3, 0x91, 0x7f, 0x4d, 0x1f, 0xe6, 0x7a, 0xc0, 0x71, 0xaf, 0xa9, 0xe8, 0x7c, 0x55, 0x5c,
	0xc6, 0xab, 0x55, 0x7b, 0x69, 0x9c, 0xf9, 0x65, 0x38, 0x89, 0x24, 0x1e, 0x94, 0xbd, 0x46, 0x2c,
	0xdc, 0xa6, 0x60, 0xfc, 0xe2, 0x48, 0xbe, 0x60, 0x41, 0xdd, 0x80, 0xe0, 0x17, 0x61, 0x71, 0xa4,
	0xe8, 0xe3, 0x75, 0xb2, 0xd6, 0xb1, 0xa8, 0xfb, 0x8f, 0xa6, 0x2e, 0x63, 0x66, 0xca, 0x45, 0x67,
	0xfc, 0x5f, 0xea, 0xee, 0x90, 0xd9, 0x94, 0x83, 0x46, 0x4d, 0x10, 0xec, 0xb2, 0x4d, 0x39, 0x2d,
	0xe1, 0xd5, 0xb9, 0xde, 0x92, 0x47, 0x61, 0x75, 0xce, 0xe8, 0x78, 0x7e, 0x72, 0xc2, 0xe8, 0x57,
	0x0d, 0x83, 0xff, 0xe2, 0x8f, 0x8f, 0xb0, 0x8c, 0x47, 0x23, 0x11, 0xc1, 0x61, 0x9d, 0x6a, 0x9b,
	0x5d, 0x3a, 0x2a, 0xcf, 0x45, 0xdc, 0xd7, 0x07, 0x4b, 0x6f, 0x45, 0xfa, 0xfc, 0xd3, 0x8e, 0x58,
	0x27, 0xd3, 0x1a, 0x8b, 0xbd, 0xea, 0x67, 0x33, 0x4e, 0x13, 0x1c, 0xf3, 0xa3, 0xfa, 0xb5, 0x64,
	0x43, 0x2a, 0x70, 0xde, 0x15, 0x5b, 0x24, 0x4c, 0x34, 0xed, 0xd8, 0x90, 0xc1, 0xb7, 0x69, 0x44,
	0x4f, 0x62, 0x4a, 0x62, 0xb9, 0x88, 0xf4, 0x60, 0xa9, 0x56, 0x4f, 0x05, 0xee, 0xb7, 0xc4, 0x16,
	0x9f, 0xb4, 0xc8, 0x4f, 0x4a, 0xbf, 0xac, 0x8a, 0xc6, 0xbd, 0x32, 0xc4, 0x20, 0x09, 0xc1, 0x24,
	0xe5, 0x67, 0x5e, 0x14, 0x84, 0xb7, 0x38, 0x97, 0xa3, 0x3a, 0x9e, 0x53, 0xd8, 0x0d, 0x96, 0x6a,
	0xc1, 0x06, 0x6c, 0x9e, 0x12, 0x5d, 0x39, 0xef, 0x94, 0x28, 0xbd, 0x70, 0xd2, 0x6d, 0xbd, 0x70,
	0xc2, 0x9c, 0xbb, 0xd7, 0xee, 0xdc, 0x7a, 0x6f, 0xa4, 0xdf, 0xdc, 0x1b, 0x01, 0xca, 0x13, 0xaa,
	0x0c, 0xca, 0xb2, 0x9c, 0x06, 0x4d, 0x8a, 0x39, 0x5c, 0xa4, 0x89, 0x72, 0xaa, 0x21, 0x4d, 0x31,
	0x08, 0x43, 0x1b, 0x65, 0xaa, 0x34, 0x06, 0x94, 0xe4, 0x6a, 0x10, 0xbe, 0x34, 0x4a, 0x83, 0x93,
	0xfb, 0x61, 0x91, 0x45, 0xfe, 0x19, 0x2f, 0x07, 0x12, 0x81, 0x1a, 0xe8, 0x5c, 0xe2, 0x31, 0xb1,
	0xa5, 0x5a, 0x2e, 0x17, 0xb1, 0x3d, 0x93, 0xf5, 0xb6, 0xeb, 0x85, 0xee, 0x0f, 0x3b, 0x62, 0x60,
	0xa3, 0xea, 0x57, 0xc4, 0x26, 0xa6, 0xf5, 0x64, 0x7a, 0x9c, 0x02, 0xa8, 0x2f, 0xdd, 0xa9, 0x20,
	0x8c, 0xa1, 0x8b, 0xcb, 0x9d, 0xf7, 0xc5, 0x56, 0x5c, 0xcc, 0x1f, 0xbc, 0x08, 0xa2, 0x6a, 0x2a,
	0xf1, 0x89, 0x95, 0xe6, 0x13, 0x0d, 0x05, 0x1d, 0xe6, 0x1f, 0xea, 0xa4, 0xaa, 0x0f, 0xbc, 0x12,
	0x7d, 0x2a, 0x75, 0x7f, 0xa0, 0x7b, 0x67, 0xae, 0xb9, 0xf9, 0x19, 0x26, 0x71, 0xe6, 0x7b, 0x0a,
	0x03, 0x69, 0xa8, 0xb2, 0x37, 0xf5, 0x11, 0x8d, 0x21, 0x65, 0x8b, 0xfc, 0x72, 0x96, 0xe6, 0xfc,
	0x08, 0x8e, 0x45, 0x61, 0xb6, 0xc9, 0xa4, 0x8a, 0xef, 0x4b, 0xeb, 0x6b, 0xd4, 0xae, 0x0d, 0x99,
	0xfb, 0x44, 0x6c, 0x37, 0xa2, 0x3a, 0xf8, 0x40, 0x50, 0xe5, 0x07, 0xfe, 0x8b, 0xe6, 0x45, 0xbc,
	0x1a, 0x46, 0x6f, 0xaf, 0xf2, 0x63, 0x73, 0x48, 0xc8, 0x26, 0x72, 0x0d, 0xba, 0x7f, 0xb1, 0x22,
	0xc4, 0x51, 0x7d, 0xaf, 0x08, 0x4f, 0x50, 0xc6, 0xfa, 0x9c, 0x59, 0x4d, 0xea, 0x00, 0x62, 0x87,
	0x8d, 0xba, 0xcd, 0x3a, 0x46, 0xee, 0x27, 0xef, 0xb3, 0x69, 0x80, 0x88, 0x96, 0xec, 0x32, 0xef,
	0x47, 0x04, 0x29, 0x60, 0x9a, 0x14, 0xe5, 0xfb, 0xec, 0x62, 0x9d, 0xc6, 0xac, 0x74, 0x17, 0x9d,
	0x88, 0x4b, 0xeb, 0x67, 0x6f, 0x23, 0x23, 0xe2, 0xd2, 0xdb, 0xe6, 0x6a, 0x0c, 0x7c, 0x15, 0x7e,
	0xf7, 0x26, 0xcd, 0x05, 0x54, 0x62, 0xdb, 0xb9, 0x83, 0x2c, 0x88, 0xb7, 0x73, 0xc7, 0xfd, 0xf7,
	0xae, 0xd8, 0xc0, 0x38, 0xf4, 0x7f, 0x71, 0x09, 0xf1, 0x22, 0x46, 0xac, 0xee, 0xa1, 0x1c, 0x55,
	0x13, 0xac, 0xec, 0xf4, 0x1a, 0x17, 0xaa, 0x34, 0x7e, 0x01, 0x33, 0xae, 0x99, 0xef, 0xea, 0x67,
	0x5f, 0x65, 0x5c, 0x6b, 0xe3, 0xcd, 0xb8, 0x54, 0xf5, 0x23, 0xb3, 0x39, 0x30, 0xe0, 0x4b, 0x55,
	0x2b, 0x00, 0xc7, 0x4e, 0xc2, 0xe0, 0x64, 0xf9, 0x64, 0x96, 0x41, 0xf5, 0x9b, 0x96, 0x4e, 0x65,
	0x19, 0x50, 0x5f, 0xac, 0xda, 0xcf, 0x18, 0xeb, 0x55, 0x50, 0x1b, 0xa9, 0xd9, 0x78, 0x59, 0x52,
	0xd3, 0xb8, 0x4e, 0xb5, 0x73, 0xde, 0x75, 0xaa, 0x5f, 0xf6, 0xc5, 0x06, 0xbd, 0xb0, 0xe0, 0x8c,
	0xc5, 0xb6, 0xaa, 0xf7, 0xdf, 0x0f, 0xcf, 0x80, 0xe6, 0xec, 0xf3, 0x09, 0xdf, 0x14, 0xd6, 0x47,
	0x80, 0x22, 0x7f, 0xfe, 0x58, 0x3e, 0x67, 0xf3, 0x9f, 0x49, 0xcc, 0xee, 0x58, 0xb7, 0xb9, 0x3b,
	0x06, 0xf3, 0x22, 0x6b, 0x6c, 0x15, 0x21, 0x82, 0xd7, 0xb5, 0xf2, 0xec, 0x61, 0x1a, 0x35, 0xae,
	0xef, 0x6b, 0x10, 0xbd, 0x3b, 0x4d, 0xe6, 0xc7, 0xe6, 0x1f, 0x33, 0xac, 0xb2, 0x8b, 0x5f, 0x44,
	0x02, 0x61, 0xdb, 0xfc, 0x56, 0x15, 0x2f, 0x9a, 0x26, 0xb8, 0x88, 0x73, 0xac, 0xc1, 0xb9, 0xf7,
	0xb3, 0xd1, 0x97, 0x97, 0xee, 0xaa, 0xd5, 0x30, 0x5a, 0x26, 0xf2, 0xe3, 0xb4, 0xca, 0x15, 0x2f,
	0x62, 0xbb, 0x7e, 0x54, 0x82, 0xa7, 0xfd, 0x65, 0x3c, 0x91, 0x5a, 0x91, 0xba, 0x02, 0x15, 0x58,
	0x5b, 0x03, 0xe9, 0x02, 0xc7, 0xdf, 0x58, 0x62, 0x76, 0x5a, 0x02, 0x9a, 0x69, 0x74, 0x16, 0x67,
	0x61, 0x70, 0x9c, 0xe6, 0xc1, 0x82, 0x57, 0xf1, 0xa9, 0x04, 0xd8, 0xef, 0xc4, 0x9f, 0x9c, 0x3d,
	0x7b, 0x54, 0x85, 0x53, 0x79, 0x50, 0xcc, 0xf5, 0xd5, 0x44, 0x7a, 0xc0, 0xac, 0x4d, 0x01, 0xfc,
	0xa4, 0x0a, 0x93, 0xdb, 0xbb, 0x0f, 0x5e, 0x64, 0x32, 0x57, 0xe6, 0xa7, 0xc7, 0xcd, 0x9a, 0x42,
	0xdc, 0x97, 0x43, 0xd7, 0x39, 0xaa, 0x26, 0xfb, 0x53, 0x7e, 0xe0, 0x8c, 0x08, 0xb0, 0x60, 0x20,
	0x93, 0xa9, 0x9f, 0x80, 0xe7, 0xed, 0x50, 0xa2, 0x60, 0x61, 0x2c, 0xed, 0x66, 0xfb, 0x4b, 0x27,
	0xf6, 0x0d, 0xc8, 0x8b, 0x0e, 0x97, 0xdb, 0x8b, 0x0e, 0xdf, 0x15, 0x5b, 0x87, 0x93, 0x03, 0xa0,
	0xf5, 0x10, 0xd2, 0x4a, 0xb5, 0x33, 0x6e, 0x77, 0x9a, 0x3a, 0xad, 0x47, 0x12, 0xbf, 0x68, 0x6b,
	0x94, 0x2b, 0xfa, 0xea, 0x59, 0xdd, 0xc4, 0x63, 0xf9, 0xdc, 0x54, 0x2b, 0xdd, 0x77, 0xc4, 0x26,
	0x13, 0x38, 0xd7, 0x44, 0x37, 0x2e, 0xe6, 0x3a, 0xa1, 0xd7, 0x17, 0x05, 0x01, 0x74, 0x7d, 0xe1,
	0xd4, 0xca, 0x18, 0x63, 0xe3, 0xb0, 0xfc, 0xac, 0x27, 0x9c, 0xaf, 0x08, 0x91, 0x4d, 0xa0, 0xcb,
	0x78, 0xf7, 0x7f, 0x45, 0x5f, 0x61, 0xe5, 0x5f, 0xe3, 0x11, 0x15, 0xf7, 0xf7, 0x3a, 0xe2, 0xea,
	0x41, 0x31, 0x37, 0x37, 0xc4, 0x9e, 0x82, 0x05, 0x20, 0x86, 0xde, 0x76, 0x6e, 0x8b, 0xed, 0x59,
	0xe4, 0x17, 0x8b, 0xa7, 0x58, 0x95, 0x7e, 0x9a, 0x85, 0xe6, 0x7a, 0x33, 0xbb, 0x30, 0xb6, 0x89,
	0x3a, 0xc7, 0xa0, 0x72, 0x18, 0x06, 0xce, 0x6d, 0xa1, 0x80, 0xa7, 0xc1, 0x6e, 0x80, 0x8f, 0xac,
	0xb4, 0x5f, 0x65, 0x5b, 0x47, 0xad, 0xbd, 0xdd, 0xe0, 0x30, 0x0c, 0xdc, 0x3f, 0xe8, 0x88, 0x57,
	0x5b, 0xfb, 0x70, 0x9b, 0xd7, 0xbf, 0x37, 0x79, 0x31, 0x6f, 0xa4, 0x6f, 0xe7, 0xb1, 0xb3, 0xd2,
	0x78, 0x39, 0x0f, 0x13, 0x16, 0x2c, 0xc8, 0xf8, 0x16, 0xb4, 0xc2, 0x4c, 0x7d, 0xbc, 0xd7, 0xac,
	0x8f, 0xff, 0x5d, 0x47, 0xec, 0x1c, 0x55, 0x93, 0x03, 0x95, 0x6a, 0xde, 0x7b, 0x71, 0x07, 0x2f,
	0x80, 0x2c, 0x5d, 0x2d, 0xec, 0xbc, 0xcc, 0xd5, 0x42, 0x92, 0x45, 0xe8, 0xfd, 0x0b, 0x9b, 0x45,
	0xee, 0x8b, 0x6b, 0xa9, 0xd5, 0x7e, 0x98, 0xe6, 0x87, 0x69, 0x74, 0x76, 0x9c, 0x7e, 0x3c, 0x9b,
	0x01, 0x86, 0xbd, 0x36, 0x8f, 0x7c, 0x86, 0x9e, 0xfb, 0x5b, 0x62, 0xe0, 0xc9, 0xe2, 0x14, 0x37,
	0x9e, 0x76, 0x85, 0xc0, 0x1a, 0xe8, 0xd3, 0x62, 0x91, 0x3e, 0xc7, 0x18, 0xb6, 0xbe, 0x7b, 0x79,
	0x7c, 0x37, 0x09, 0x63, 0x1f, 0x58, 0x27, 0x9a, 0xfd, 0x68, 0x91, 0x3e, 0xd7, 0xa5, 0x52, 0xf8,
	0xd3, 0x9d, 0x09, 0x67, 0x59, 0xc1, 0x79, 0x53, 0x0c, 0xd5, 0x59, 0xe5, 0xa7, 0x0d, 0x46, 0x37,
	0x50, 0xf0, 0xfe, 0xd4, 0xf9, 0xb2, 0xd8, 0xf6, 0xcd, 0x83, 0x4f, 0x33, 0x3f, 0xf7, 0xf9, 0x1d,
	0xb0, 0x2d, 0x2b, 0x3c, 0x04, 0x99, 0xfb, 0x47, 0xea, 0x62, 0x2e, 0x98, 0xf5, 0x89, 0xfa, 0xc7,
	0x12, 0xb8, 0xc7, 0xae, 0xf8, 0xc0, 0xf2, 0x25, 0x33, 0x22, 0x80, 0xe8, 0x0c, 0x3f, 0x1f, 0xd9,
	0x05, 0x02, 0x25, 0x0d, 0x5c, 0xb4, 0x74, 0x50, 0x6a, 0xd8, 0xdc, 0x51, 0x76, 0xff, 0x7e, 0x45,
	0x6c, 0x3d, 0x92, 0xa5, 0xb9, 0x04, 0xe8, 0xd1, 0x85, 0xae, 0x59, 0x5a, 0xf7, 0x96, 0x57, 0x1f,
	0x37, 0xc5, 0x60, 0x22, 0xe7, 0x61, 0x02, 0x81, 0x75, 0x85, 0xa8, 0x58, 0x14, 0xcf, 0x7c, 0xab,
	0xff, 0xcb, 0xd2, 0x25, 0x72, 0x8d, 0xe9, 0x8d, 0x86, 0x52, 0x6f, 0x60, 0x6c, 0x92, 0x8d, 0x86,
	0x52, 0x5d, 0x1c, 0x53, 0x91, 0xdc, 0x10, 0x16, 0xdb, 0x03, 0x0b, 0x83, 0xb9, 0x54, 0xb9, 0x04,
	0xbb, 0x8e, 0xd9, 0xcc, 0xd4, 0x0c, 0xa8, 0x00, 0xb7, 0x24, 0x16, 0xa1, 0x8c, 0xa6, 0xf6, 0xbf,
	0x11, 0xd9, 0x6b, 0x31, 0x35, 0x0e, 0x01, 0xba, 0xf0, 0x4f, 0xe5, 0x71, 0xee, 0xcf, 0x66, 0xa1,
	0xba, 0x1d, 0x3f, 0x20, 0xaa, 0x4d, 0xa1, 0xfb, 0x8b, 0x8e, 0xd8, 0x66, 0x66, 0x5b, 0xfa, 0x3f,
	0x19, 0x9b, 0xad, 0xff, 0x27, 0x23, 0x6e, 0xf9, 0x3f, 0x19, 0xb1, 0xda, 0x5f, 0xe3, 0xff, 0xc2,
	0xa4, 0xc5, 0xe6, 0xef, 0x8a, 0xad, 0x5c, 0x96, 0x55, 0x9e, 0xdc, 0x33, 0x96, 0xef, 0x11, 0xc5,
	0x86, 0x0c, 0x92, 0x9a, 0x42, 0x1e, 0xa8, 0x51, 0xa0, 0x66, 0x64, 0x12, 0x13, 0x3d, 0x57, 0x5b,
	0xa2, 0xe7, 0xdb, 0x63, 0x31, 0xb0, 0xff, 0xd8, 0x69, 0x28, 0xfa, 0x47, 0xc7, 0x77, 0xbd, 0xe3,
	0x4b, 0xaf, 0x38, 0x9b, 0x62, 0xb8, 0xf7, 0xf1, 0xe3, 0xe3, 0xfd, 0xc7, 0x4f, 0x0e, 0x1e, 0x5c,
	0xea, 0x38, 0x03, 0xd1, 0x3b, 0x3a, 0xfe, 0xf8, 0xf0, 0xd2, 0xca, 0xbd, 0x37, 0x7e, 0xf4, 0xb3,
	0x1b, 0x9d, 0x1f, 0xff, 0xec, 0x46, 0xe7, 0xbf, 0x7e, 0x76, 0xa3, 0xf3, 0xfd, 0x9f, 0xdf, 0x78,
	0xe5, 0xc7, 0x3f, 0xbf, 0xf1, 0xca, 0x4f, 0x7e, 0x7e, 0xe3, 0x95, 0xef, 0xf6, 0xc7, 0xdf, 0x88,
	0x8b, 0xf9, 0xff, 0x06, 0x00, 0x00, 0xff, 0xff, 0x66, 0xd9, 0xfa, 0x96, 0x50, 0x4b, 0x00, 0x00,
}

func (m *GetMessageRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMessageRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetMessageRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ServerBuf != nil {
		i -= len(m.ServerBuf)
		copy(dAtA[i:], m.ServerBuf)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.ServerBuf)))
		i--
		dAtA[i] = 0x62
	}
	if m.MsgCtrlBuf != nil {
		i -= len(m.MsgCtrlBuf)
		copy(dAtA[i:], m.MsgCtrlBuf)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.MsgCtrlBuf)))
		i--
		dAtA[i] = 0x5a
	}
	if m.PubaccountCookie != nil {
		i -= len(m.PubaccountCookie)
		copy(dAtA[i:], m.PubaccountCookie)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.PubaccountCookie)))
		i--
		dAtA[i] = 0x52
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.MsgReqType))
	i--
	dAtA[i] = 0x48
	i = encodeVarintMsg(dAtA, i, uint64(m.WhisperSessionId))
	i--
	dAtA[i] = 0x40
	i = encodeVarintMsg(dAtA, i, uint64(m.ContextFlag))
	i--
	dAtA[i] = 0x38
	i = encodeVarintMsg(dAtA, i, uint64(m.OnlineSyncFlag))
	i--
	dAtA[i] = 0x30
	i = encodeVarintMsg(dAtA, i, uint64(m.OtherRambleNumber))
	i--
	dAtA[i] = 0x28
	i = encodeVarintMsg(dAtA, i, uint64(m.LatestRambleNumber))
	i--
	dAtA[i] = 0x20
	i = encodeVarintMsg(dAtA, i, uint64(m.RambleFlag))
	i--
	dAtA[i] = 0x18
	if m.SyncCookie != nil {
		i -= len(m.SyncCookie)
		copy(dAtA[i:], m.SyncCookie)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.SyncCookie)))
		i--
		dAtA[i] = 0x12
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.SyncFlag))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *SendMessageRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendMessageRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendMessageRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintMsg(dAtA, i, uint64(m.MultiSendSeq))
	i--
	dAtA[i] = 0x70
	if m.MsgCtrl != nil {
		{
			size, err := m.MsgCtrl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.DataStatist))
	i--
	dAtA[i] = 0x48
	i = encodeVarintMsg(dAtA, i, uint64(m.MsgVia))
	i--
	dAtA[i] = 0x40
	if m.SyncCookie != nil {
		i -= len(m.SyncCookie)
		copy(dAtA[i:], m.SyncCookie)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.SyncCookie)))
		i--
		dAtA[i] = 0x32
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.MsgRand))
	i--
	dAtA[i] = 0x28
	i = encodeVarintMsg(dAtA, i, uint64(m.MsgSeq))
	i--
	dAtA[i] = 0x20
	if m.MsgBody != nil {
		{
			size, err := m.MsgBody.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ContentHead != nil {
		{
			size, err := m.ContentHead.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.RoutingHead != nil {
		{
			size, err := m.RoutingHead.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SendMessageResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendMessageResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendMessageResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.ErrMsg)
	copy(dAtA[i:], m.ErrMsg)
	i = encodeVarintMsg(dAtA, i, uint64(len(m.ErrMsg)))
	i--
	dAtA[i] = 0x12
	i = encodeVarintMsg(dAtA, i, uint64(m.Result))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *MsgWithDrawReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgWithDrawReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWithDrawReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GroupWithDraw) > 0 {
		for iNdEx := len(m.GroupWithDraw) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GroupWithDraw[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.C2CWithDraw) > 0 {
		for iNdEx := len(m.C2CWithDraw) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.C2CWithDraw[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *C2CMsgWithDrawReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2CMsgWithDrawReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2CMsgWithDrawReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintMsg(dAtA, i, uint64(m.SubCmd))
	i--
	dAtA[i] = 0x20
	if m.Reserved != nil {
		i -= len(m.Reserved)
		copy(dAtA[i:], m.Reserved)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Reserved)))
		i--
		dAtA[i] = 0x1a
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.LongMessageFlag))
	i--
	dAtA[i] = 0x10
	if len(m.MsgInfo) > 0 {
		for iNdEx := len(m.MsgInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MsgInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GroupMsgWithDrawReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupMsgWithDrawReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupMsgWithDrawReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UserDef != nil {
		i -= len(m.UserDef)
		copy(dAtA[i:], m.UserDef)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.UserDef)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.MsgList) > 0 {
		for iNdEx := len(m.MsgList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MsgList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.GroupCode))
	i--
	dAtA[i] = 0x18
	i = encodeVarintMsg(dAtA, i, uint64(m.GroupType))
	i--
	dAtA[i] = 0x10
	i = encodeVarintMsg(dAtA, i, uint64(m.SubCmd))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *MsgWithDrawResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgWithDrawResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWithDrawResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GroupWithDraw) > 0 {
		for iNdEx := len(m.GroupWithDraw) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GroupWithDraw[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.C2CWithDraw) > 0 {
		for iNdEx := len(m.C2CWithDraw) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.C2CWithDraw[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *C2CMsgWithDrawResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2CMsgWithDrawResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2CMsgWithDrawResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.ErrMsg)
	copy(dAtA[i:], m.ErrMsg)
	i = encodeVarintMsg(dAtA, i, uint64(len(m.ErrMsg)))
	i--
	dAtA[i] = 0x12
	i = encodeVarintMsg(dAtA, i, uint64(m.Result))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *GroupMsgWithDrawResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupMsgWithDrawResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupMsgWithDrawResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.ErrMsg)
	copy(dAtA[i:], m.ErrMsg)
	i = encodeVarintMsg(dAtA, i, uint64(len(m.ErrMsg)))
	i--
	dAtA[i] = 0x12
	i = encodeVarintMsg(dAtA, i, uint64(m.Result))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *GroupMsgInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupMsgInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupMsgInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintMsg(dAtA, i, uint64(m.MsgType))
	i--
	dAtA[i] = 0x18
	i = encodeVarintMsg(dAtA, i, uint64(m.MsgRandom))
	i--
	dAtA[i] = 0x10
	i = encodeVarintMsg(dAtA, i, uint64(m.MsgSeq))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *C2CMsgInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2CMsgInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2CMsgInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RoutingHead != nil {
		{
			size, err := m.RoutingHead.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.MsgType))
	i--
	dAtA[i] = 0x50
	i = encodeVarintMsg(dAtA, i, uint64(m.DivSeq))
	i--
	dAtA[i] = 0x48
	i = encodeVarintMsg(dAtA, i, uint64(m.PkgIndex))
	i--
	dAtA[i] = 0x40
	i = encodeVarintMsg(dAtA, i, uint64(m.PkgNum))
	i--
	dAtA[i] = 0x38
	i = encodeVarintMsg(dAtA, i, uint64(m.MsgRandom))
	i--
	dAtA[i] = 0x30
	i = encodeVarintMsg(dAtA, i, uint64(m.MsgTime))
	i--
	dAtA[i] = 0x28
	i = encodeVarintMsg(dAtA, i, uint64(m.MsgUid))
	i--
	dAtA[i] = 0x20
	i = encodeVarintMsg(dAtA, i, uint64(m.MsgSeq))
	i--
	dAtA[i] = 0x18
	i = encodeVarintMsg(dAtA, i, uint64(m.ToUin))
	i--
	dAtA[i] = 0x10
	i = encodeVarintMsg(dAtA, i, uint64(m.FromUin))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *RoutingHead) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoutingHead) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoutingHead) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GrpTmp != nil {
		{
			size, err := m.GrpTmp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Grp != nil {
		{
			size, err := m.Grp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.C2C != nil {
		{
			size, err := m.C2C.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *C2C) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2C) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2C) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintMsg(dAtA, i, uint64(m.ToUin))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *Grp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Grp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Grp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintMsg(dAtA, i, uint64(m.GroupCode))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *GrpTmp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GrpTmp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GrpTmp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintMsg(dAtA, i, uint64(m.ToUin))
	i--
	dAtA[i] = 0x10
	i = encodeVarintMsg(dAtA, i, uint64(m.GroupUin))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *MsgCtrl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCtrl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCtrl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintMsg(dAtA, i, uint64(m.MsgFlag))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *GetMessageResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMessageResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetMessageResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MsgCtrlBuf != nil {
		i -= len(m.MsgCtrlBuf)
		copy(dAtA[i:], m.MsgCtrlBuf)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.MsgCtrlBuf)))
		i--
		dAtA[i] = 0x52
	}
	i--
	if m.IsPartialSync {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x48
	if m.PubAccountCookie != nil {
		i -= len(m.PubAccountCookie)
		copy(dAtA[i:], m.PubAccountCookie)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.PubAccountCookie)))
		i--
		dAtA[i] = 0x42
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.MsgRspType))
	i--
	dAtA[i] = 0x38
	i = encodeVarintMsg(dAtA, i, uint64(m.BindUin))
	i--
	dAtA[i] = 0x30
	if len(m.UinPairMsgs) > 0 {
		for iNdEx := len(m.UinPairMsgs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UinPairMsgs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.SyncFlag))
	i--
	dAtA[i] = 0x20
	if m.SyncCookie != nil {
		i -= len(m.SyncCookie)
		copy(dAtA[i:], m.SyncCookie)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.SyncCookie)))
		i--
		dAtA[i] = 0x1a
	}
	i -= len(m.ErrorMessage)
	copy(dAtA[i:], m.ErrorMessage)
	i = encodeVarintMsg(dAtA, i, uint64(len(m.ErrorMessage)))
	i--
	dAtA[i] = 0x12
	i = encodeVarintMsg(dAtA, i, uint64(m.Result))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *PushMessagePacket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PushMessagePacket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PushMessagePacket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintMsg(dAtA, i, uint64(m.GeneralFlag))
	i--
	dAtA[i] = 0x48
	i = encodeVarintMsg(dAtA, i, uint64(m.PingFLag))
	i--
	dAtA[i] = 0x20
	if m.PushToken != nil {
		i -= len(m.PushToken)
		copy(dAtA[i:], m.PushToken)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.PushToken)))
		i--
		dAtA[i] = 0x1a
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.Svrip))
	i--
	dAtA[i] = 0x10
	if m.Message != nil {
		{
			size, err := m.Message.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UinPairMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UinPairMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UinPairMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for iNdEx := len(m.Messages) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Messages[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.MsgCompleted))
	i--
	dAtA[i] = 0x18
	i = encodeVarintMsg(dAtA, i, uint64(m.PeerUin))
	i--
	dAtA[i] = 0x10
	i = encodeVarintMsg(dAtA, i, uint64(m.LastReadTime))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Body != nil {
		{
			size, err := m.Body.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Content != nil {
		{
			size, err := m.Content.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Head != nil {
		{
			size, err := m.Head.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MessageBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MsgEncryptContent != nil {
		i -= len(m.MsgEncryptContent)
		copy(dAtA[i:], m.MsgEncryptContent)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.MsgEncryptContent)))
		i--
		dAtA[i] = 0x1a
	}
	if m.MsgContent != nil {
		i -= len(m.MsgContent)
		copy(dAtA[i:], m.MsgContent)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.MsgContent)))
		i--
		dAtA[i] = 0x12
	}
	if m.RichText != nil {
		{
			size, err := m.RichText.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RichText) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RichText) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RichText) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ptt != nil {
		{
			size, err := m.Ptt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.NotOnlineFile != nil {
		{
			size, err := m.NotOnlineFile.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Elems) > 0 {
		for iNdEx := len(m.Elems) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Elems[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Attr != nil {
		{
			size, err := m.Attr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Elem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Elem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Elem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CommonElem != nil {
		{
			size, err := m.CommonElem.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xaa
	}
	if m.LightApp != nil {
		{
			size, err := m.LightApp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	if m.SrcMsg != nil {
		{
			size, err := m.SrcMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xea
	}
	if m.GeneralFlags != nil {
		{
			size, err := m.GeneralFlags.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xaa
	}
	if m.CustomElem != nil {
		{
			size, err := m.CustomElem.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if m.QQWalletMsg != nil {
		{
			size, err := m.QQWalletMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.AnonGroupMsg != nil {
		{
			size, err := m.AnonGroupMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.VideoFile != nil {
		{
			size, err := m.VideoFile.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.ExtraInfo != nil {
		{
			size, err := m.ExtraInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.GroupFile != nil {
		{
			size, err := m.GroupFile.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.RichMsg != nil {
		{
			size, err := m.RichMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.CustomFace != nil {
		{
			size, err := m.CustomFace.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.TransElemInfo != nil {
		{
			size, err := m.TransElemInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.NotOnlineImage != nil {
		{
			size, err := m.NotOnlineImage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.OnlineImage != nil {
		{
			size, err := m.OnlineImage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Face != nil {
		{
			size, err := m.Face.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Text != nil {
		{
			size, err := m.Text.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommonElem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommonElem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommonElem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintMsg(dAtA, i, uint64(m.BusinessType))
	i--
	dAtA[i] = 0x18
	if m.PbElem != nil {
		i -= len(m.PbElem)
		copy(dAtA[i:], m.PbElem)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.PbElem)))
		i--
		dAtA[i] = 0x12
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.ServiceType))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *QQWalletMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QQWalletMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QQWalletMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AioBody != nil {
		{
			size, err := m.AioBody.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QQWalletAioBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QQWalletAioBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QQWalletAioBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PbReserve != nil {
		i -= len(m.PbReserve)
		copy(dAtA[i:], m.PbReserve)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.PbReserve)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.GrapUin) > 0 {
		for iNdEx := len(m.GrapUin) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintMsg(dAtA, i, uint64(m.GrapUin[iNdEx]))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa0
		}
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.RedChannel))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x98
	if m.Index != nil {
		i -= len(m.Index)
		copy(dAtA[i:], m.Index)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Index)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.PcBody != nil {
		i -= len(m.PcBody)
		copy(dAtA[i:], m.PcBody)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.PcBody)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	i = encodeVarintMsg(dAtA, i, uint64((uint32(m.MsgFrom)<<1)^uint32((m.MsgFrom>>31))))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x80
	i = encodeVarintMsg(dAtA, i, uint64((uint32(m.ConfType)<<1)^uint32((m.ConfType>>31))))
	i--
	dAtA[i] = 0x78
	if m.Name != nil {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x72
	}
	i = encodeVarintMsg(dAtA, i, uint64((uint32(m.EnvelOpeId)<<1)^uint32((m.EnvelOpeId>>31))))
	i--
	dAtA[i] = 0x68
	i = encodeVarintMsg(dAtA, i, uint64((uint32(m.MsgType)<<1)^uint32((m.MsgType>>31))))
	i--
	dAtA[i] = 0x60
	i = encodeVarintMsg(dAtA, i, uint64((uint32(m.SessionType)<<1)^uint32((m.SessionType>>31))))
	i--
	dAtA[i] = 0x58
	if m.AuthKey != nil {
		i -= len(m.AuthKey)
		copy(dAtA[i:], m.AuthKey)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.AuthKey)))
		i--
		dAtA[i] = 0x52
	}
	if m.BillNo != nil {
		i -= len(m.BillNo)
		copy(dAtA[i:], m.BillNo)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.BillNo)))
		i--
		dAtA[i] = 0x4a
	}
	i = encodeVarintMsg(dAtA, i, uint64((uint32(m.RedType)<<1)^uint32((m.RedType>>31))))
	i--
	dAtA[i] = 0x40
	i = encodeVarintMsg(dAtA, i, uint64(m.MsgPriority))
	i--
	dAtA[i] = 0x38
	i = encodeVarintMsg(dAtA, i, uint64(m.Resend))
	i--
	dAtA[i] = 0x30
	i = encodeVarintMsg(dAtA, i, uint64((uint32(m.TemplateId)<<1)^uint32((m.TemplateId>>31))))
	i--
	dAtA[i] = 0x28
	i = encodeVarintMsg(dAtA, i, uint64((uint32(m.ChannelId)<<1)^uint32((m.ChannelId>>31))))
	i--
	dAtA[i] = 0x20
	if m.Receiver != nil {
		{
			size, err := m.Receiver.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Sender != nil {
		{
			size, err := m.Sender.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.SendUin))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *QQWalletAioElem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QQWalletAioElem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QQWalletAioElem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PbReserve != nil {
		i -= len(m.PbReserve)
		copy(dAtA[i:], m.PbReserve)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.PbReserve)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.CftImage != nil {
		i -= len(m.CftImage)
		copy(dAtA[i:], m.CftImage)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.CftImage)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.AioImageRight != nil {
		i -= len(m.AioImageRight)
		copy(dAtA[i:], m.AioImageRight)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.AioImageRight)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.AioImageLeft != nil {
		i -= len(m.AioImageLeft)
		copy(dAtA[i:], m.AioImageLeft)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.AioImageLeft)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.ContentBgColor))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x88
	i = encodeVarintMsg(dAtA, i, uint64(m.ContentColor))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x80
	if m.IconUrl != nil {
		i -= len(m.IconUrl)
		copy(dAtA[i:], m.IconUrl)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.IconUrl)))
		i--
		dAtA[i] = 0x7a
	}
	if m.NativeAndroid != nil {
		i -= len(m.NativeAndroid)
		copy(dAtA[i:], m.NativeAndroid)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.NativeAndroid)))
		i--
		dAtA[i] = 0x72
	}
	if m.NativeIos != nil {
		i -= len(m.NativeIos)
		copy(dAtA[i:], m.NativeIos)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.NativeIos)))
		i--
		dAtA[i] = 0x6a
	}
	if m.JumpUrl != nil {
		i -= len(m.JumpUrl)
		copy(dAtA[i:], m.JumpUrl)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.JumpUrl)))
		i--
		dAtA[i] = 0x62
	}
	if m.ActionsPriority != nil {
		i -= len(m.ActionsPriority)
		copy(dAtA[i:], m.ActionsPriority)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.ActionsPriority)))
		i--
		dAtA[i] = 0x5a
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.SubtitleColor))
	i--
	dAtA[i] = 0x50
	i = encodeVarintMsg(dAtA, i, uint64(m.TitleColor))
	i--
	dAtA[i] = 0x48
	if m.Notice != nil {
		i -= len(m.Notice)
		copy(dAtA[i:], m.Notice)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Notice)))
		i--
		dAtA[i] = 0x42
	}
	if m.BlackStripe != nil {
		i -= len(m.BlackStripe)
		copy(dAtA[i:], m.BlackStripe)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.BlackStripe)))
		i--
		dAtA[i] = 0x3a
	}
	if m.LinkUrl != nil {
		i -= len(m.LinkUrl)
		copy(dAtA[i:], m.LinkUrl)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.LinkUrl)))
		i--
		dAtA[i] = 0x32
	}
	i -= len(m.Content)
	copy(dAtA[i:], m.Content)
	i = encodeVarintMsg(dAtA, i, uint64(len(m.Content)))
	i--
	dAtA[i] = 0x2a
	i -= len(m.Subtitle)
	copy(dAtA[i:], m.Subtitle)
	i = encodeVarintMsg(dAtA, i, uint64(len(m.Subtitle)))
	i--
	dAtA[i] = 0x22
	i -= len(m.Title)
	copy(dAtA[i:], m.Title)
	i = encodeVarintMsg(dAtA, i, uint64(len(m.Title)))
	i--
	dAtA[i] = 0x1a
	i = encodeVarintMsg(dAtA, i, uint64(m.Icon))
	i--
	dAtA[i] = 0x10
	i = encodeVarintMsg(dAtA, i, uint64(m.Background))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *RichMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RichMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RichMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintMsg(dAtA, i, uint64(m.Seq))
	i--
	dAtA[i] = 0x28
	i = encodeVarintMsg(dAtA, i, uint64(m.Rand))
	i--
	dAtA[i] = 0x20
	if m.MsgResId != nil {
		i -= len(m.MsgResId)
		copy(dAtA[i:], m.MsgResId)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.MsgResId)))
		i--
		dAtA[i] = 0x1a
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.ServiceId))
	i--
	dAtA[i] = 0x10
	if m.Template1 != nil {
		i -= len(m.Template1)
		copy(dAtA[i:], m.Template1)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Template1)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CustomElem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CustomElem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CustomElem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sound != nil {
		i -= len(m.Sound)
		copy(dAtA[i:], m.Sound)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Sound)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Ext != nil {
		i -= len(m.Ext)
		copy(dAtA[i:], m.Ext)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Ext)))
		i--
		dAtA[i] = 0x22
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.EnumType))
	i--
	dAtA[i] = 0x18
	if m.Data != nil {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if m.Desc != nil {
		i -= len(m.Desc)
		copy(dAtA[i:], m.Desc)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Desc)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Text) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Text) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Text) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PbReserve != nil {
		i -= len(m.PbReserve)
		copy(dAtA[i:], m.PbReserve)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.PbReserve)))
		i--
		dAtA[i] = 0x62
	}
	if m.Buf != nil {
		i -= len(m.Buf)
		copy(dAtA[i:], m.Buf)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Buf)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Attr7Buf != nil {
		i -= len(m.Attr7Buf)
		copy(dAtA[i:], m.Attr7Buf)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Attr7Buf)))
		i--
		dAtA[i] = 0x22
	}
	if m.Attr6Buf != nil {
		i -= len(m.Attr6Buf)
		copy(dAtA[i:], m.Attr6Buf)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Attr6Buf)))
		i--
		dAtA[i] = 0x1a
	}
	i -= len(m.Link)
	copy(dAtA[i:], m.Link)
	i = encodeVarintMsg(dAtA, i, uint64(len(m.Link)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Str)
	copy(dAtA[i:], m.Str)
	i = encodeVarintMsg(dAtA, i, uint64(len(m.Str)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Attr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Attr) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Attr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReserveData != nil {
		i -= len(m.ReserveData)
		copy(dAtA[i:], m.ReserveData)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.ReserveData)))
		i--
		dAtA[i] = 0x52
	}
	i -= len(m.FontName)
	copy(dAtA[i:], m.FontName)
	i = encodeVarintMsg(dAtA, i, uint64(len(m.FontName)))
	i--
	dAtA[i] = 0x4a
	i = encodeVarintMsg(dAtA, i, uint64(m.PitchAndFamily))
	i--
	dAtA[i] = 0x40
	i = encodeVarintMsg(dAtA, i, uint64(m.CharSet))
	i--
	dAtA[i] = 0x38
	i = encodeVarintMsg(dAtA, i, uint64(m.Effect))
	i--
	dAtA[i] = 0x30
	i = encodeVarintMsg(dAtA, i, uint64(m.Size_))
	i--
	dAtA[i] = 0x28
	i = encodeVarintMsg(dAtA, i, uint64(m.Color))
	i--
	dAtA[i] = 0x20
	i = encodeVarintMsg(dAtA, i, uint64(m.Random))
	i--
	dAtA[i] = 0x18
	i = encodeVarintMsg(dAtA, i, uint64(m.Time))
	i--
	dAtA[i] = 0x10
	i = encodeVarintMsg(dAtA, i, uint64(m.CodePage))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *Ptt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ptt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ptt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintMsg(dAtA, i, uint64(m.DownloadFlag))
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0x80
	if len(m.BytesPttUrls) > 0 {
		for iNdEx := len(m.BytesPttUrls) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.BytesPttUrls[iNdEx])
			copy(dAtA[i:], m.BytesPttUrls[iNdEx])
			i = encodeVarintMsg(dAtA, i, uint64(len(m.BytesPttUrls[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xfa
		}
	}
	if m.PbReserve != nil {
		i -= len(m.PbReserve)
		copy(dAtA[i:], m.PbReserve)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.PbReserve)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.Format))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xe8
	if m.DownPara != nil {
		i -= len(m.DownPara)
		copy(dAtA[i:], m.DownPara)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.DownPara)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.Time))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x98
	if m.GroupFileKey != nil {
		i -= len(m.GroupFileKey)
		copy(dAtA[i:], m.GroupFileKey)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.GroupFileKey)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.PttUrl != nil {
		i -= len(m.PttUrl)
		copy(dAtA[i:], m.PttUrl)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.PttUrl)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.VoiceSwitch))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x80
	i = encodeVarintMsg(dAtA, i, uint64(m.MagicPttIndex))
	i--
	dAtA[i] = 0x78
	if m.FileKey != nil {
		i -= len(m.FileKey)
		copy(dAtA[i:], m.FileKey)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.FileKey)))
		i--
		dAtA[i] = 0x72
	}
	if m.Shortcut != nil {
		i -= len(m.Shortcut)
		copy(dAtA[i:], m.Shortcut)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Shortcut)))
		i--
		dAtA[i] = 0x6a
	}
	if m.Signature != nil {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x62
	}
	i--
	if m.BoolValid {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x58
	i = encodeVarintMsg(dAtA, i, uint64(m.ServerPort))
	i--
	dAtA[i] = 0x50
	i = encodeVarintMsg(dAtA, i, uint64(m.ServerIp))
	i--
	dAtA[i] = 0x48
	i = encodeVarintMsg(dAtA, i, uint64(m.FileId))
	i--
	dAtA[i] = 0x40
	if m.Reserve != nil {
		i -= len(m.Reserve)
		copy(dAtA[i:], m.Reserve)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Reserve)))
		i--
		dAtA[i] = 0x3a
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.FileSize))
	i--
	dAtA[i] = 0x30
	i -= len(m.FileName)
	copy(dAtA[i:], m.FileName)
	i = encodeVarintMsg(dAtA, i, uint64(len(m.FileName)))
	i--
	dAtA[i] = 0x2a
	if m.FileMd5 != nil {
		i -= len(m.FileMd5)
		copy(dAtA[i:], m.FileMd5)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.FileMd5)))
		i--
		dAtA[i] = 0x22
	}
	if m.FileUuid != nil {
		i -= len(m.FileUuid)
		copy(dAtA[i:], m.FileUuid)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.FileUuid)))
		i--
		dAtA[i] = 0x1a
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.SrcUin))
	i--
	dAtA[i] = 0x10
	i = encodeVarintMsg(dAtA, i, uint64(m.FileType))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *OnlineImage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OnlineImage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OnlineImage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OldVerSendFile != nil {
		i -= len(m.OldVerSendFile)
		copy(dAtA[i:], m.OldVerSendFile)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.OldVerSendFile)))
		i--
		dAtA[i] = 0x1a
	}
	if m.FilePath != nil {
		i -= len(m.FilePath)
		copy(dAtA[i:], m.FilePath)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.FilePath)))
		i--
		dAtA[i] = 0x12
	}
	if m.Guid != nil {
		i -= len(m.Guid)
		copy(dAtA[i:], m.Guid)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Guid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NotOnlineImage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotOnlineImage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NotOnlineImage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PbReserve != nil {
		i -= len(m.PbReserve)
		copy(dAtA[i:], m.PbReserve)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.PbReserve)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.DownloadLen))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xc8
	i = encodeVarintMsg(dAtA, i, uint64(m.ShowLen))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xc0
	i = encodeVarintMsg(dAtA, i, uint64(m.FileId))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xb8
	i = encodeVarintMsg(dAtA, i, uint64(m.ThumbHeight))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xb0
	i = encodeVarintMsg(dAtA, i, uint64(m.ThumbWidth))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa8
	i--
	if m.OldPicMd5 {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa0
	if m.OpFaceBuf != nil {
		i -= len(m.OpFaceBuf)
		copy(dAtA[i:], m.OpFaceBuf)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.OpFaceBuf)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.Index))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x90
	i = encodeVarintMsg(dAtA, i, uint64(m.Result))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x88
	i = encodeVarintMsg(dAtA, i, uint64(m.BizType))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x80
	i -= len(m.OrigUrl)
	copy(dAtA[i:], m.OrigUrl)
	i = encodeVarintMsg(dAtA, i, uint64(len(m.OrigUrl)))
	i--
	dAtA[i] = 0x7a
	i -= len(m.BigUrl)
	copy(dAtA[i:], m.BigUrl)
	i = encodeVarintMsg(dAtA, i, uint64(len(m.BigUrl)))
	i--
	dAtA[i] = 0x72
	i = encodeVarintMsg(dAtA, i, uint64(m.Original))
	i--
	dAtA[i] = 0x68
	i -= len(m.ThumbUrl)
	copy(dAtA[i:], m.ThumbUrl)
	i = encodeVarintMsg(dAtA, i, uint64(len(m.ThumbUrl)))
	i--
	dAtA[i] = 0x62
	if m.Flag != nil {
		i -= len(m.Flag)
		copy(dAtA[i:], m.Flag)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Flag)))
		i--
		dAtA[i] = 0x5a
	}
	i -= len(m.ResId)
	copy(dAtA[i:], m.ResId)
	i = encodeVarintMsg(dAtA, i, uint64(len(m.ResId)))
	i--
	dAtA[i] = 0x52
	i = encodeVarintMsg(dAtA, i, uint64(m.PicWidth))
	i--
	dAtA[i] = 0x48
	i = encodeVarintMsg(dAtA, i, uint64(m.PicHeight))
	i--
	dAtA[i] = 0x40
	if m.PicMd5 != nil {
		i -= len(m.PicMd5)
		copy(dAtA[i:], m.PicMd5)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.PicMd5)))
		i--
		dAtA[i] = 0x3a
	}
	if m.PreviewsImage != nil {
		i -= len(m.PreviewsImage)
		copy(dAtA[i:], m.PreviewsImage)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.PreviewsImage)))
		i--
		dAtA[i] = 0x32
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.ImgType))
	i--
	dAtA[i] = 0x28
	if m.OldVerSendFile != nil {
		i -= len(m.OldVerSendFile)
		copy(dAtA[i:], m.OldVerSendFile)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.OldVerSendFile)))
		i--
		dAtA[i] = 0x22
	}
	i -= len(m.DownloadPath)
	copy(dAtA[i:], m.DownloadPath)
	i = encodeVarintMsg(dAtA, i, uint64(len(m.DownloadPath)))
	i--
	dAtA[i] = 0x1a
	i = encodeVarintMsg(dAtA, i, uint64(m.FileLen))
	i--
	dAtA[i] = 0x10
	i -= len(m.FilePath)
	copy(dAtA[i:], m.FilePath)
	i = encodeVarintMsg(dAtA, i, uint64(len(m.FilePath)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *NotOnlineFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotOnlineFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NotOnlineFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PbReserve != nil {
		i -= len(m.PbReserve)
		copy(dAtA[i:], m.PbReserve)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.PbReserve)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc2
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.ExpireTime))
	i--
	dAtA[i] = 0x3
	i--
	dAtA[i] = 0xb8
	i = encodeVarintMsg(dAtA, i, uint64(m.ClientType))
	i--
	dAtA[i] = 0x3
	i--
	dAtA[i] = 0xb0
	i = encodeVarintMsg(dAtA, i, uint64(m.AbsFileType))
	i--
	dAtA[i] = 0x3
	i--
	dAtA[i] = 0xa8
	i = encodeVarintMsg(dAtA, i, uint64(m.UploadTime))
	i--
	dAtA[i] = 0x3
	i--
	dAtA[i] = 0xa0
	i = encodeVarintMsg(dAtA, i, uint64(m.LifeTime))
	i--
	dAtA[i] = 0x3
	i--
	dAtA[i] = 0x98
	i = encodeVarintMsg(dAtA, i, uint64(m.DangerEvel))
	i--
	dAtA[i] = 0x3
	i--
	dAtA[i] = 0x90
	i = encodeVarintMsg(dAtA, i, uint64(m.DownloadFlag))
	i--
	dAtA[i] = 0x60
	if len(m.BytesFileUrls) > 0 {
		for iNdEx := len(m.BytesFileUrls) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.BytesFileUrls[iNdEx])
			copy(dAtA[i:], m.BytesFileUrls[iNdEx])
			i = encodeVarintMsg(dAtA, i, uint64(len(m.BytesFileUrls[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.MicroCloud))
	i--
	dAtA[i] = 0x50
	i = encodeVarintMsg(dAtA, i, uint64(m.Subcmd))
	i--
	dAtA[i] = 0x48
	i = encodeVarintMsg(dAtA, i, uint64(m.Reserved))
	i--
	dAtA[i] = 0x40
	if m.Note != nil {
		i -= len(m.Note)
		copy(dAtA[i:], m.Note)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Note)))
		i--
		dAtA[i] = 0x3a
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.FileSize))
	i--
	dAtA[i] = 0x30
	if m.FileName != nil {
		i -= len(m.FileName)
		copy(dAtA[i:], m.FileName)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.FileName)))
		i--
		dAtA[i] = 0x2a
	}
	if m.FileMd5 != nil {
		i -= len(m.FileMd5)
		copy(dAtA[i:], m.FileMd5)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.FileMd5)))
		i--
		dAtA[i] = 0x22
	}
	if m.FileUuid != nil {
		i -= len(m.FileUuid)
		copy(dAtA[i:], m.FileUuid)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.FileUuid)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Sig != nil {
		i -= len(m.Sig)
		copy(dAtA[i:], m.Sig)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Sig)))
		i--
		dAtA[i] = 0x12
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.FileType))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *TransElem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransElem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransElem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ElemValue != nil {
		i -= len(m.ElemValue)
		copy(dAtA[i:], m.ElemValue)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.ElemValue)))
		i--
		dAtA[i] = 0x12
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.ElemType))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *ExtraInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtraInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExtraInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintMsg(dAtA, i, uint64(m.NewGroupFlag))
	i--
	dAtA[i] = 0x60
	i = encodeVarintMsg(dAtA, i, uint64(m.ApnsSoundType))
	i--
	dAtA[i] = 0x58
	i = encodeVarintMsg(dAtA, i, uint64(m.MsgStateFlag))
	i--
	dAtA[i] = 0x50
	i = encodeVarintMsg(dAtA, i, uint64(m.Uin))
	i--
	dAtA[i] = 0x48
	if m.ApnsTips != nil {
		i -= len(m.ApnsTips)
		copy(dAtA[i:], m.ApnsTips)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.ApnsTips)))
		i--
		dAtA[i] = 0x42
	}
	if m.SenderTitle != nil {
		i -= len(m.SenderTitle)
		copy(dAtA[i:], m.SenderTitle)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.SenderTitle)))
		i--
		dAtA[i] = 0x3a
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.MsgTailId))
	i--
	dAtA[i] = 0x30
	i = encodeVarintMsg(dAtA, i, uint64(m.GroupMask))
	i--
	dAtA[i] = 0x28
	i = encodeVarintMsg(dAtA, i, uint64(m.Flags))
	i--
	dAtA[i] = 0x20
	i = encodeVarintMsg(dAtA, i, uint64(m.Level))
	i--
	dAtA[i] = 0x18
	if m.GroupCard != nil {
		i -= len(m.GroupCard)
		copy(dAtA[i:], m.GroupCard)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.GroupCard)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nick != nil {
		i -= len(m.Nick)
		copy(dAtA[i:], m.Nick)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Nick)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GroupFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PbReserve != nil {
		i -= len(m.PbReserve)
		copy(dAtA[i:], m.PbReserve)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.PbReserve)))
		i--
		dAtA[i] = 0x52
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.FeedMsgTime))
	i--
	dAtA[i] = 0x48
	if m.BatchItemId != nil {
		i -= len(m.BatchItemId)
		copy(dAtA[i:], m.BatchItemId)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.BatchItemId)))
		i--
		dAtA[i] = 0x42
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.Sequence))
	i--
	dAtA[i] = 0x38
	if m.Mark != nil {
		i -= len(m.Mark)
		copy(dAtA[i:], m.Mark)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Mark)))
		i--
		dAtA[i] = 0x32
	}
	if m.FileKey != nil {
		i -= len(m.FileKey)
		copy(dAtA[i:], m.FileKey)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.FileKey)))
		i--
		dAtA[i] = 0x2a
	}
	if m.BatchId != nil {
		i -= len(m.BatchId)
		copy(dAtA[i:], m.BatchId)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.BatchId)))
		i--
		dAtA[i] = 0x22
	}
	if m.FileId != nil {
		i -= len(m.FileId)
		copy(dAtA[i:], m.FileId)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.FileId)))
		i--
		dAtA[i] = 0x1a
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.FileSize))
	i--
	dAtA[i] = 0x10
	if m.Filename != nil {
		i -= len(m.Filename)
		copy(dAtA[i:], m.Filename)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Filename)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AnonymousGroupMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnonymousGroupMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AnonymousGroupMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RankColor != nil {
		i -= len(m.RankColor)
		copy(dAtA[i:], m.RankColor)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.RankColor)))
		i--
		dAtA[i] = 0x3a
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.BubbleId))
	i--
	dAtA[i] = 0x30
	i = encodeVarintMsg(dAtA, i, uint64(m.ExpireTime))
	i--
	dAtA[i] = 0x28
	i = encodeVarintMsg(dAtA, i, uint64(m.HeadPortrait))
	i--
	dAtA[i] = 0x20
	if m.AnonNick != nil {
		i -= len(m.AnonNick)
		copy(dAtA[i:], m.AnonNick)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.AnonNick)))
		i--
		dAtA[i] = 0x1a
	}
	if m.AnonId != nil {
		i -= len(m.AnonId)
		copy(dAtA[i:], m.AnonId)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.AnonId)))
		i--
		dAtA[i] = 0x12
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.Flags))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *VideoFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VideoFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PbReserve != nil {
		i -= len(m.PbReserve)
		copy(dAtA[i:], m.PbReserve)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.PbReserve)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.VideoDownloadFlag))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xb8
	i = encodeVarintMsg(dAtA, i, uint64(m.ThumbDownloadFlag))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xb0
	if len(m.BytesVideoFileUrls) > 0 {
		for iNdEx := len(m.BytesVideoFileUrls) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.BytesVideoFileUrls[iNdEx])
			copy(dAtA[i:], m.BytesVideoFileUrls[iNdEx])
			i = encodeVarintMsg(dAtA, i, uint64(len(m.BytesVideoFileUrls[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.BytesThumbFileUrls) > 0 {
		for iNdEx := len(m.BytesThumbFileUrls) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.BytesThumbFileUrls[iNdEx])
			copy(dAtA[i:], m.BytesThumbFileUrls[iNdEx])
			i = encodeVarintMsg(dAtA, i, uint64(len(m.BytesThumbFileUrls[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.VideoAttr))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x98
	i = encodeVarintMsg(dAtA, i, uint64(m.SubBusiType))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x90
	i = encodeVarintMsg(dAtA, i, uint64(m.FileHeight))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x88
	i = encodeVarintMsg(dAtA, i, uint64(m.FileWidth))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x80
	i--
	if m.BoolSupportProgressive {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x78
	i = encodeVarintMsg(dAtA, i, uint64(m.ToChatType))
	i--
	dAtA[i] = 0x70
	i = encodeVarintMsg(dAtA, i, uint64(m.FromChatType))
	i--
	dAtA[i] = 0x68
	i = encodeVarintMsg(dAtA, i, uint64(m.BusiType))
	i--
	dAtA[i] = 0x60
	i = encodeVarintMsg(dAtA, i, uint64(m.ThumbFileSize))
	i--
	dAtA[i] = 0x58
	if m.Source != nil {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0x52
	}
	if m.ThumbFileMd5 != nil {
		i -= len(m.ThumbFileMd5)
		copy(dAtA[i:], m.ThumbFileMd5)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.ThumbFileMd5)))
		i--
		dAtA[i] = 0x4a
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.ThumbHeight))
	i--
	dAtA[i] = 0x40
	i = encodeVarintMsg(dAtA, i, uint64(m.ThumbWidth))
	i--
	dAtA[i] = 0x38
	i = encodeVarintMsg(dAtA, i, uint64(m.FileSize))
	i--
	dAtA[i] = 0x30
	i = encodeVarintMsg(dAtA, i, uint64(m.FileTime))
	i--
	dAtA[i] = 0x28
	i = encodeVarintMsg(dAtA, i, uint64(m.FileFormat))
	i--
	dAtA[i] = 0x20
	if m.FileName != nil {
		i -= len(m.FileName)
		copy(dAtA[i:], m.FileName)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.FileName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.FileMd5 != nil {
		i -= len(m.FileMd5)
		copy(dAtA[i:], m.FileMd5)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.FileMd5)))
		i--
		dAtA[i] = 0x12
	}
	if m.FileUuid != nil {
		i -= len(m.FileUuid)
		copy(dAtA[i:], m.FileUuid)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.FileUuid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SourceMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SourceMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SourceMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TroopName != nil {
		i -= len(m.TroopName)
		copy(dAtA[i:], m.TroopName)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.TroopName)))
		i--
		dAtA[i] = 0x5a
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.ToUin))
	i--
	dAtA[i] = 0x50
	if m.SrcMsg != nil {
		i -= len(m.SrcMsg)
		copy(dAtA[i:], m.SrcMsg)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.SrcMsg)))
		i--
		dAtA[i] = 0x4a
	}
	if m.PbReserve != nil {
		i -= len(m.PbReserve)
		copy(dAtA[i:], m.PbReserve)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.PbReserve)))
		i--
		dAtA[i] = 0x42
	}
	if m.RichMsg != nil {
		i -= len(m.RichMsg)
		copy(dAtA[i:], m.RichMsg)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.RichMsg)))
		i--
		dAtA[i] = 0x3a
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.Type))
	i--
	dAtA[i] = 0x30
	if len(m.Elems) > 0 {
		for iNdEx := len(m.Elems) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Elems[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.Flag))
	i--
	dAtA[i] = 0x20
	i = encodeVarintMsg(dAtA, i, uint64(m.Time))
	i--
	dAtA[i] = 0x18
	i = encodeVarintMsg(dAtA, i, uint64(m.SenderUin))
	i--
	dAtA[i] = 0x10
	if len(m.OrigSeqs) > 0 {
		for iNdEx := len(m.OrigSeqs) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintMsg(dAtA, i, uint64(m.OrigSeqs[iNdEx]))
			i--
			dAtA[i] = 0x8
		}
	}
	return len(dAtA) - i, nil
}

func (m *Face) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Face) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Face) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Buf != nil {
		i -= len(m.Buf)
		copy(dAtA[i:], m.Buf)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Buf)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Old != nil {
		i -= len(m.Old)
		copy(dAtA[i:], m.Old)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Old)))
		i--
		dAtA[i] = 0x12
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.Index))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *LightAppElem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LightAppElem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LightAppElem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MsgResid != nil {
		i -= len(m.MsgResid)
		copy(dAtA[i:], m.MsgResid)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.MsgResid)))
		i--
		dAtA[i] = 0x12
	}
	if m.Data != nil {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CustomFace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CustomFace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CustomFace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PbReserve != nil {
		i -= len(m.PbReserve)
		copy(dAtA[i:], m.PbReserve)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.PbReserve)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.X400Height))
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0x88
	i = encodeVarintMsg(dAtA, i, uint64(m.X400Width))
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0x80
	i -= len(m.X400Url)
	copy(dAtA[i:], m.X400Url)
	i = encodeVarintMsg(dAtA, i, uint64(len(m.X400Url)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xfa
	i = encodeVarintMsg(dAtA, i, uint64(m.DownloadLen))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xf0
	i = encodeVarintMsg(dAtA, i, uint64(m.ShowLen))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xe8
	i = encodeVarintMsg(dAtA, i, uint64(m.ThumbHeight))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xe0
	i = encodeVarintMsg(dAtA, i, uint64(m.ThumbWidth))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xd8
	i = encodeVarintMsg(dAtA, i, uint64(m.Origin))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xd0
	i = encodeVarintMsg(dAtA, i, uint64(m.Size_))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xc8
	i = encodeVarintMsg(dAtA, i, uint64(m.Source))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xc0
	i = encodeVarintMsg(dAtA, i, uint64(m.Height))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xb8
	i = encodeVarintMsg(dAtA, i, uint64(m.Width))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xb0
	i = encodeVarintMsg(dAtA, i, uint64(m.Index))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa8
	i = encodeVarintMsg(dAtA, i, uint64(m.ImageType))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa0
	i = encodeVarintMsg(dAtA, i, uint64(m.RepeatImage))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x98
	i = encodeVarintMsg(dAtA, i, uint64(m.RepeatIndex))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x90
	i = encodeVarintMsg(dAtA, i, uint64(m.BizType))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x88
	i -= len(m.OrigUrl)
	copy(dAtA[i:], m.OrigUrl)
	i = encodeVarintMsg(dAtA, i, uint64(len(m.OrigUrl)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x82
	i -= len(m.BigUrl)
	copy(dAtA[i:], m.BigUrl)
	i = encodeVarintMsg(dAtA, i, uint64(len(m.BigUrl)))
	i--
	dAtA[i] = 0x7a
	i -= len(m.ThumbUrl)
	copy(dAtA[i:], m.ThumbUrl)
	i = encodeVarintMsg(dAtA, i, uint64(len(m.ThumbUrl)))
	i--
	dAtA[i] = 0x72
	if m.Md5 != nil {
		i -= len(m.Md5)
		copy(dAtA[i:], m.Md5)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Md5)))
		i--
		dAtA[i] = 0x6a
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.Useful))
	i--
	dAtA[i] = 0x60
	if m.Signature != nil {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x5a
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.FileType))
	i--
	dAtA[i] = 0x50
	i = encodeVarintMsg(dAtA, i, uint64(m.ServerPort))
	i--
	dAtA[i] = 0x48
	i = encodeVarintMsg(dAtA, i, uint64(m.ServerIp))
	i--
	dAtA[i] = 0x40
	i = encodeVarintMsg(dAtA, i, uint64(m.FileId))
	i--
	dAtA[i] = 0x38
	if m.OldData != nil {
		i -= len(m.OldData)
		copy(dAtA[i:], m.OldData)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.OldData)))
		i--
		dAtA[i] = 0x32
	}
	if m.Flag != nil {
		i -= len(m.Flag)
		copy(dAtA[i:], m.Flag)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Flag)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Buffer != nil {
		i -= len(m.Buffer)
		copy(dAtA[i:], m.Buffer)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Buffer)))
		i--
		dAtA[i] = 0x22
	}
	i -= len(m.Shortcut)
	copy(dAtA[i:], m.Shortcut)
	i = encodeVarintMsg(dAtA, i, uint64(len(m.Shortcut)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.FilePath)
	copy(dAtA[i:], m.FilePath)
	i = encodeVarintMsg(dAtA, i, uint64(len(m.FilePath)))
	i--
	dAtA[i] = 0x12
	if m.Guid != nil {
		i -= len(m.Guid)
		copy(dAtA[i:], m.Guid)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Guid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContentHead) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContentHead) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContentHead) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintMsg(dAtA, i, uint64(m.AutoReply))
	i--
	dAtA[i] = 0x20
	i = encodeVarintMsg(dAtA, i, uint64(m.DivSeq))
	i--
	dAtA[i] = 0x18
	i = encodeVarintMsg(dAtA, i, uint64(m.PkgIndex))
	i--
	dAtA[i] = 0x10
	i = encodeVarintMsg(dAtA, i, uint64(m.PkgNum))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *MessageHead) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageHead) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageHead) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i--
	if m.IsSrcMsg {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xe0
	i = encodeVarintMsg(dAtA, i, uint64(m.AuthSex))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xd8
	i -= len(m.MultiCompatibleText)
	copy(dAtA[i:], m.MultiCompatibleText)
	i = encodeVarintMsg(dAtA, i, uint64(len(m.MultiCompatibleText)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xd2
	if m.ExtGroupKeyInfo != nil {
		{
			size, err := m.ExtGroupKeyInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.Cpid))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xc0
	i = encodeVarintMsg(dAtA, i, uint64(m.WseqInC2CMsghead))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xb8
	i = encodeVarintMsg(dAtA, i, uint64(m.PublicAccountGroupSendFlag))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xb0
	if m.MsgInstCtrl != nil {
		{
			size, err := m.MsgInstCtrl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.MutiltransHead != nil {
		{
			size, err := m.MutiltransHead.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	i -= len(m.GroupName)
	copy(dAtA[i:], m.GroupName)
	i = encodeVarintMsg(dAtA, i, uint64(len(m.GroupName)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x9a
	i -= len(m.AuthRemark)
	copy(dAtA[i:], m.AuthRemark)
	i = encodeVarintMsg(dAtA, i, uint64(len(m.AuthRemark)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x92
	i = encodeVarintMsg(dAtA, i, uint64(m.MsgFlag))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x88
	i -= len(m.AuthNick)
	copy(dAtA[i:], m.AuthNick)
	i = encodeVarintMsg(dAtA, i, uint64(len(m.AuthNick)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x82
	i = encodeVarintMsg(dAtA, i, uint64(m.AuthUin))
	i--
	dAtA[i] = 0x78
	i -= len(m.FromNick)
	copy(dAtA[i:], m.FromNick)
	i = encodeVarintMsg(dAtA, i, uint64(len(m.FromNick)))
	i--
	dAtA[i] = 0x72
	if m.DiscussInfo != nil {
		{
			size, err := m.DiscussInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.UserActive))
	i--
	dAtA[i] = 0x60
	i = encodeVarintMsg(dAtA, i, uint64(m.FromInstid))
	i--
	dAtA[i] = 0x58
	i = encodeVarintMsg(dAtA, i, uint64(m.FromAppid))
	i--
	dAtA[i] = 0x50
	if m.GroupInfo != nil {
		{
			size, err := m.GroupInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.C2CTmpMsgHead != nil {
		{
			size, err := m.C2CTmpMsgHead.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.MsgUid))
	i--
	dAtA[i] = 0x38
	i = encodeVarintMsg(dAtA, i, uint64(m.MsgTime))
	i--
	dAtA[i] = 0x30
	i = encodeVarintMsg(dAtA, i, uint64(m.MsgSeq))
	i--
	dAtA[i] = 0x28
	i = encodeVarintMsg(dAtA, i, uint64(m.C2CCmd))
	i--
	dAtA[i] = 0x20
	i = encodeVarintMsg(dAtA, i, uint64(m.MsgType))
	i--
	dAtA[i] = 0x18
	i = encodeVarintMsg(dAtA, i, uint64(m.ToUin))
	i--
	dAtA[i] = 0x10
	i = encodeVarintMsg(dAtA, i, uint64(m.FromUin))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *GroupInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GroupName != nil {
		i -= len(m.GroupName)
		copy(dAtA[i:], m.GroupName)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.GroupName)))
		i--
		dAtA[i] = 0x42
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.GroupCardType))
	i--
	dAtA[i] = 0x38
	i = encodeVarintMsg(dAtA, i, uint64(m.GroupLevel))
	i--
	dAtA[i] = 0x30
	if m.GroupRank != nil {
		i -= len(m.GroupRank)
		copy(dAtA[i:], m.GroupRank)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.GroupRank)))
		i--
		dAtA[i] = 0x2a
	}
	i -= len(m.GroupCard)
	copy(dAtA[i:], m.GroupCard)
	i = encodeVarintMsg(dAtA, i, uint64(len(m.GroupCard)))
	i--
	dAtA[i] = 0x22
	i = encodeVarintMsg(dAtA, i, uint64(m.GroupInfoSeq))
	i--
	dAtA[i] = 0x18
	i = encodeVarintMsg(dAtA, i, uint64(m.GroupType))
	i--
	dAtA[i] = 0x10
	i = encodeVarintMsg(dAtA, i, uint64(m.GroupCode))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *DiscussInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiscussInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiscussInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DiscussName != nil {
		i -= len(m.DiscussName)
		copy(dAtA[i:], m.DiscussName)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.DiscussName)))
		i--
		dAtA[i] = 0x2a
	}
	if m.DiscussRemark != nil {
		i -= len(m.DiscussRemark)
		copy(dAtA[i:], m.DiscussRemark)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.DiscussRemark)))
		i--
		dAtA[i] = 0x22
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.DiscussInfoSeq))
	i--
	dAtA[i] = 0x18
	i = encodeVarintMsg(dAtA, i, uint64(m.DiscussType))
	i--
	dAtA[i] = 0x10
	i = encodeVarintMsg(dAtA, i, uint64(m.DiscussUin))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *MutilTransHead) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MutilTransHead) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MutilTransHead) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintMsg(dAtA, i, uint64(m.MsgId))
	i--
	dAtA[i] = 0x10
	i = encodeVarintMsg(dAtA, i, uint64(m.Status))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *C2CTempMessageHead) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2CTempMessageHead) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2CTempMessageHead) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Reserved != nil {
		i -= len(m.Reserved)
		copy(dAtA[i:], m.Reserved)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Reserved)))
		i--
		dAtA[i] = 0x5a
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.DirectionFlag))
	i--
	dAtA[i] = 0x50
	i = encodeVarintMsg(dAtA, i, uint64(m.LockDisplay))
	i--
	dAtA[i] = 0x48
	i -= len(m.ToPhone)
	copy(dAtA[i:], m.ToPhone)
	i = encodeVarintMsg(dAtA, i, uint64(len(m.ToPhone)))
	i--
	dAtA[i] = 0x42
	i -= len(m.FromPhone)
	copy(dAtA[i:], m.FromPhone)
	i = encodeVarintMsg(dAtA, i, uint64(len(m.FromPhone)))
	i--
	dAtA[i] = 0x3a
	i = encodeVarintMsg(dAtA, i, uint64(m.SigType))
	i--
	dAtA[i] = 0x30
	if m.Sig != nil {
		i -= len(m.Sig)
		copy(dAtA[i:], m.Sig)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Sig)))
		i--
		dAtA[i] = 0x2a
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.GroupCode))
	i--
	dAtA[i] = 0x20
	i = encodeVarintMsg(dAtA, i, uint64(m.GroupUin))
	i--
	dAtA[i] = 0x18
	i = encodeVarintMsg(dAtA, i, uint64(m.ServiceType))
	i--
	dAtA[i] = 0x10
	i = encodeVarintMsg(dAtA, i, uint64(m.C2CType))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *InstCtrl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstCtrl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InstCtrl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MsgFromInst != nil {
		{
			size, err := m.MsgFromInst.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MsgExcludeInst) > 0 {
		for iNdEx := len(m.MsgExcludeInst) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MsgExcludeInst[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.MsgSendToInst) > 0 {
		for iNdEx := len(m.MsgSendToInst) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MsgSendToInst[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *InstInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InstInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintMsg(dAtA, i, uint64(m.EnumDeviceType))
	i--
	dAtA[i] = 0x50
	i = encodeVarintMsg(dAtA, i, uint64(m.Platform))
	i--
	dAtA[i] = 0x18
	i = encodeVarintMsg(dAtA, i, uint64(m.Instid))
	i--
	dAtA[i] = 0x10
	i = encodeVarintMsg(dAtA, i, uint64(m.Apppid))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *ExtGroupKeyInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtGroupKeyInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExtGroupKeyInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintMsg(dAtA, i, uint64(m.CurTime))
	i--
	dAtA[i] = 0x10
	i = encodeVarintMsg(dAtA, i, uint64(m.CurMaxSeq))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *SyncCookie) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncCookie) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncCookie) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintMsg(dAtA, i, uint64(m.Const4))
	i--
	dAtA[i] = 0x70
	i = encodeVarintMsg(dAtA, i, uint64(m.LastSyncTime))
	i--
	dAtA[i] = 0x68
	i = encodeVarintMsg(dAtA, i, uint64(m.Const3))
	i--
	dAtA[i] = 0x60
	i = encodeVarintMsg(dAtA, i, uint64(m.Const2))
	i--
	dAtA[i] = 0x58
	i = encodeVarintMsg(dAtA, i, uint64(m.Const1))
	i--
	dAtA[i] = 0x28
	i = encodeVarintMsg(dAtA, i, uint64(m.Ran2))
	i--
	dAtA[i] = 0x20
	i = encodeVarintMsg(dAtA, i, uint64(m.Ran1))
	i--
	dAtA[i] = 0x18
	i = encodeVarintMsg(dAtA, i, uint64(m.Time))
	i--
	dAtA[i] = 0x10
	i = encodeVarintMsg(dAtA, i, uint64(m.Time1))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *TransMsgInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransMsgInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransMsgInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintMsg(dAtA, i, uint64(m.GeneralFlag))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x88
	if m.ExtGroupKeyInfo != nil {
		{
			size, err := m.ExtGroupKeyInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.SvrIp))
	i--
	dAtA[i] = 0x58
	if m.MsgData != nil {
		i -= len(m.MsgData)
		copy(dAtA[i:], m.MsgData)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.MsgData)))
		i--
		dAtA[i] = 0x52
	}
	i -= len(m.NickName)
	copy(dAtA[i:], m.NickName)
	i = encodeVarintMsg(dAtA, i, uint64(len(m.NickName)))
	i--
	dAtA[i] = 0x4a
	i = encodeVarintMsg(dAtA, i, uint64(m.RealMsgTime))
	i--
	dAtA[i] = 0x40
	i = encodeVarintMsg(dAtA, i, uint64(m.MsgTime))
	i--
	dAtA[i] = 0x38
	i = encodeVarintMsg(dAtA, i, uint64(m.MsgUid))
	i--
	dAtA[i] = 0x30
	i = encodeVarintMsg(dAtA, i, uint64(m.MsgSeq))
	i--
	dAtA[i] = 0x28
	i = encodeVarintMsg(dAtA, i, uint64(m.MsgSubtype))
	i--
	dAtA[i] = 0x20
	i = encodeVarintMsg(dAtA, i, uint64(m.MsgType))
	i--
	dAtA[i] = 0x18
	i = encodeVarintMsg(dAtA, i, uint64(m.ToUin))
	i--
	dAtA[i] = 0x10
	i = encodeVarintMsg(dAtA, i, uint64(m.FromUin))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *GeneralFlags) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GeneralFlags) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GeneralFlags) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PbReserve != nil {
		i -= len(m.PbReserve)
		copy(dAtA[i:], m.PbReserve)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.PbReserve)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.RpIndex != nil {
		i -= len(m.RpIndex)
		copy(dAtA[i:], m.RpIndex)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.RpIndex)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.PendantId))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x88
	i = encodeVarintMsg(dAtA, i, uint64(m.BubbleSubId))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x80
	i = encodeVarintMsg(dAtA, i, uint64(m.Uin32ExpertFlag))
	i--
	dAtA[i] = 0x78
	if m.BabyqGuideMsgCookie != nil {
		i -= len(m.BabyqGuideMsgCookie)
		copy(dAtA[i:], m.BabyqGuideMsgCookie)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.BabyqGuideMsgCookie)))
		i--
		dAtA[i] = 0x72
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.OlympicTorch))
	i--
	dAtA[i] = 0x68
	i = encodeVarintMsg(dAtA, i, uint64(m.GroupRankSeq))
	i--
	dAtA[i] = 0x60
	i = encodeVarintMsg(dAtA, i, uint64(m.MemberLevel))
	i--
	dAtA[i] = 0x58
	i = encodeVarintMsg(dAtA, i, uint64(m.GlamourLevel))
	i--
	dAtA[i] = 0x50
	i = encodeVarintMsg(dAtA, i, uint64(m.ToUinFlag))
	i--
	dAtA[i] = 0x48
	i = encodeVarintMsg(dAtA, i, uint64(m.GroupType))
	i--
	dAtA[i] = 0x40
	i -= len(m.LongTextResid)
	copy(dAtA[i:], m.LongTextResid)
	i = encodeVarintMsg(dAtA, i, uint64(len(m.LongTextResid)))
	i--
	dAtA[i] = 0x3a
	i = encodeVarintMsg(dAtA, i, uint64(m.LongTextFlag))
	i--
	dAtA[i] = 0x30
	i = encodeVarintMsg(dAtA, i, uint64(m.PrpFold))
	i--
	dAtA[i] = 0x28
	if m.RpId != nil {
		i -= len(m.RpId)
		copy(dAtA[i:], m.RpId)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.RpId)))
		i--
		dAtA[i] = 0x22
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.Uin))
	i--
	dAtA[i] = 0x18
	i = encodeVarintMsg(dAtA, i, uint64(m.GroupFlagNew))
	i--
	dAtA[i] = 0x10
	i = encodeVarintMsg(dAtA, i, uint64(m.BubbleDiyTextId))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *PbMultiMsgItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PbMultiMsgItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PbMultiMsgItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Buffer != nil {
		{
			size, err := m.Buffer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	i -= len(m.FileName)
	copy(dAtA[i:], m.FileName)
	i = encodeVarintMsg(dAtA, i, uint64(len(m.FileName)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PbMultiMsgNew) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PbMultiMsgNew) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PbMultiMsgNew) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		for iNdEx := len(m.Msg) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Msg[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PbMultiMsgTransmit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PbMultiMsgTransmit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PbMultiMsgTransmit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PbItemList) > 0 {
		for iNdEx := len(m.PbItemList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PbItemList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Msg) > 0 {
		for iNdEx := len(m.Msg) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Msg[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MsgElemInfoServtype3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgElemInfoServtype3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgElemInfoServtype3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FlashC2CPic != nil {
		{
			size, err := m.FlashC2CPic.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.FlashTroopPic != nil {
		{
			size, err := m.FlashTroopPic.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgElemInfoServtype33) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgElemInfoServtype33) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgElemInfoServtype33) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Buf != nil {
		i -= len(m.Buf)
		copy(dAtA[i:], m.Buf)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Buf)))
		i--
		dAtA[i] = 0x22
	}
	if m.Compat != nil {
		i -= len(m.Compat)
		copy(dAtA[i:], m.Compat)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Compat)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Text != nil {
		i -= len(m.Text)
		copy(dAtA[i:], m.Text)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Text)))
		i--
		dAtA[i] = 0x12
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.Index))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *SubMsgType0X4Body) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubMsgType0X4Body) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubMsgType0X4Body) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintMsg(dAtA, i, uint64(m.OnlineFileForPolyToOffline))
	i--
	dAtA[i] = 0x18
	i = encodeVarintMsg(dAtA, i, uint64(m.MsgTime))
	i--
	dAtA[i] = 0x10
	if m.NotOnlineFile != nil {
		{
			size, err := m.NotOnlineFile.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResvAttr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResvAttr) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResvAttr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ImageShow != nil {
		{
			size, err := m.ImageShow.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}

func (m *AnimationImageShow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnimationImageShow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AnimationImageShow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AnimationParam != nil {
		i -= len(m.AnimationParam)
		copy(dAtA[i:], m.AnimationParam)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.AnimationParam)))
		i--
		dAtA[i] = 0x12
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.EffectId))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *UinTypeUserDef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UinTypeUserDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UinTypeUserDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.FileUuid)
	copy(dAtA[i:], m.FileUuid)
	i = encodeVarintMsg(dAtA, i, uint64(len(m.FileUuid)))
	i--
	dAtA[i] = 0x1a
	i = encodeVarintMsg(dAtA, i, uint64(m.FromGroupCode))
	i--
	dAtA[i] = 0x10
	i = encodeVarintMsg(dAtA, i, uint64(m.FromUinType))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *GetGroupMsgReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetGroupMsgReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetGroupMsgReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintMsg(dAtA, i, uint64(m.SaveTrafficFlag))
	i--
	dAtA[i] = 0x40
	i = encodeVarintMsg(dAtA, i, uint64(m.ShieldFlag))
	i--
	dAtA[i] = 0x38
	i--
	if m.PublicGroup {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x30
	i = encodeVarintMsg(dAtA, i, uint64(m.MemberSeq))
	i--
	dAtA[i] = 0x28
	i = encodeVarintMsg(dAtA, i, uint64(m.Filter))
	i--
	dAtA[i] = 0x20
	i = encodeVarintMsg(dAtA, i, uint64(m.EndSeq))
	i--
	dAtA[i] = 0x18
	i = encodeVarintMsg(dAtA, i, uint64(m.BeginSeq))
	i--
	dAtA[i] = 0x10
	i = encodeVarintMsg(dAtA, i, uint64(m.GroupCode))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *GetGroupMsgResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetGroupMsgResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetGroupMsgResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		for iNdEx := len(m.Msg) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Msg[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	i = encodeVarintMsg(dAtA, i, uint64(m.ReturnEndSeq))
	i--
	dAtA[i] = 0x28
	i = encodeVarintMsg(dAtA, i, uint64(m.ReturnBeginSeq))
	i--
	dAtA[i] = 0x20
	i = encodeVarintMsg(dAtA, i, uint64(m.GroupCode))
	i--
	dAtA[i] = 0x18
	i -= len(m.Errmsg)
	copy(dAtA[i:], m.Errmsg)
	i = encodeVarintMsg(dAtA, i, uint64(len(m.Errmsg)))
	i--
	dAtA[i] = 0x12
	i = encodeVarintMsg(dAtA, i, uint64(m.Result))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func encodeVarintMsg(dAtA []byte, offset int, v uint64) int {
	offset -= sovMsg(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GetMessageRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMsg(uint64(m.SyncFlag))
	if m.SyncCookie != nil {
		l = len(m.SyncCookie)
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 1 + sovMsg(uint64(m.RambleFlag))
	n += 1 + sovMsg(uint64(m.LatestRambleNumber))
	n += 1 + sovMsg(uint64(m.OtherRambleNumber))
	n += 1 + sovMsg(uint64(m.OnlineSyncFlag))
	n += 1 + sovMsg(uint64(m.ContextFlag))
	n += 1 + sovMsg(uint64(m.WhisperSessionId))
	n += 1 + sovMsg(uint64(m.MsgReqType))
	if m.PubaccountCookie != nil {
		l = len(m.PubaccountCookie)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.MsgCtrlBuf != nil {
		l = len(m.MsgCtrlBuf)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.ServerBuf != nil {
		l = len(m.ServerBuf)
		n += 1 + l + sovMsg(uint64(l))
	}
	return n
}

func (m *SendMessageRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoutingHead != nil {
		l = m.RoutingHead.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.ContentHead != nil {
		l = m.ContentHead.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.MsgBody != nil {
		l = m.MsgBody.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 1 + sovMsg(uint64(m.MsgSeq))
	n += 1 + sovMsg(uint64(m.MsgRand))
	if m.SyncCookie != nil {
		l = len(m.SyncCookie)
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 1 + sovMsg(uint64(m.MsgVia))
	n += 1 + sovMsg(uint64(m.DataStatist))
	if m.MsgCtrl != nil {
		l = m.MsgCtrl.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 1 + sovMsg(uint64(m.MultiSendSeq))
	return n
}

func (m *SendMessageResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMsg(uint64(m.Result))
	l = len(m.ErrMsg)
	n += 1 + l + sovMsg(uint64(l))
	return n
}

func (m *MsgWithDrawReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.C2CWithDraw) > 0 {
		for _, e := range m.C2CWithDraw {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if len(m.GroupWithDraw) > 0 {
		for _, e := range m.GroupWithDraw {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	return n
}

func (m *C2CMsgWithDrawReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MsgInfo) > 0 {
		for _, e := range m.MsgInfo {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	n += 1 + sovMsg(uint64(m.LongMessageFlag))
	if m.Reserved != nil {
		l = len(m.Reserved)
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 1 + sovMsg(uint64(m.SubCmd))
	return n
}

func (m *GroupMsgWithDrawReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMsg(uint64(m.SubCmd))
	n += 1 + sovMsg(uint64(m.GroupType))
	n += 1 + sovMsg(uint64(m.GroupCode))
	if len(m.MsgList) > 0 {
		for _, e := range m.MsgList {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if m.UserDef != nil {
		l = len(m.UserDef)
		n += 1 + l + sovMsg(uint64(l))
	}
	return n
}

func (m *MsgWithDrawResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.C2CWithDraw) > 0 {
		for _, e := range m.C2CWithDraw {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if len(m.GroupWithDraw) > 0 {
		for _, e := range m.GroupWithDraw {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	return n
}

func (m *C2CMsgWithDrawResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMsg(uint64(m.Result))
	l = len(m.ErrMsg)
	n += 1 + l + sovMsg(uint64(l))
	return n
}

func (m *GroupMsgWithDrawResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMsg(uint64(m.Result))
	l = len(m.ErrMsg)
	n += 1 + l + sovMsg(uint64(l))
	return n
}

func (m *GroupMsgInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMsg(uint64(m.MsgSeq))
	n += 1 + sovMsg(uint64(m.MsgRandom))
	n += 1 + sovMsg(uint64(m.MsgType))
	return n
}

func (m *C2CMsgInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMsg(uint64(m.FromUin))
	n += 1 + sovMsg(uint64(m.ToUin))
	n += 1 + sovMsg(uint64(m.MsgSeq))
	n += 1 + sovMsg(uint64(m.MsgUid))
	n += 1 + sovMsg(uint64(m.MsgTime))
	n += 1 + sovMsg(uint64(m.MsgRandom))
	n += 1 + sovMsg(uint64(m.PkgNum))
	n += 1 + sovMsg(uint64(m.PkgIndex))
	n += 1 + sovMsg(uint64(m.DivSeq))
	n += 1 + sovMsg(uint64(m.MsgType))
	if m.RoutingHead != nil {
		l = m.RoutingHead.Size()
		n += 2 + l + sovMsg(uint64(l))
	}
	return n
}

func (m *RoutingHead) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.C2C != nil {
		l = m.C2C.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.Grp != nil {
		l = m.Grp.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.GrpTmp != nil {
		l = m.GrpTmp.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	return n
}

func (m *C2C) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMsg(uint64(m.ToUin))
	return n
}

func (m *Grp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMsg(uint64(m.GroupCode))
	return n
}

func (m *GrpTmp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMsg(uint64(m.GroupUin))
	n += 1 + sovMsg(uint64(m.ToUin))
	return n
}

func (m *MsgCtrl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMsg(uint64(m.MsgFlag))
	return n
}

func (m *GetMessageResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMsg(uint64(m.Result))
	l = len(m.ErrorMessage)
	n += 1 + l + sovMsg(uint64(l))
	if m.SyncCookie != nil {
		l = len(m.SyncCookie)
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 1 + sovMsg(uint64(m.SyncFlag))
	if len(m.UinPairMsgs) > 0 {
		for _, e := range m.UinPairMsgs {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	n += 1 + sovMsg(uint64(m.BindUin))
	n += 1 + sovMsg(uint64(m.MsgRspType))
	if m.PubAccountCookie != nil {
		l = len(m.PubAccountCookie)
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 2
	if m.MsgCtrlBuf != nil {
		l = len(m.MsgCtrlBuf)
		n += 1 + l + sovMsg(uint64(l))
	}
	return n
}

func (m *PushMessagePacket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 1 + sovMsg(uint64(m.Svrip))
	if m.PushToken != nil {
		l = len(m.PushToken)
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 1 + sovMsg(uint64(m.PingFLag))
	n += 1 + sovMsg(uint64(m.GeneralFlag))
	return n
}

func (m *UinPairMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMsg(uint64(m.LastReadTime))
	n += 1 + sovMsg(uint64(m.PeerUin))
	n += 1 + sovMsg(uint64(m.MsgCompleted))
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	return n
}

func (m *Message) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Head != nil {
		l = m.Head.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.Content != nil {
		l = m.Content.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	return n
}

func (m *MessageBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RichText != nil {
		l = m.RichText.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.MsgContent != nil {
		l = len(m.MsgContent)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.MsgEncryptContent != nil {
		l = len(m.MsgEncryptContent)
		n += 1 + l + sovMsg(uint64(l))
	}
	return n
}

func (m *RichText) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Attr != nil {
		l = m.Attr.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	if len(m.Elems) > 0 {
		for _, e := range m.Elems {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if m.NotOnlineFile != nil {
		l = m.NotOnlineFile.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.Ptt != nil {
		l = m.Ptt.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	return n
}

func (m *Elem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Text != nil {
		l = m.Text.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.Face != nil {
		l = m.Face.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.OnlineImage != nil {
		l = m.OnlineImage.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.NotOnlineImage != nil {
		l = m.NotOnlineImage.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.TransElemInfo != nil {
		l = m.TransElemInfo.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.CustomFace != nil {
		l = m.CustomFace.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.RichMsg != nil {
		l = m.RichMsg.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.GroupFile != nil {
		l = m.GroupFile.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.ExtraInfo != nil {
		l = m.ExtraInfo.Size()
		n += 2 + l + sovMsg(uint64(l))
	}
	if m.VideoFile != nil {
		l = m.VideoFile.Size()
		n += 2 + l + sovMsg(uint64(l))
	}
	if m.AnonGroupMsg != nil {
		l = m.AnonGroupMsg.Size()
		n += 2 + l + sovMsg(uint64(l))
	}
	if m.QQWalletMsg != nil {
		l = m.QQWalletMsg.Size()
		n += 2 + l + sovMsg(uint64(l))
	}
	if m.CustomElem != nil {
		l = m.CustomElem.Size()
		n += 2 + l + sovMsg(uint64(l))
	}
	if m.GeneralFlags != nil {
		l = m.GeneralFlags.Size()
		n += 2 + l + sovMsg(uint64(l))
	}
	if m.SrcMsg != nil {
		l = m.SrcMsg.Size()
		n += 2 + l + sovMsg(uint64(l))
	}
	if m.LightApp != nil {
		l = m.LightApp.Size()
		n += 2 + l + sovMsg(uint64(l))
	}
	if m.CommonElem != nil {
		l = m.CommonElem.Size()
		n += 2 + l + sovMsg(uint64(l))
	}
	return n
}

func (m *CommonElem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMsg(uint64(m.ServiceType))
	if m.PbElem != nil {
		l = len(m.PbElem)
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 1 + sovMsg(uint64(m.BusinessType))
	return n
}

func (m *QQWalletMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AioBody != nil {
		l = m.AioBody.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	return n
}

func (m *QQWalletAioBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMsg(uint64(m.SendUin))
	if m.Sender != nil {
		l = m.Sender.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.Receiver != nil {
		l = m.Receiver.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 1 + sozMsg(uint64(m.ChannelId))
	n += 1 + sozMsg(uint64(m.TemplateId))
	n += 1 + sovMsg(uint64(m.Resend))
	n += 1 + sovMsg(uint64(m.MsgPriority))
	n += 1 + sozMsg(uint64(m.RedType))
	if m.BillNo != nil {
		l = len(m.BillNo)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.AuthKey != nil {
		l = len(m.AuthKey)
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 1 + sozMsg(uint64(m.SessionType))
	n += 1 + sozMsg(uint64(m.MsgType))
	n += 1 + sozMsg(uint64(m.EnvelOpeId))
	if m.Name != nil {
		l = len(m.Name)
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 1 + sozMsg(uint64(m.ConfType))
	n += 2 + sozMsg(uint64(m.MsgFrom))
	if m.PcBody != nil {
		l = len(m.PcBody)
		n += 2 + l + sovMsg(uint64(l))
	}
	if m.Index != nil {
		l = len(m.Index)
		n += 2 + l + sovMsg(uint64(l))
	}
	n += 2 + sovMsg(uint64(m.RedChannel))
	if len(m.GrapUin) > 0 {
		for _, e := range m.GrapUin {
			n += 2 + sovMsg(uint64(e))
		}
	}
	if m.PbReserve != nil {
		l = len(m.PbReserve)
		n += 2 + l + sovMsg(uint64(l))
	}
	return n
}

func (m *QQWalletAioElem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMsg(uint64(m.Background))
	n += 1 + sovMsg(uint64(m.Icon))
	l = len(m.Title)
	n += 1 + l + sovMsg(uint64(l))
	l = len(m.Subtitle)
	n += 1 + l + sovMsg(uint64(l))
	l = len(m.Content)
	n += 1 + l + sovMsg(uint64(l))
	if m.LinkUrl != nil {
		l = len(m.LinkUrl)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.BlackStripe != nil {
		l = len(m.BlackStripe)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.Notice != nil {
		l = len(m.Notice)
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 1 + sovMsg(uint64(m.TitleColor))
	n += 1 + sovMsg(uint64(m.SubtitleColor))
	if m.ActionsPriority != nil {
		l = len(m.ActionsPriority)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.JumpUrl != nil {
		l = len(m.JumpUrl)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.NativeIos != nil {
		l = len(m.NativeIos)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.NativeAndroid != nil {
		l = len(m.NativeAndroid)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.IconUrl != nil {
		l = len(m.IconUrl)
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 2 + sovMsg(uint64(m.ContentColor))
	n += 2 + sovMsg(uint64(m.ContentBgColor))
	if m.AioImageLeft != nil {
		l = len(m.AioImageLeft)
		n += 2 + l + sovMsg(uint64(l))
	}
	if m.AioImageRight != nil {
		l = len(m.AioImageRight)
		n += 2 + l + sovMsg(uint64(l))
	}
	if m.CftImage != nil {
		l = len(m.CftImage)
		n += 2 + l + sovMsg(uint64(l))
	}
	if m.PbReserve != nil {
		l = len(m.PbReserve)
		n += 2 + l + sovMsg(uint64(l))
	}
	return n
}

func (m *RichMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Template1 != nil {
		l = len(m.Template1)
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 1 + sovMsg(uint64(m.ServiceId))
	if m.MsgResId != nil {
		l = len(m.MsgResId)
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 1 + sovMsg(uint64(m.Rand))
	n += 1 + sovMsg(uint64(m.Seq))
	return n
}

func (m *CustomElem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Desc != nil {
		l = len(m.Desc)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.Data != nil {
		l = len(m.Data)
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 1 + sovMsg(uint64(m.EnumType))
	if m.Ext != nil {
		l = len(m.Ext)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.Sound != nil {
		l = len(m.Sound)
		n += 1 + l + sovMsg(uint64(l))
	}
	return n
}

func (m *Text) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Str)
	n += 1 + l + sovMsg(uint64(l))
	l = len(m.Link)
	n += 1 + l + sovMsg(uint64(l))
	if m.Attr6Buf != nil {
		l = len(m.Attr6Buf)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.Attr7Buf != nil {
		l = len(m.Attr7Buf)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.Buf != nil {
		l = len(m.Buf)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.PbReserve != nil {
		l = len(m.PbReserve)
		n += 1 + l + sovMsg(uint64(l))
	}
	return n
}

func (m *Attr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMsg(uint64(m.CodePage))
	n += 1 + sovMsg(uint64(m.Time))
	n += 1 + sovMsg(uint64(m.Random))
	n += 1 + sovMsg(uint64(m.Color))
	n += 1 + sovMsg(uint64(m.Size_))
	n += 1 + sovMsg(uint64(m.Effect))
	n += 1 + sovMsg(uint64(m.CharSet))
	n += 1 + sovMsg(uint64(m.PitchAndFamily))
	l = len(m.FontName)
	n += 1 + l + sovMsg(uint64(l))
	if m.ReserveData != nil {
		l = len(m.ReserveData)
		n += 1 + l + sovMsg(uint64(l))
	}
	return n
}

func (m *Ptt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMsg(uint64(m.FileType))
	n += 1 + sovMsg(uint64(m.SrcUin))
	if m.FileUuid != nil {
		l = len(m.FileUuid)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.FileMd5 != nil {
		l = len(m.FileMd5)
		n += 1 + l + sovMsg(uint64(l))
	}
	l = len(m.FileName)
	n += 1 + l + sovMsg(uint64(l))
	n += 1 + sovMsg(uint64(m.FileSize))
	if m.Reserve != nil {
		l = len(m.Reserve)
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 1 + sovMsg(uint64(m.FileId))
	n += 1 + sovMsg(uint64(m.ServerIp))
	n += 1 + sovMsg(uint64(m.ServerPort))
	n += 2
	if m.Signature != nil {
		l = len(m.Signature)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.Shortcut != nil {
		l = len(m.Shortcut)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.FileKey != nil {
		l = len(m.FileKey)
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 1 + sovMsg(uint64(m.MagicPttIndex))
	n += 2 + sovMsg(uint64(m.VoiceSwitch))
	if m.PttUrl != nil {
		l = len(m.PttUrl)
		n += 2 + l + sovMsg(uint64(l))
	}
	if m.GroupFileKey != nil {
		l = len(m.GroupFileKey)
		n += 2 + l + sovMsg(uint64(l))
	}
	n += 2 + sovMsg(uint64(m.Time))
	if m.DownPara != nil {
		l = len(m.DownPara)
		n += 2 + l + sovMsg(uint64(l))
	}
	n += 2 + sovMsg(uint64(m.Format))
	if m.PbReserve != nil {
		l = len(m.PbReserve)
		n += 2 + l + sovMsg(uint64(l))
	}
	if len(m.BytesPttUrls) > 0 {
		for _, b := range m.BytesPttUrls {
			l = len(b)
			n += 2 + l + sovMsg(uint64(l))
		}
	}
	n += 2 + sovMsg(uint64(m.DownloadFlag))
	return n
}

func (m *OnlineImage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Guid != nil {
		l = len(m.Guid)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.FilePath != nil {
		l = len(m.FilePath)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.OldVerSendFile != nil {
		l = len(m.OldVerSendFile)
		n += 1 + l + sovMsg(uint64(l))
	}
	return n
}

func (m *NotOnlineImage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FilePath)
	n += 1 + l + sovMsg(uint64(l))
	n += 1 + sovMsg(uint64(m.FileLen))
	l = len(m.DownloadPath)
	n += 1 + l + sovMsg(uint64(l))
	if m.OldVerSendFile != nil {
		l = len(m.OldVerSendFile)
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 1 + sovMsg(uint64(m.ImgType))
	if m.PreviewsImage != nil {
		l = len(m.PreviewsImage)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.PicMd5 != nil {
		l = len(m.PicMd5)
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 1 + sovMsg(uint64(m.PicHeight))
	n += 1 + sovMsg(uint64(m.PicWidth))
	l = len(m.ResId)
	n += 1 + l + sovMsg(uint64(l))
	if m.Flag != nil {
		l = len(m.Flag)
		n += 1 + l + sovMsg(uint64(l))
	}
	l = len(m.ThumbUrl)
	n += 1 + l + sovMsg(uint64(l))
	n += 1 + sovMsg(uint64(m.Original))
	l = len(m.BigUrl)
	n += 1 + l + sovMsg(uint64(l))
	l = len(m.OrigUrl)
	n += 1 + l + sovMsg(uint64(l))
	n += 2 + sovMsg(uint64(m.BizType))
	n += 2 + sovMsg(uint64(m.Result))
	n += 2 + sovMsg(uint64(m.Index))
	if m.OpFaceBuf != nil {
		l = len(m.OpFaceBuf)
		n += 2 + l + sovMsg(uint64(l))
	}
	n += 3
	n += 2 + sovMsg(uint64(m.ThumbWidth))
	n += 2 + sovMsg(uint64(m.ThumbHeight))
	n += 2 + sovMsg(uint64(m.FileId))
	n += 2 + sovMsg(uint64(m.ShowLen))
	n += 2 + sovMsg(uint64(m.DownloadLen))
	if m.PbReserve != nil {
		l = len(m.PbReserve)
		n += 2 + l + sovMsg(uint64(l))
	}
	return n
}

func (m *NotOnlineFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMsg(uint64(m.FileType))
	if m.Sig != nil {
		l = len(m.Sig)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.FileUuid != nil {
		l = len(m.FileUuid)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.FileMd5 != nil {
		l = len(m.FileMd5)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.FileName != nil {
		l = len(m.FileName)
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 1 + sovMsg(uint64(m.FileSize))
	if m.Note != nil {
		l = len(m.Note)
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 1 + sovMsg(uint64(m.Reserved))
	n += 1 + sovMsg(uint64(m.Subcmd))
	n += 1 + sovMsg(uint64(m.MicroCloud))
	if len(m.BytesFileUrls) > 0 {
		for _, b := range m.BytesFileUrls {
			l = len(b)
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	n += 1 + sovMsg(uint64(m.DownloadFlag))
	n += 2 + sovMsg(uint64(m.DangerEvel))
	n += 2 + sovMsg(uint64(m.LifeTime))
	n += 2 + sovMsg(uint64(m.UploadTime))
	n += 2 + sovMsg(uint64(m.AbsFileType))
	n += 2 + sovMsg(uint64(m.ClientType))
	n += 2 + sovMsg(uint64(m.ExpireTime))
	if m.PbReserve != nil {
		l = len(m.PbReserve)
		n += 2 + l + sovMsg(uint64(l))
	}
	return n
}

func (m *TransElem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMsg(uint64(m.ElemType))
	if m.ElemValue != nil {
		l = len(m.ElemValue)
		n += 1 + l + sovMsg(uint64(l))
	}
	return n
}

func (m *ExtraInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nick != nil {
		l = len(m.Nick)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.GroupCard != nil {
		l = len(m.GroupCard)
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 1 + sovMsg(uint64(m.Level))
	n += 1 + sovMsg(uint64(m.Flags))
	n += 1 + sovMsg(uint64(m.GroupMask))
	n += 1 + sovMsg(uint64(m.MsgTailId))
	if m.SenderTitle != nil {
		l = len(m.SenderTitle)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.ApnsTips != nil {
		l = len(m.ApnsTips)
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 1 + sovMsg(uint64(m.Uin))
	n += 1 + sovMsg(uint64(m.MsgStateFlag))
	n += 1 + sovMsg(uint64(m.ApnsSoundType))
	n += 1 + sovMsg(uint64(m.NewGroupFlag))
	return n
}

func (m *GroupFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Filename != nil {
		l = len(m.Filename)
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 1 + sovMsg(uint64(m.FileSize))
	if m.FileId != nil {
		l = len(m.FileId)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.BatchId != nil {
		l = len(m.BatchId)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.FileKey != nil {
		l = len(m.FileKey)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.Mark != nil {
		l = len(m.Mark)
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 1 + sovMsg(uint64(m.Sequence))
	if m.BatchItemId != nil {
		l = len(m.BatchItemId)
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 1 + sovMsg(uint64(m.FeedMsgTime))
	if m.PbReserve != nil {
		l = len(m.PbReserve)
		n += 1 + l + sovMsg(uint64(l))
	}
	return n
}

func (m *AnonymousGroupMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMsg(uint64(m.Flags))
	if m.AnonId != nil {
		l = len(m.AnonId)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.AnonNick != nil {
		l = len(m.AnonNick)
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 1 + sovMsg(uint64(m.HeadPortrait))
	n += 1 + sovMsg(uint64(m.ExpireTime))
	n += 1 + sovMsg(uint64(m.BubbleId))
	if m.RankColor != nil {
		l = len(m.RankColor)
		n += 1 + l + sovMsg(uint64(l))
	}
	return n
}

func (m *VideoFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FileUuid != nil {
		l = len(m.FileUuid)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.FileMd5 != nil {
		l = len(m.FileMd5)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.FileName != nil {
		l = len(m.FileName)
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 1 + sovMsg(uint64(m.FileFormat))
	n += 1 + sovMsg(uint64(m.FileTime))
	n += 1 + sovMsg(uint64(m.FileSize))
	n += 1 + sovMsg(uint64(m.ThumbWidth))
	n += 1 + sovMsg(uint64(m.ThumbHeight))
	if m.ThumbFileMd5 != nil {
		l = len(m.ThumbFileMd5)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.Source != nil {
		l = len(m.Source)
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 1 + sovMsg(uint64(m.ThumbFileSize))
	n += 1 + sovMsg(uint64(m.BusiType))
	n += 1 + sovMsg(uint64(m.FromChatType))
	n += 1 + sovMsg(uint64(m.ToChatType))
	n += 2
	n += 2 + sovMsg(uint64(m.FileWidth))
	n += 2 + sovMsg(uint64(m.FileHeight))
	n += 2 + sovMsg(uint64(m.SubBusiType))
	n += 2 + sovMsg(uint64(m.VideoAttr))
	if len(m.BytesThumbFileUrls) > 0 {
		for _, b := range m.BytesThumbFileUrls {
			l = len(b)
			n += 2 + l + sovMsg(uint64(l))
		}
	}
	if len(m.BytesVideoFileUrls) > 0 {
		for _, b := range m.BytesVideoFileUrls {
			l = len(b)
			n += 2 + l + sovMsg(uint64(l))
		}
	}
	n += 2 + sovMsg(uint64(m.ThumbDownloadFlag))
	n += 2 + sovMsg(uint64(m.VideoDownloadFlag))
	if m.PbReserve != nil {
		l = len(m.PbReserve)
		n += 2 + l + sovMsg(uint64(l))
	}
	return n
}

func (m *SourceMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.OrigSeqs) > 0 {
		for _, e := range m.OrigSeqs {
			n += 1 + sovMsg(uint64(e))
		}
	}
	n += 1 + sovMsg(uint64(m.SenderUin))
	n += 1 + sovMsg(uint64(m.Time))
	n += 1 + sovMsg(uint64(m.Flag))
	if len(m.Elems) > 0 {
		for _, e := range m.Elems {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	n += 1 + sovMsg(uint64(m.Type))
	if m.RichMsg != nil {
		l = len(m.RichMsg)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.PbReserve != nil {
		l = len(m.PbReserve)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.SrcMsg != nil {
		l = len(m.SrcMsg)
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 1 + sovMsg(uint64(m.ToUin))
	if m.TroopName != nil {
		l = len(m.TroopName)
		n += 1 + l + sovMsg(uint64(l))
	}
	return n
}

func (m *Face) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMsg(uint64(m.Index))
	if m.Old != nil {
		l = len(m.Old)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.Buf != nil {
		l = len(m.Buf)
		n += 1 + l + sovMsg(uint64(l))
	}
	return n
}

func (m *LightAppElem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		l = len(m.Data)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.MsgResid != nil {
		l = len(m.MsgResid)
		n += 1 + l + sovMsg(uint64(l))
	}
	return n
}

func (m *CustomFace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Guid != nil {
		l = len(m.Guid)
		n += 1 + l + sovMsg(uint64(l))
	}
	l = len(m.FilePath)
	n += 1 + l + sovMsg(uint64(l))
	l = len(m.Shortcut)
	n += 1 + l + sovMsg(uint64(l))
	if m.Buffer != nil {
		l = len(m.Buffer)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.Flag != nil {
		l = len(m.Flag)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.OldData != nil {
		l = len(m.OldData)
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 1 + sovMsg(uint64(m.FileId))
	n += 1 + sovMsg(uint64(m.ServerIp))
	n += 1 + sovMsg(uint64(m.ServerPort))
	n += 1 + sovMsg(uint64(m.FileType))
	if m.Signature != nil {
		l = len(m.Signature)
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 1 + sovMsg(uint64(m.Useful))
	if m.Md5 != nil {
		l = len(m.Md5)
		n += 1 + l + sovMsg(uint64(l))
	}
	l = len(m.ThumbUrl)
	n += 1 + l + sovMsg(uint64(l))
	l = len(m.BigUrl)
	n += 1 + l + sovMsg(uint64(l))
	l = len(m.OrigUrl)
	n += 2 + l + sovMsg(uint64(l))
	n += 2 + sovMsg(uint64(m.BizType))
	n += 2 + sovMsg(uint64(m.RepeatIndex))
	n += 2 + sovMsg(uint64(m.RepeatImage))
	n += 2 + sovMsg(uint64(m.ImageType))
	n += 2 + sovMsg(uint64(m.Index))
	n += 2 + sovMsg(uint64(m.Width))
	n += 2 + sovMsg(uint64(m.Height))
	n += 2 + sovMsg(uint64(m.Source))
	n += 2 + sovMsg(uint64(m.Size_))
	n += 2 + sovMsg(uint64(m.Origin))
	n += 2 + sovMsg(uint64(m.ThumbWidth))
	n += 2 + sovMsg(uint64(m.ThumbHeight))
	n += 2 + sovMsg(uint64(m.ShowLen))
	n += 2 + sovMsg(uint64(m.DownloadLen))
	l = len(m.X400Url)
	n += 2 + l + sovMsg(uint64(l))
	n += 2 + sovMsg(uint64(m.X400Width))
	n += 2 + sovMsg(uint64(m.X400Height))
	if m.PbReserve != nil {
		l = len(m.PbReserve)
		n += 2 + l + sovMsg(uint64(l))
	}
	return n
}

func (m *ContentHead) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMsg(uint64(m.PkgNum))
	n += 1 + sovMsg(uint64(m.PkgIndex))
	n += 1 + sovMsg(uint64(m.DivSeq))
	n += 1 + sovMsg(uint64(m.AutoReply))
	return n
}

func (m *MessageHead) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMsg(uint64(m.FromUin))
	n += 1 + sovMsg(uint64(m.ToUin))
	n += 1 + sovMsg(uint64(m.MsgType))
	n += 1 + sovMsg(uint64(m.C2CCmd))
	n += 1 + sovMsg(uint64(m.MsgSeq))
	n += 1 + sovMsg(uint64(m.MsgTime))
	n += 1 + sovMsg(uint64(m.MsgUid))
	if m.C2CTmpMsgHead != nil {
		l = m.C2CTmpMsgHead.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.GroupInfo != nil {
		l = m.GroupInfo.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 1 + sovMsg(uint64(m.FromAppid))
	n += 1 + sovMsg(uint64(m.FromInstid))
	n += 1 + sovMsg(uint64(m.UserActive))
	if m.DiscussInfo != nil {
		l = m.DiscussInfo.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	l = len(m.FromNick)
	n += 1 + l + sovMsg(uint64(l))
	n += 1 + sovMsg(uint64(m.AuthUin))
	l = len(m.AuthNick)
	n += 2 + l + sovMsg(uint64(l))
	n += 2 + sovMsg(uint64(m.MsgFlag))
	l = len(m.AuthRemark)
	n += 2 + l + sovMsg(uint64(l))
	l = len(m.GroupName)
	n += 2 + l + sovMsg(uint64(l))
	if m.MutiltransHead != nil {
		l = m.MutiltransHead.Size()
		n += 2 + l + sovMsg(uint64(l))
	}
	if m.MsgInstCtrl != nil {
		l = m.MsgInstCtrl.Size()
		n += 2 + l + sovMsg(uint64(l))
	}
	n += 2 + sovMsg(uint64(m.PublicAccountGroupSendFlag))
	n += 2 + sovMsg(uint64(m.WseqInC2CMsghead))
	n += 2 + sovMsg(uint64(m.Cpid))
	if m.ExtGroupKeyInfo != nil {
		l = m.ExtGroupKeyInfo.Size()
		n += 2 + l + sovMsg(uint64(l))
	}
	l = len(m.MultiCompatibleText)
	n += 2 + l + sovMsg(uint64(l))
	n += 2 + sovMsg(uint64(m.AuthSex))
	n += 3
	return n
}

func (m *GroupInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMsg(uint64(m.GroupCode))
	n += 1 + sovMsg(uint64(m.GroupType))
	n += 1 + sovMsg(uint64(m.GroupInfoSeq))
	l = len(m.GroupCard)
	n += 1 + l + sovMsg(uint64(l))
	if m.GroupRank != nil {
		l = len(m.GroupRank)
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 1 + sovMsg(uint64(m.GroupLevel))
	n += 1 + sovMsg(uint64(m.GroupCardType))
	if m.GroupName != nil {
		l = len(m.GroupName)
		n += 1 + l + sovMsg(uint64(l))
	}
	return n
}

func (m *DiscussInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMsg(uint64(m.DiscussUin))
	n += 1 + sovMsg(uint64(m.DiscussType))
	n += 1 + sovMsg(uint64(m.DiscussInfoSeq))
	if m.DiscussRemark != nil {
		l = len(m.DiscussRemark)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.DiscussName != nil {
		l = len(m.DiscussName)
		n += 1 + l + sovMsg(uint64(l))
	}
	return n
}

func (m *MutilTransHead) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMsg(uint64(m.Status))
	n += 1 + sovMsg(uint64(m.MsgId))
	return n
}

func (m *C2CTempMessageHead) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMsg(uint64(m.C2CType))
	n += 1 + sovMsg(uint64(m.ServiceType))
	n += 1 + sovMsg(uint64(m.GroupUin))
	n += 1 + sovMsg(uint64(m.GroupCode))
	if m.Sig != nil {
		l = len(m.Sig)
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 1 + sovMsg(uint64(m.SigType))
	l = len(m.FromPhone)
	n += 1 + l + sovMsg(uint64(l))
	l = len(m.ToPhone)
	n += 1 + l + sovMsg(uint64(l))
	n += 1 + sovMsg(uint64(m.LockDisplay))
	n += 1 + sovMsg(uint64(m.DirectionFlag))
	if m.Reserved != nil {
		l = len(m.Reserved)
		n += 1 + l + sovMsg(uint64(l))
	}
	return n
}

func (m *InstCtrl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MsgSendToInst) > 0 {
		for _, e := range m.MsgSendToInst {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if len(m.MsgExcludeInst) > 0 {
		for _, e := range m.MsgExcludeInst {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if m.MsgFromInst != nil {
		l = m.MsgFromInst.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	return n
}

func (m *InstInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMsg(uint64(m.Apppid))
	n += 1 + sovMsg(uint64(m.Instid))
	n += 1 + sovMsg(uint64(m.Platform))
	n += 1 + sovMsg(uint64(m.EnumDeviceType))
	return n
}

func (m *ExtGroupKeyInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMsg(uint64(m.CurMaxSeq))
	n += 1 + sovMsg(uint64(m.CurTime))
	return n
}

func (m *SyncCookie) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMsg(uint64(m.Time1))
	n += 1 + sovMsg(uint64(m.Time))
	n += 1 + sovMsg(uint64(m.Ran1))
	n += 1 + sovMsg(uint64(m.Ran2))
	n += 1 + sovMsg(uint64(m.Const1))
	n += 1 + sovMsg(uint64(m.Const2))
	n += 1 + sovMsg(uint64(m.Const3))
	n += 1 + sovMsg(uint64(m.LastSyncTime))
	n += 1 + sovMsg(uint64(m.Const4))
	return n
}

func (m *TransMsgInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMsg(uint64(m.FromUin))
	n += 1 + sovMsg(uint64(m.ToUin))
	n += 1 + sovMsg(uint64(m.MsgType))
	n += 1 + sovMsg(uint64(m.MsgSubtype))
	n += 1 + sovMsg(uint64(m.MsgSeq))
	n += 1 + sovMsg(uint64(m.MsgUid))
	n += 1 + sovMsg(uint64(m.MsgTime))
	n += 1 + sovMsg(uint64(m.RealMsgTime))
	l = len(m.NickName)
	n += 1 + l + sovMsg(uint64(l))
	if m.MsgData != nil {
		l = len(m.MsgData)
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 1 + sovMsg(uint64(m.SvrIp))
	if m.ExtGroupKeyInfo != nil {
		l = m.ExtGroupKeyInfo.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 2 + sovMsg(uint64(m.GeneralFlag))
	return n
}

func (m *GeneralFlags) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMsg(uint64(m.BubbleDiyTextId))
	n += 1 + sovMsg(uint64(m.GroupFlagNew))
	n += 1 + sovMsg(uint64(m.Uin))
	if m.RpId != nil {
		l = len(m.RpId)
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 1 + sovMsg(uint64(m.PrpFold))
	n += 1 + sovMsg(uint64(m.LongTextFlag))
	l = len(m.LongTextResid)
	n += 1 + l + sovMsg(uint64(l))
	n += 1 + sovMsg(uint64(m.GroupType))
	n += 1 + sovMsg(uint64(m.ToUinFlag))
	n += 1 + sovMsg(uint64(m.GlamourLevel))
	n += 1 + sovMsg(uint64(m.MemberLevel))
	n += 1 + sovMsg(uint64(m.GroupRankSeq))
	n += 1 + sovMsg(uint64(m.OlympicTorch))
	if m.BabyqGuideMsgCookie != nil {
		l = len(m.BabyqGuideMsgCookie)
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 1 + sovMsg(uint64(m.Uin32ExpertFlag))
	n += 2 + sovMsg(uint64(m.BubbleSubId))
	n += 2 + sovMsg(uint64(m.PendantId))
	if m.RpIndex != nil {
		l = len(m.RpIndex)
		n += 2 + l + sovMsg(uint64(l))
	}
	if m.PbReserve != nil {
		l = len(m.PbReserve)
		n += 2 + l + sovMsg(uint64(l))
	}
	return n
}

func (m *PbMultiMsgItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FileName)
	n += 1 + l + sovMsg(uint64(l))
	if m.Buffer != nil {
		l = m.Buffer.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	return n
}

func (m *PbMultiMsgNew) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Msg) > 0 {
		for _, e := range m.Msg {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	return n
}

func (m *PbMultiMsgTransmit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Msg) > 0 {
		for _, e := range m.Msg {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if len(m.PbItemList) > 0 {
		for _, e := range m.PbItemList {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	return n
}

func (m *MsgElemInfoServtype3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FlashTroopPic != nil {
		l = m.FlashTroopPic.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.FlashC2CPic != nil {
		l = m.FlashC2CPic.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	return n
}

func (m *MsgElemInfoServtype33) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMsg(uint64(m.Index))
	if m.Text != nil {
		l = len(m.Text)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.Compat != nil {
		l = len(m.Compat)
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.Buf != nil {
		l = len(m.Buf)
		n += 1 + l + sovMsg(uint64(l))
	}
	return n
}

func (m *SubMsgType0X4Body) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NotOnlineFile != nil {
		l = m.NotOnlineFile.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	n += 1 + sovMsg(uint64(m.MsgTime))
	n += 1 + sovMsg(uint64(m.OnlineFileForPolyToOffline))
	return n
}

func (m *ResvAttr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ImageShow != nil {
		l = m.ImageShow.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	return n
}

func (m *AnimationImageShow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMsg(uint64(m.EffectId))
	if m.AnimationParam != nil {
		l = len(m.AnimationParam)
		n += 1 + l + sovMsg(uint64(l))
	}
	return n
}

func (m *UinTypeUserDef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMsg(uint64(m.FromUinType))
	n += 1 + sovMsg(uint64(m.FromGroupCode))
	l = len(m.FileUuid)
	n += 1 + l + sovMsg(uint64(l))
	return n
}

func (m *GetGroupMsgReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMsg(uint64(m.GroupCode))
	n += 1 + sovMsg(uint64(m.BeginSeq))
	n += 1 + sovMsg(uint64(m.EndSeq))
	n += 1 + sovMsg(uint64(m.Filter))
	n += 1 + sovMsg(uint64(m.MemberSeq))
	n += 2
	n += 1 + sovMsg(uint64(m.ShieldFlag))
	n += 1 + sovMsg(uint64(m.SaveTrafficFlag))
	return n
}

func (m *GetGroupMsgResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMsg(uint64(m.Result))
	l = len(m.Errmsg)
	n += 1 + l + sovMsg(uint64(l))
	n += 1 + sovMsg(uint64(m.GroupCode))
	n += 1 + sovMsg(uint64(m.ReturnBeginSeq))
	n += 1 + sovMsg(uint64(m.ReturnEndSeq))
	if len(m.Msg) > 0 {
		for _, e := range m.Msg {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	return n
}

func sovMsg(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMsg(x uint64) (n int) {
	return sovMsg(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GetMessageRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMessageRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMessageRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncFlag", wireType)
			}
			m.SyncFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SyncFlag |= SyncFlag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncCookie", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SyncCookie = append(m.SyncCookie[:0], dAtA[iNdEx:postIndex]...)
			if m.SyncCookie == nil {
				m.SyncCookie = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RambleFlag", wireType)
			}
			m.RambleFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RambleFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestRambleNumber", wireType)
			}
			m.LatestRambleNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatestRambleNumber |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherRambleNumber", wireType)
			}
			m.OtherRambleNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OtherRambleNumber |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnlineSyncFlag", wireType)
			}
			m.OnlineSyncFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnlineSyncFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContextFlag", wireType)
			}
			m.ContextFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContextFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WhisperSessionId", wireType)
			}
			m.WhisperSessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WhisperSessionId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgReqType", wireType)
			}
			m.MsgReqType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgReqType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubaccountCookie", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubaccountCookie = append(m.PubaccountCookie[:0], dAtA[iNdEx:postIndex]...)
			if m.PubaccountCookie == nil {
				m.PubaccountCookie = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgCtrlBuf", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgCtrlBuf = append(m.MsgCtrlBuf[:0], dAtA[iNdEx:postIndex]...)
			if m.MsgCtrlBuf == nil {
				m.MsgCtrlBuf = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerBuf", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerBuf = append(m.ServerBuf[:0], dAtA[iNdEx:postIndex]...)
			if m.ServerBuf == nil {
				m.ServerBuf = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendMessageRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendMessageRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendMessageRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoutingHead", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RoutingHead == nil {
				m.RoutingHead = &RoutingHead{}
			}
			if err := m.RoutingHead.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentHead", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContentHead == nil {
				m.ContentHead = &ContentHead{}
			}
			if err := m.ContentHead.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgBody", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MsgBody == nil {
				m.MsgBody = &MessageBody{}
			}
			if err := m.MsgBody.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgSeq", wireType)
			}
			m.MsgSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgSeq |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgRand", wireType)
			}
			m.MsgRand = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgRand |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncCookie", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SyncCookie = append(m.SyncCookie[:0], dAtA[iNdEx:postIndex]...)
			if m.SyncCookie == nil {
				m.SyncCookie = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgVia", wireType)
			}
			m.MsgVia = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgVia |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataStatist", wireType)
			}
			m.DataStatist = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataStatist |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgCtrl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MsgCtrl == nil {
				m.MsgCtrl = &MsgCtrl{}
			}
			if err := m.MsgCtrl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiSendSeq", wireType)
			}
			m.MultiSendSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MultiSendSeq |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendMessageResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendMessageResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendMessageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgWithDrawReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgWithDrawReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgWithDrawReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field C2CWithDraw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.C2CWithDraw = append(m.C2CWithDraw, &C2CMsgWithDrawReq{})
			if err := m.C2CWithDraw[len(m.C2CWithDraw)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupWithDraw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupWithDraw = append(m.GroupWithDraw, &GroupMsgWithDrawReq{})
			if err := m.GroupWithDraw[len(m.GroupWithDraw)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2CMsgWithDrawReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2CMsgWithDrawReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2CMsgWithDrawReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgInfo = append(m.MsgInfo, &C2CMsgInfo{})
			if err := m.MsgInfo[len(m.MsgInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LongMessageFlag", wireType)
			}
			m.LongMessageFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LongMessageFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reserved = append(m.Reserved[:0], dAtA[iNdEx:postIndex]...)
			if m.Reserved == nil {
				m.Reserved = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubCmd", wireType)
			}
			m.SubCmd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubCmd |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupMsgWithDrawReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupMsgWithDrawReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupMsgWithDrawReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubCmd", wireType)
			}
			m.SubCmd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubCmd |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupType", wireType)
			}
			m.GroupType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupCode", wireType)
			}
			m.GroupCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupCode |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgList = append(m.MsgList, &GroupMsgInfo{})
			if err := m.MsgList[len(m.MsgList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserDef", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserDef = append(m.UserDef[:0], dAtA[iNdEx:postIndex]...)
			if m.UserDef == nil {
				m.UserDef = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgWithDrawResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgWithDrawResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgWithDrawResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field C2CWithDraw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.C2CWithDraw = append(m.C2CWithDraw, &C2CMsgWithDrawResp{})
			if err := m.C2CWithDraw[len(m.C2CWithDraw)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupWithDraw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupWithDraw = append(m.GroupWithDraw, &GroupMsgWithDrawResp{})
			if err := m.GroupWithDraw[len(m.GroupWithDraw)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2CMsgWithDrawResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2CMsgWithDrawResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2CMsgWithDrawResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupMsgWithDrawResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupMsgWithDrawResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupMsgWithDrawResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupMsgInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupMsgInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupMsgInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgSeq", wireType)
			}
			m.MsgSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgSeq |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgRandom", wireType)
			}
			m.MsgRandom = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgRandom |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgType", wireType)
			}
			m.MsgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2CMsgInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2CMsgInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2CMsgInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromUin", wireType)
			}
			m.FromUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToUin", wireType)
			}
			m.ToUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgSeq", wireType)
			}
			m.MsgSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgSeq |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgUid", wireType)
			}
			m.MsgUid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgUid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgTime", wireType)
			}
			m.MsgTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgRandom", wireType)
			}
			m.MsgRandom = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgRandom |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PkgNum", wireType)
			}
			m.PkgNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PkgNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PkgIndex", wireType)
			}
			m.PkgIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PkgIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DivSeq", wireType)
			}
			m.DivSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DivSeq |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgType", wireType)
			}
			m.MsgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoutingHead", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RoutingHead == nil {
				m.RoutingHead = &RoutingHead{}
			}
			if err := m.RoutingHead.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoutingHead) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoutingHead: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoutingHead: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field C2C", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.C2C == nil {
				m.C2C = &C2C{}
			}
			if err := m.C2C.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Grp == nil {
				m.Grp = &Grp{}
			}
			if err := m.Grp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrpTmp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GrpTmp == nil {
				m.GrpTmp = &GrpTmp{}
			}
			if err := m.GrpTmp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2C) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2C: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2C: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToUin", wireType)
			}
			m.ToUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Grp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Grp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Grp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupCode", wireType)
			}
			m.GroupCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupCode |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GrpTmp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GrpTmp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GrpTmp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupUin", wireType)
			}
			m.GroupUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToUin", wireType)
			}
			m.ToUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCtrl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCtrl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCtrl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgFlag", wireType)
			}
			m.MsgFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMessageResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMessageResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMessageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncCookie", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SyncCookie = append(m.SyncCookie[:0], dAtA[iNdEx:postIndex]...)
			if m.SyncCookie == nil {
				m.SyncCookie = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncFlag", wireType)
			}
			m.SyncFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SyncFlag |= SyncFlag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UinPairMsgs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UinPairMsgs = append(m.UinPairMsgs, &UinPairMessage{})
			if err := m.UinPairMsgs[len(m.UinPairMsgs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BindUin", wireType)
			}
			m.BindUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BindUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgRspType", wireType)
			}
			m.MsgRspType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgRspType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubAccountCookie", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubAccountCookie = append(m.PubAccountCookie[:0], dAtA[iNdEx:postIndex]...)
			if m.PubAccountCookie == nil {
				m.PubAccountCookie = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPartialSync", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPartialSync = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgCtrlBuf", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgCtrlBuf = append(m.MsgCtrlBuf[:0], dAtA[iNdEx:postIndex]...)
			if m.MsgCtrlBuf == nil {
				m.MsgCtrlBuf = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PushMessagePacket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PushMessagePacket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PushMessagePacket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &Message{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Svrip", wireType)
			}
			m.Svrip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Svrip |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushToken", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PushToken = append(m.PushToken[:0], dAtA[iNdEx:postIndex]...)
			if m.PushToken == nil {
				m.PushToken = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PingFLag", wireType)
			}
			m.PingFLag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PingFLag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeneralFlag", wireType)
			}
			m.GeneralFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GeneralFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UinPairMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UinPairMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UinPairMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastReadTime", wireType)
			}
			m.LastReadTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastReadTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerUin", wireType)
			}
			m.PeerUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgCompleted", wireType)
			}
			m.MsgCompleted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgCompleted |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, &Message{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Head == nil {
				m.Head = &MessageHead{}
			}
			if err := m.Head.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Content == nil {
				m.Content = &ContentHead{}
			}
			if err := m.Content.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &MessageBody{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RichText", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RichText == nil {
				m.RichText = &RichText{}
			}
			if err := m.RichText.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgContent", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgContent = append(m.MsgContent[:0], dAtA[iNdEx:postIndex]...)
			if m.MsgContent == nil {
				m.MsgContent = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgEncryptContent", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgEncryptContent = append(m.MsgEncryptContent[:0], dAtA[iNdEx:postIndex]...)
			if m.MsgEncryptContent == nil {
				m.MsgEncryptContent = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RichText) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RichText: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RichText: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attr == nil {
				m.Attr = &Attr{}
			}
			if err := m.Attr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Elems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Elems = append(m.Elems, &Elem{})
			if err := m.Elems[len(m.Elems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotOnlineFile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NotOnlineFile == nil {
				m.NotOnlineFile = &NotOnlineFile{}
			}
			if err := m.NotOnlineFile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ptt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ptt == nil {
				m.Ptt = &Ptt{}
			}
			if err := m.Ptt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Elem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Elem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Elem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Text == nil {
				m.Text = &Text{}
			}
			if err := m.Text.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Face", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Face == nil {
				m.Face = &Face{}
			}
			if err := m.Face.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnlineImage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OnlineImage == nil {
				m.OnlineImage = &OnlineImage{}
			}
			if err := m.OnlineImage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotOnlineImage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NotOnlineImage == nil {
				m.NotOnlineImage = &NotOnlineImage{}
			}
			if err := m.NotOnlineImage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransElemInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransElemInfo == nil {
				m.TransElemInfo = &TransElem{}
			}
			if err := m.TransElemInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomFace", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CustomFace == nil {
				m.CustomFace = &CustomFace{}
			}
			if err := m.CustomFace.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RichMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RichMsg == nil {
				m.RichMsg = &RichMsg{}
			}
			if err := m.RichMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupFile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GroupFile == nil {
				m.GroupFile = &GroupFile{}
			}
			if err := m.GroupFile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExtraInfo == nil {
				m.ExtraInfo = &ExtraInfo{}
			}
			if err := m.ExtraInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoFile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VideoFile == nil {
				m.VideoFile = &VideoFile{}
			}
			if err := m.VideoFile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnonGroupMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AnonGroupMsg == nil {
				m.AnonGroupMsg = &AnonymousGroupMessage{}
			}
			if err := m.AnonGroupMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QQWalletMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QQWalletMsg == nil {
				m.QQWalletMsg = &QQWalletMsg{}
			}
			if err := m.QQWalletMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomElem", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CustomElem == nil {
				m.CustomElem = &CustomElem{}
			}
			if err := m.CustomElem.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeneralFlags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GeneralFlags == nil {
				m.GeneralFlags = &GeneralFlags{}
			}
			if err := m.GeneralFlags.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcMsg == nil {
				m.SrcMsg = &SourceMsg{}
			}
			if err := m.SrcMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LightApp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LightApp == nil {
				m.LightApp = &LightAppElem{}
			}
			if err := m.LightApp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 53:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonElem", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommonElem == nil {
				m.CommonElem = &CommonElem{}
			}
			if err := m.CommonElem.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommonElem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommonElem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommonElem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceType", wireType)
			}
			m.ServiceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServiceType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PbElem", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PbElem = append(m.PbElem[:0], dAtA[iNdEx:postIndex]...)
			if m.PbElem == nil {
				m.PbElem = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BusinessType", wireType)
			}
			m.BusinessType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BusinessType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QQWalletMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QQWalletMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QQWalletMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AioBody", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AioBody == nil {
				m.AioBody = &QQWalletAioBody{}
			}
			if err := m.AioBody.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QQWalletAioBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QQWalletAioBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QQWalletAioBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendUin", wireType)
			}
			m.SendUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendUin |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sender == nil {
				m.Sender = &QQWalletAioElem{}
			}
			if err := m.Sender.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receiver", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Receiver == nil {
				m.Receiver = &QQWalletAioElem{}
			}
			if err := m.Receiver.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ChannelId = v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemplateId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.TemplateId = v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resend", wireType)
			}
			m.Resend = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Resend |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgPriority", wireType)
			}
			m.MsgPriority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgPriority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.RedType = v
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BillNo", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BillNo = append(m.BillNo[:0], dAtA[iNdEx:postIndex]...)
			if m.BillNo == nil {
				m.BillNo = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthKey = append(m.AuthKey[:0], dAtA[iNdEx:postIndex]...)
			if m.AuthKey == nil {
				m.AuthKey = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SessionType = v
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.MsgType = v
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvelOpeId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.EnvelOpeId = v
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = append(m.Name[:0], dAtA[iNdEx:postIndex]...)
			if m.Name == nil {
				m.Name = []byte{}
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ConfType = v
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgFrom", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.MsgFrom = v
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PcBody", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PcBody = append(m.PcBody[:0], dAtA[iNdEx:postIndex]...)
			if m.PcBody == nil {
				m.PcBody = []byte{}
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Index = append(m.Index[:0], dAtA[iNdEx:postIndex]...)
			if m.Index == nil {
				m.Index = []byte{}
			}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedChannel", wireType)
			}
			m.RedChannel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RedChannel |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GrapUin = append(m.GrapUin, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsg
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsg
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.GrapUin) == 0 {
					m.GrapUin = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsg
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GrapUin = append(m.GrapUin, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GrapUin", wireType)
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PbReserve", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PbReserve = append(m.PbReserve[:0], dAtA[iNdEx:postIndex]...)
			if m.PbReserve == nil {
				m.PbReserve = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QQWalletAioElem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QQWalletAioElem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QQWalletAioElem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Background", wireType)
			}
			m.Background = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Background |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			m.Icon = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Icon |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subtitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subtitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkUrl", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LinkUrl = append(m.LinkUrl[:0], dAtA[iNdEx:postIndex]...)
			if m.LinkUrl == nil {
				m.LinkUrl = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlackStripe", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlackStripe = append(m.BlackStripe[:0], dAtA[iNdEx:postIndex]...)
			if m.BlackStripe == nil {
				m.BlackStripe = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notice", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notice = append(m.Notice[:0], dAtA[iNdEx:postIndex]...)
			if m.Notice == nil {
				m.Notice = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TitleColor", wireType)
			}
			m.TitleColor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TitleColor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubtitleColor", wireType)
			}
			m.SubtitleColor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubtitleColor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionsPriority", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionsPriority = append(m.ActionsPriority[:0], dAtA[iNdEx:postIndex]...)
			if m.ActionsPriority == nil {
				m.ActionsPriority = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JumpUrl", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JumpUrl = append(m.JumpUrl[:0], dAtA[iNdEx:postIndex]...)
			if m.JumpUrl == nil {
				m.JumpUrl = []byte{}
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NativeIos", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NativeIos = append(m.NativeIos[:0], dAtA[iNdEx:postIndex]...)
			if m.NativeIos == nil {
				m.NativeIos = []byte{}
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NativeAndroid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NativeAndroid = append(m.NativeAndroid[:0], dAtA[iNdEx:postIndex]...)
			if m.NativeAndroid == nil {
				m.NativeAndroid = []byte{}
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IconUrl", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IconUrl = append(m.IconUrl[:0], dAtA[iNdEx:postIndex]...)
			if m.IconUrl == nil {
				m.IconUrl = []byte{}
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentColor", wireType)
			}
			m.ContentColor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContentColor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentBgColor", wireType)
			}
			m.ContentBgColor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContentBgColor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AioImageLeft", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AioImageLeft = append(m.AioImageLeft[:0], dAtA[iNdEx:postIndex]...)
			if m.AioImageLeft == nil {
				m.AioImageLeft = []byte{}
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AioImageRight", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AioImageRight = append(m.AioImageRight[:0], dAtA[iNdEx:postIndex]...)
			if m.AioImageRight == nil {
				m.AioImageRight = []byte{}
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CftImage", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CftImage = append(m.CftImage[:0], dAtA[iNdEx:postIndex]...)
			if m.CftImage == nil {
				m.CftImage = []byte{}
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PbReserve", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PbReserve = append(m.PbReserve[:0], dAtA[iNdEx:postIndex]...)
			if m.PbReserve == nil {
				m.PbReserve = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RichMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RichMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RichMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Template1", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Template1 = append(m.Template1[:0], dAtA[iNdEx:postIndex]...)
			if m.Template1 == nil {
				m.Template1 = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceId", wireType)
			}
			m.ServiceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServiceId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgResId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgResId = append(m.MsgResId[:0], dAtA[iNdEx:postIndex]...)
			if m.MsgResId == nil {
				m.MsgResId = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rand", wireType)
			}
			m.Rand = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rand |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CustomElem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CustomElem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CustomElem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = append(m.Desc[:0], dAtA[iNdEx:postIndex]...)
			if m.Desc == nil {
				m.Desc = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnumType", wireType)
			}
			m.EnumType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EnumType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ext = append(m.Ext[:0], dAtA[iNdEx:postIndex]...)
			if m.Ext == nil {
				m.Ext = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sound", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sound = append(m.Sound[:0], dAtA[iNdEx:postIndex]...)
			if m.Sound == nil {
				m.Sound = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Text) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Text: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Text: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Str", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Str = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Link = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attr6Buf", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attr6Buf = append(m.Attr6Buf[:0], dAtA[iNdEx:postIndex]...)
			if m.Attr6Buf == nil {
				m.Attr6Buf = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attr7Buf", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attr7Buf = append(m.Attr7Buf[:0], dAtA[iNdEx:postIndex]...)
			if m.Attr7Buf == nil {
				m.Attr7Buf = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buf", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buf = append(m.Buf[:0], dAtA[iNdEx:postIndex]...)
			if m.Buf == nil {
				m.Buf = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PbReserve", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PbReserve = append(m.PbReserve[:0], dAtA[iNdEx:postIndex]...)
			if m.PbReserve == nil {
				m.PbReserve = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Attr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Attr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Attr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodePage", wireType)
			}
			m.CodePage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CodePage |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Random", wireType)
			}
			m.Random = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Random |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Color", wireType)
			}
			m.Color = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Color |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Effect", wireType)
			}
			m.Effect = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Effect |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CharSet", wireType)
			}
			m.CharSet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CharSet |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PitchAndFamily", wireType)
			}
			m.PitchAndFamily = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PitchAndFamily |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FontName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FontName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReserveData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReserveData = append(m.ReserveData[:0], dAtA[iNdEx:postIndex]...)
			if m.ReserveData == nil {
				m.ReserveData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ptt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ptt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ptt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileType", wireType)
			}
			m.FileType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcUin", wireType)
			}
			m.SrcUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileUuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileUuid = append(m.FileUuid[:0], dAtA[iNdEx:postIndex]...)
			if m.FileUuid == nil {
				m.FileUuid = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileMd5", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileMd5 = append(m.FileMd5[:0], dAtA[iNdEx:postIndex]...)
			if m.FileMd5 == nil {
				m.FileMd5 = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserve", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reserve = append(m.Reserve[:0], dAtA[iNdEx:postIndex]...)
			if m.Reserve == nil {
				m.Reserve = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			m.FileId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerIp", wireType)
			}
			m.ServerIp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerIp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerPort", wireType)
			}
			m.ServerPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoolValid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BoolValid = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shortcut", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shortcut = append(m.Shortcut[:0], dAtA[iNdEx:postIndex]...)
			if m.Shortcut == nil {
				m.Shortcut = []byte{}
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileKey = append(m.FileKey[:0], dAtA[iNdEx:postIndex]...)
			if m.FileKey == nil {
				m.FileKey = []byte{}
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MagicPttIndex", wireType)
			}
			m.MagicPttIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MagicPttIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoiceSwitch", wireType)
			}
			m.VoiceSwitch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VoiceSwitch |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PttUrl", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PttUrl = append(m.PttUrl[:0], dAtA[iNdEx:postIndex]...)
			if m.PttUrl == nil {
				m.PttUrl = []byte{}
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupFileKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupFileKey = append(m.GroupFileKey[:0], dAtA[iNdEx:postIndex]...)
			if m.GroupFileKey == nil {
				m.GroupFileKey = []byte{}
			}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownPara", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DownPara = append(m.DownPara[:0], dAtA[iNdEx:postIndex]...)
			if m.DownPara == nil {
				m.DownPara = []byte{}
			}
			iNdEx = postIndex
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			m.Format = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Format |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PbReserve", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PbReserve = append(m.PbReserve[:0], dAtA[iNdEx:postIndex]...)
			if m.PbReserve == nil {
				m.PbReserve = []byte{}
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesPttUrls", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BytesPttUrls = append(m.BytesPttUrls, make([]byte, postIndex-iNdEx))
			copy(m.BytesPttUrls[len(m.BytesPttUrls)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadFlag", wireType)
			}
			m.DownloadFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DownloadFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OnlineImage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OnlineImage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OnlineImage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Guid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Guid = append(m.Guid[:0], dAtA[iNdEx:postIndex]...)
			if m.Guid == nil {
				m.Guid = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilePath", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilePath = append(m.FilePath[:0], dAtA[iNdEx:postIndex]...)
			if m.FilePath == nil {
				m.FilePath = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldVerSendFile", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OldVerSendFile = append(m.OldVerSendFile[:0], dAtA[iNdEx:postIndex]...)
			if m.OldVerSendFile == nil {
				m.OldVerSendFile = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotOnlineImage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotOnlineImage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotOnlineImage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileLen", wireType)
			}
			m.FileLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileLen |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DownloadPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldVerSendFile", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OldVerSendFile = append(m.OldVerSendFile[:0], dAtA[iNdEx:postIndex]...)
			if m.OldVerSendFile == nil {
				m.OldVerSendFile = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImgType", wireType)
			}
			m.ImgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ImgType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviewsImage", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviewsImage = append(m.PreviewsImage[:0], dAtA[iNdEx:postIndex]...)
			if m.PreviewsImage == nil {
				m.PreviewsImage = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PicMd5", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PicMd5 = append(m.PicMd5[:0], dAtA[iNdEx:postIndex]...)
			if m.PicMd5 == nil {
				m.PicMd5 = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PicHeight", wireType)
			}
			m.PicHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PicHeight |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PicWidth", wireType)
			}
			m.PicWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PicWidth |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Flag = append(m.Flag[:0], dAtA[iNdEx:postIndex]...)
			if m.Flag == nil {
				m.Flag = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThumbUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ThumbUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Original", wireType)
			}
			m.Original = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Original |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BigUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BigUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrigUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrigUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BizType", wireType)
			}
			m.BizType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BizType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpFaceBuf", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpFaceBuf = append(m.OpFaceBuf[:0], dAtA[iNdEx:postIndex]...)
			if m.OpFaceBuf == nil {
				m.OpFaceBuf = []byte{}
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldPicMd5", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OldPicMd5 = bool(v != 0)
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThumbWidth", wireType)
			}
			m.ThumbWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThumbWidth |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThumbHeight", wireType)
			}
			m.ThumbHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThumbHeight |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			m.FileId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowLen", wireType)
			}
			m.ShowLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShowLen |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadLen", wireType)
			}
			m.DownloadLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DownloadLen |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PbReserve", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PbReserve = append(m.PbReserve[:0], dAtA[iNdEx:postIndex]...)
			if m.PbReserve == nil {
				m.PbReserve = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotOnlineFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotOnlineFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotOnlineFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileType", wireType)
			}
			m.FileType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sig = append(m.Sig[:0], dAtA[iNdEx:postIndex]...)
			if m.Sig == nil {
				m.Sig = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileUuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileUuid = append(m.FileUuid[:0], dAtA[iNdEx:postIndex]...)
			if m.FileUuid == nil {
				m.FileUuid = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileMd5", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileMd5 = append(m.FileMd5[:0], dAtA[iNdEx:postIndex]...)
			if m.FileMd5 == nil {
				m.FileMd5 = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = append(m.FileName[:0], dAtA[iNdEx:postIndex]...)
			if m.FileName == nil {
				m.FileName = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Note", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Note = append(m.Note[:0], dAtA[iNdEx:postIndex]...)
			if m.Note == nil {
				m.Note = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved", wireType)
			}
			m.Reserved = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reserved |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subcmd", wireType)
			}
			m.Subcmd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Subcmd |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MicroCloud", wireType)
			}
			m.MicroCloud = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MicroCloud |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesFileUrls", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BytesFileUrls = append(m.BytesFileUrls, make([]byte, postIndex-iNdEx))
			copy(m.BytesFileUrls[len(m.BytesFileUrls)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadFlag", wireType)
			}
			m.DownloadFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DownloadFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DangerEvel", wireType)
			}
			m.DangerEvel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DangerEvel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LifeTime", wireType)
			}
			m.LifeTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LifeTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadTime", wireType)
			}
			m.UploadTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UploadTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 53:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbsFileType", wireType)
			}
			m.AbsFileType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AbsFileType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 54:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientType", wireType)
			}
			m.ClientType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 55:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpireTime", wireType)
			}
			m.ExpireTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpireTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 56:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PbReserve", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PbReserve = append(m.PbReserve[:0], dAtA[iNdEx:postIndex]...)
			if m.PbReserve == nil {
				m.PbReserve = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransElem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransElem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransElem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElemType", wireType)
			}
			m.ElemType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ElemType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElemValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ElemValue = append(m.ElemValue[:0], dAtA[iNdEx:postIndex]...)
			if m.ElemValue == nil {
				m.ElemValue = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtraInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtraInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtraInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nick", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nick = append(m.Nick[:0], dAtA[iNdEx:postIndex]...)
			if m.Nick == nil {
				m.Nick = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupCard", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupCard = append(m.GroupCard[:0], dAtA[iNdEx:postIndex]...)
			if m.GroupCard == nil {
				m.GroupCard = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupMask", wireType)
			}
			m.GroupMask = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupMask |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgTailId", wireType)
			}
			m.MsgTailId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgTailId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderTitle", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SenderTitle = append(m.SenderTitle[:0], dAtA[iNdEx:postIndex]...)
			if m.SenderTitle == nil {
				m.SenderTitle = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApnsTips", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApnsTips = append(m.ApnsTips[:0], dAtA[iNdEx:postIndex]...)
			if m.ApnsTips == nil {
				m.ApnsTips = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uin", wireType)
			}
			m.Uin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgStateFlag", wireType)
			}
			m.MsgStateFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgStateFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApnsSoundType", wireType)
			}
			m.ApnsSoundType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApnsSoundType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewGroupFlag", wireType)
			}
			m.NewGroupFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewGroupFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filename", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filename = append(m.Filename[:0], dAtA[iNdEx:postIndex]...)
			if m.Filename == nil {
				m.Filename = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = append(m.FileId[:0], dAtA[iNdEx:postIndex]...)
			if m.FileId == nil {
				m.FileId = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchId = append(m.BatchId[:0], dAtA[iNdEx:postIndex]...)
			if m.BatchId == nil {
				m.BatchId = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileKey = append(m.FileKey[:0], dAtA[iNdEx:postIndex]...)
			if m.FileKey == nil {
				m.FileKey = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mark", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mark = append(m.Mark[:0], dAtA[iNdEx:postIndex]...)
			if m.Mark == nil {
				m.Mark = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchItemId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchItemId = append(m.BatchItemId[:0], dAtA[iNdEx:postIndex]...)
			if m.BatchItemId == nil {
				m.BatchItemId = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeedMsgTime", wireType)
			}
			m.FeedMsgTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FeedMsgTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PbReserve", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PbReserve = append(m.PbReserve[:0], dAtA[iNdEx:postIndex]...)
			if m.PbReserve == nil {
				m.PbReserve = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnonymousGroupMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnonymousGroupMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnonymousGroupMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnonId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AnonId = append(m.AnonId[:0], dAtA[iNdEx:postIndex]...)
			if m.AnonId == nil {
				m.AnonId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnonNick", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AnonNick = append(m.AnonNick[:0], dAtA[iNdEx:postIndex]...)
			if m.AnonNick == nil {
				m.AnonNick = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadPortrait", wireType)
			}
			m.HeadPortrait = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeadPortrait |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpireTime", wireType)
			}
			m.ExpireTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpireTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BubbleId", wireType)
			}
			m.BubbleId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BubbleId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankColor", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RankColor = append(m.RankColor[:0], dAtA[iNdEx:postIndex]...)
			if m.RankColor == nil {
				m.RankColor = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileUuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileUuid = append(m.FileUuid[:0], dAtA[iNdEx:postIndex]...)
			if m.FileUuid == nil {
				m.FileUuid = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileMd5", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileMd5 = append(m.FileMd5[:0], dAtA[iNdEx:postIndex]...)
			if m.FileMd5 == nil {
				m.FileMd5 = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = append(m.FileName[:0], dAtA[iNdEx:postIndex]...)
			if m.FileName == nil {
				m.FileName = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileFormat", wireType)
			}
			m.FileFormat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileFormat |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileTime", wireType)
			}
			m.FileTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThumbWidth", wireType)
			}
			m.ThumbWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThumbWidth |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThumbHeight", wireType)
			}
			m.ThumbHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThumbHeight |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThumbFileMd5", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ThumbFileMd5 = append(m.ThumbFileMd5[:0], dAtA[iNdEx:postIndex]...)
			if m.ThumbFileMd5 == nil {
				m.ThumbFileMd5 = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = append(m.Source[:0], dAtA[iNdEx:postIndex]...)
			if m.Source == nil {
				m.Source = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThumbFileSize", wireType)
			}
			m.ThumbFileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThumbFileSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BusiType", wireType)
			}
			m.BusiType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BusiType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromChatType", wireType)
			}
			m.FromChatType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromChatType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToChatType", wireType)
			}
			m.ToChatType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToChatType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoolSupportProgressive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BoolSupportProgressive = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileWidth", wireType)
			}
			m.FileWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileWidth |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHeight", wireType)
			}
			m.FileHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileHeight |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubBusiType", wireType)
			}
			m.SubBusiType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubBusiType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoAttr", wireType)
			}
			m.VideoAttr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VideoAttr |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesThumbFileUrls", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BytesThumbFileUrls = append(m.BytesThumbFileUrls, make([]byte, postIndex-iNdEx))
			copy(m.BytesThumbFileUrls[len(m.BytesThumbFileUrls)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesVideoFileUrls", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BytesVideoFileUrls = append(m.BytesVideoFileUrls, make([]byte, postIndex-iNdEx))
			copy(m.BytesVideoFileUrls[len(m.BytesVideoFileUrls)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThumbDownloadFlag", wireType)
			}
			m.ThumbDownloadFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThumbDownloadFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoDownloadFlag", wireType)
			}
			m.VideoDownloadFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VideoDownloadFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PbReserve", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PbReserve = append(m.PbReserve[:0], dAtA[iNdEx:postIndex]...)
			if m.PbReserve == nil {
				m.PbReserve = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SourceMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SourceMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SourceMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OrigSeqs = append(m.OrigSeqs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsg
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsg
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OrigSeqs) == 0 {
					m.OrigSeqs = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsg
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OrigSeqs = append(m.OrigSeqs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OrigSeqs", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderUin", wireType)
			}
			m.SenderUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SenderUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			m.Flag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Elems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Elems = append(m.Elems, &Elem{})
			if err := m.Elems[len(m.Elems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RichMsg", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RichMsg = append(m.RichMsg[:0], dAtA[iNdEx:postIndex]...)
			if m.RichMsg == nil {
				m.RichMsg = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PbReserve", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PbReserve = append(m.PbReserve[:0], dAtA[iNdEx:postIndex]...)
			if m.PbReserve == nil {
				m.PbReserve = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcMsg", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcMsg = append(m.SrcMsg[:0], dAtA[iNdEx:postIndex]...)
			if m.SrcMsg == nil {
				m.SrcMsg = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToUin", wireType)
			}
			m.ToUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TroopName", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TroopName = append(m.TroopName[:0], dAtA[iNdEx:postIndex]...)
			if m.TroopName == nil {
				m.TroopName = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Face) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Face: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Face: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Old", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Old = append(m.Old[:0], dAtA[iNdEx:postIndex]...)
			if m.Old == nil {
				m.Old = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buf", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buf = append(m.Buf[:0], dAtA[iNdEx:postIndex]...)
			if m.Buf == nil {
				m.Buf = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LightAppElem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LightAppElem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LightAppElem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgResid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgResid = append(m.MsgResid[:0], dAtA[iNdEx:postIndex]...)
			if m.MsgResid == nil {
				m.MsgResid = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CustomFace) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CustomFace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CustomFace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Guid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Guid = append(m.Guid[:0], dAtA[iNdEx:postIndex]...)
			if m.Guid == nil {
				m.Guid = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shortcut", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shortcut = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buffer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buffer = append(m.Buffer[:0], dAtA[iNdEx:postIndex]...)
			if m.Buffer == nil {
				m.Buffer = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Flag = append(m.Flag[:0], dAtA[iNdEx:postIndex]...)
			if m.Flag == nil {
				m.Flag = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OldData = append(m.OldData[:0], dAtA[iNdEx:postIndex]...)
			if m.OldData == nil {
				m.OldData = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			m.FileId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerIp", wireType)
			}
			m.ServerIp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerIp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerPort", wireType)
			}
			m.ServerPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileType", wireType)
			}
			m.FileType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Useful", wireType)
			}
			m.Useful = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Useful |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Md5", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Md5 = append(m.Md5[:0], dAtA[iNdEx:postIndex]...)
			if m.Md5 == nil {
				m.Md5 = []byte{}
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThumbUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ThumbUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BigUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BigUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrigUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrigUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BizType", wireType)
			}
			m.BizType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BizType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatIndex", wireType)
			}
			m.RepeatIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RepeatIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatImage", wireType)
			}
			m.RepeatImage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RepeatImage |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageType", wireType)
			}
			m.ImageType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ImageType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			m.Source = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Source |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Origin", wireType)
			}
			m.Origin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Origin |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThumbWidth", wireType)
			}
			m.ThumbWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThumbWidth |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThumbHeight", wireType)
			}
			m.ThumbHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThumbHeight |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowLen", wireType)
			}
			m.ShowLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShowLen |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadLen", wireType)
			}
			m.DownloadLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DownloadLen |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field X400Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.X400Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X400Width", wireType)
			}
			m.X400Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X400Width |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X400Height", wireType)
			}
			m.X400Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X400Height |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PbReserve", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PbReserve = append(m.PbReserve[:0], dAtA[iNdEx:postIndex]...)
			if m.PbReserve == nil {
				m.PbReserve = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContentHead) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContentHead: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContentHead: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PkgNum", wireType)
			}
			m.PkgNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PkgNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PkgIndex", wireType)
			}
			m.PkgIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PkgIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DivSeq", wireType)
			}
			m.DivSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DivSeq |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoReply", wireType)
			}
			m.AutoReply = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoReply |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageHead) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageHead: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageHead: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromUin", wireType)
			}
			m.FromUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToUin", wireType)
			}
			m.ToUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgType", wireType)
			}
			m.MsgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field C2CCmd", wireType)
			}
			m.C2CCmd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.C2CCmd |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgSeq", wireType)
			}
			m.MsgSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgSeq |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgTime", wireType)
			}
			m.MsgTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgUid", wireType)
			}
			m.MsgUid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgUid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field C2CTmpMsgHead", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.C2CTmpMsgHead == nil {
				m.C2CTmpMsgHead = &C2CTempMessageHead{}
			}
			if err := m.C2CTmpMsgHead.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GroupInfo == nil {
				m.GroupInfo = &GroupInfo{}
			}
			if err := m.GroupInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromAppid", wireType)
			}
			m.FromAppid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromAppid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromInstid", wireType)
			}
			m.FromInstid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromInstid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserActive", wireType)
			}
			m.UserActive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserActive |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscussInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DiscussInfo == nil {
				m.DiscussInfo = &DiscussInfo{}
			}
			if err := m.DiscussInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromNick", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromNick = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthUin", wireType)
			}
			m.AuthUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthNick", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthNick = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgFlag", wireType)
			}
			m.MsgFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthRemark", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthRemark = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MutiltransHead", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MutiltransHead == nil {
				m.MutiltransHead = &MutilTransHead{}
			}
			if err := m.MutiltransHead.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgInstCtrl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MsgInstCtrl == nil {
				m.MsgInstCtrl = &InstCtrl{}
			}
			if err := m.MsgInstCtrl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicAccountGroupSendFlag", wireType)
			}
			m.PublicAccountGroupSendFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PublicAccountGroupSendFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WseqInC2CMsghead", wireType)
			}
			m.WseqInC2CMsghead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WseqInC2CMsghead |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpid", wireType)
			}
			m.Cpid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cpid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtGroupKeyInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExtGroupKeyInfo == nil {
				m.ExtGroupKeyInfo = &ExtGroupKeyInfo{}
			}
			if err := m.ExtGroupKeyInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiCompatibleText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MultiCompatibleText = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthSex", wireType)
			}
			m.AuthSex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthSex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSrcMsg", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSrcMsg = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupCode", wireType)
			}
			m.GroupCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupCode |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupType", wireType)
			}
			m.GroupType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupInfoSeq", wireType)
			}
			m.GroupInfoSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupInfoSeq |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupCard", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupCard = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupRank", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupRank = append(m.GroupRank[:0], dAtA[iNdEx:postIndex]...)
			if m.GroupRank == nil {
				m.GroupRank = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupLevel", wireType)
			}
			m.GroupLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupLevel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupCardType", wireType)
			}
			m.GroupCardType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupCardType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupName", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupName = append(m.GroupName[:0], dAtA[iNdEx:postIndex]...)
			if m.GroupName == nil {
				m.GroupName = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiscussInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiscussInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiscussInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscussUin", wireType)
			}
			m.DiscussUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiscussUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscussType", wireType)
			}
			m.DiscussType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiscussType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscussInfoSeq", wireType)
			}
			m.DiscussInfoSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiscussInfoSeq |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscussRemark", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiscussRemark = append(m.DiscussRemark[:0], dAtA[iNdEx:postIndex]...)
			if m.DiscussRemark == nil {
				m.DiscussRemark = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscussName", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiscussName = append(m.DiscussName[:0], dAtA[iNdEx:postIndex]...)
			if m.DiscussName == nil {
				m.DiscussName = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MutilTransHead) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MutilTransHead: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MutilTransHead: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgId", wireType)
			}
			m.MsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2CTempMessageHead) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2CTempMessageHead: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2CTempMessageHead: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field C2CType", wireType)
			}
			m.C2CType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.C2CType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceType", wireType)
			}
			m.ServiceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServiceType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupUin", wireType)
			}
			m.GroupUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupCode", wireType)
			}
			m.GroupCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupCode |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sig = append(m.Sig[:0], dAtA[iNdEx:postIndex]...)
			if m.Sig == nil {
				m.Sig = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigType", wireType)
			}
			m.SigType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SigType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromPhone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromPhone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToPhone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToPhone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockDisplay", wireType)
			}
			m.LockDisplay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockDisplay |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectionFlag", wireType)
			}
			m.DirectionFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DirectionFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reserved = append(m.Reserved[:0], dAtA[iNdEx:postIndex]...)
			if m.Reserved == nil {
				m.Reserved = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstCtrl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstCtrl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstCtrl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgSendToInst", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgSendToInst = append(m.MsgSendToInst, &InstInfo{})
			if err := m.MsgSendToInst[len(m.MsgSendToInst)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgExcludeInst", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgExcludeInst = append(m.MsgExcludeInst, &InstInfo{})
			if err := m.MsgExcludeInst[len(m.MsgExcludeInst)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgFromInst", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MsgFromInst == nil {
				m.MsgFromInst = &InstInfo{}
			}
			if err := m.MsgFromInst.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Apppid", wireType)
			}
			m.Apppid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Apppid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instid", wireType)
			}
			m.Instid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Instid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			m.Platform = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Platform |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnumDeviceType", wireType)
			}
			m.EnumDeviceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EnumDeviceType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtGroupKeyInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtGroupKeyInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtGroupKeyInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurMaxSeq", wireType)
			}
			m.CurMaxSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurMaxSeq |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurTime", wireType)
			}
			m.CurTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncCookie) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncCookie: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncCookie: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time1", wireType)
			}
			m.Time1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time1 |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ran1", wireType)
			}
			m.Ran1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ran1 |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ran2", wireType)
			}
			m.Ran2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ran2 |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Const1", wireType)
			}
			m.Const1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Const1 |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Const2", wireType)
			}
			m.Const2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Const2 |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Const3", wireType)
			}
			m.Const3 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Const3 |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSyncTime", wireType)
			}
			m.LastSyncTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastSyncTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Const4", wireType)
			}
			m.Const4 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Const4 |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransMsgInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransMsgInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransMsgInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromUin", wireType)
			}
			m.FromUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToUin", wireType)
			}
			m.ToUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgType", wireType)
			}
			m.MsgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgSubtype", wireType)
			}
			m.MsgSubtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgSubtype |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgSeq", wireType)
			}
			m.MsgSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgSeq |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgUid", wireType)
			}
			m.MsgUid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgUid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgTime", wireType)
			}
			m.MsgTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RealMsgTime", wireType)
			}
			m.RealMsgTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RealMsgTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NickName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NickName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgData = append(m.MsgData[:0], dAtA[iNdEx:postIndex]...)
			if m.MsgData == nil {
				m.MsgData = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SvrIp", wireType)
			}
			m.SvrIp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SvrIp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtGroupKeyInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExtGroupKeyInfo == nil {
				m.ExtGroupKeyInfo = &ExtGroupKeyInfo{}
			}
			if err := m.ExtGroupKeyInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeneralFlag", wireType)
			}
			m.GeneralFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GeneralFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GeneralFlags) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GeneralFlags: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GeneralFlags: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BubbleDiyTextId", wireType)
			}
			m.BubbleDiyTextId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BubbleDiyTextId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupFlagNew", wireType)
			}
			m.GroupFlagNew = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupFlagNew |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uin", wireType)
			}
			m.Uin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RpId = append(m.RpId[:0], dAtA[iNdEx:postIndex]...)
			if m.RpId == nil {
				m.RpId = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrpFold", wireType)
			}
			m.PrpFold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrpFold |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LongTextFlag", wireType)
			}
			m.LongTextFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LongTextFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LongTextResid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LongTextResid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupType", wireType)
			}
			m.GroupType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToUinFlag", wireType)
			}
			m.ToUinFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToUinFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlamourLevel", wireType)
			}
			m.GlamourLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GlamourLevel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberLevel", wireType)
			}
			m.MemberLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberLevel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupRankSeq", wireType)
			}
			m.GroupRankSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupRankSeq |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OlympicTorch", wireType)
			}
			m.OlympicTorch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OlympicTorch |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BabyqGuideMsgCookie", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BabyqGuideMsgCookie = append(m.BabyqGuideMsgCookie[:0], dAtA[iNdEx:postIndex]...)
			if m.BabyqGuideMsgCookie == nil {
				m.BabyqGuideMsgCookie = []byte{}
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uin32ExpertFlag", wireType)
			}
			m.Uin32ExpertFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uin32ExpertFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BubbleSubId", wireType)
			}
			m.BubbleSubId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BubbleSubId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendantId", wireType)
			}
			m.PendantId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PendantId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpIndex", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RpIndex = append(m.RpIndex[:0], dAtA[iNdEx:postIndex]...)
			if m.RpIndex == nil {
				m.RpIndex = []byte{}
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PbReserve", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PbReserve = append(m.PbReserve[:0], dAtA[iNdEx:postIndex]...)
			if m.PbReserve == nil {
				m.PbReserve = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PbMultiMsgItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PbMultiMsgItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PbMultiMsgItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buffer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Buffer == nil {
				m.Buffer = &PbMultiMsgNew{}
			}
			if err := m.Buffer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PbMultiMsgNew) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PbMultiMsgNew: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PbMultiMsgNew: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = append(m.Msg, &Message{})
			if err := m.Msg[len(m.Msg)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PbMultiMsgTransmit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PbMultiMsgTransmit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PbMultiMsgTransmit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = append(m.Msg, &Message{})
			if err := m.Msg[len(m.Msg)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PbItemList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PbItemList = append(m.PbItemList, &PbMultiMsgItem{})
			if err := m.PbItemList[len(m.PbItemList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgElemInfoServtype3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgElemInfo_servtype3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgElemInfo_servtype3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlashTroopPic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FlashTroopPic == nil {
				m.FlashTroopPic = &CustomFace{}
			}
			if err := m.FlashTroopPic.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlashC2CPic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FlashC2CPic == nil {
				m.FlashC2CPic = &NotOnlineImage{}
			}
			if err := m.FlashC2CPic.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgElemInfoServtype33) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgElemInfo_servtype33: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgElemInfo_servtype33: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = append(m.Text[:0], dAtA[iNdEx:postIndex]...)
			if m.Text == nil {
				m.Text = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compat", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Compat = append(m.Compat[:0], dAtA[iNdEx:postIndex]...)
			if m.Compat == nil {
				m.Compat = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buf", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buf = append(m.Buf[:0], dAtA[iNdEx:postIndex]...)
			if m.Buf == nil {
				m.Buf = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubMsgType0X4Body) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubMsgType0x4Body: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubMsgType0x4Body: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotOnlineFile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NotOnlineFile == nil {
				m.NotOnlineFile = &NotOnlineFile{}
			}
			if err := m.NotOnlineFile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgTime", wireType)
			}
			m.MsgTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnlineFileForPolyToOffline", wireType)
			}
			m.OnlineFileForPolyToOffline = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnlineFileForPolyToOffline |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResvAttr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResvAttr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResvAttr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageShow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ImageShow == nil {
				m.ImageShow = &AnimationImageShow{}
			}
			if err := m.ImageShow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnimationImageShow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnimationImageShow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnimationImageShow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectId", wireType)
			}
			m.EffectId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EffectId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnimationParam", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AnimationParam = append(m.AnimationParam[:0], dAtA[iNdEx:postIndex]...)
			if m.AnimationParam == nil {
				m.AnimationParam = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UinTypeUserDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UinTypeUserDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UinTypeUserDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromUinType", wireType)
			}
			m.FromUinType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromUinType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromGroupCode", wireType)
			}
			m.FromGroupCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromGroupCode |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetGroupMsgReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetGroupMsgReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetGroupMsgReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupCode", wireType)
			}
			m.GroupCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupCode |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeginSeq", wireType)
			}
			m.BeginSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeginSeq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndSeq", wireType)
			}
			m.EndSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndSeq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			m.Filter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Filter |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberSeq", wireType)
			}
			m.MemberSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberSeq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicGroup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PublicGroup = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShieldFlag", wireType)
			}
			m.ShieldFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShieldFlag |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaveTrafficFlag", wireType)
			}
			m.SaveTrafficFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SaveTrafficFlag |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetGroupMsgResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetGroupMsgResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetGroupMsgResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errmsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errmsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupCode", wireType)
			}
			m.GroupCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupCode |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReturnBeginSeq", wireType)
			}
			m.ReturnBeginSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReturnBeginSeq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReturnEndSeq", wireType)
			}
			m.ReturnEndSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReturnEndSeq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = append(m.Msg, &Message{})
			if err := m.Msg[len(m.Msg)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMsg(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMsg
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMsg
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMsg
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMsg        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMsg          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMsg = fmt.Errorf("proto: unexpected end of group")
)
